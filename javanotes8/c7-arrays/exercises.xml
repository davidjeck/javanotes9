<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE exercises SYSTEM "../javanotes8.dtd" >

<exercises>

<exercise>
<exercise-question><p>Write a subroutine that creates an ArrayList containing several <i>different</i>
random integers in the range from 1 up to some specified maximum.  The number of integers and the
maximum allowed value for the integers should be parameters to the subroutine.  Write a <code>main()</code>
routine to test your subroutine.</p>
</exercise-question>
<exercise-discuss><p>The exercise asks for an ArrayList containing integers. That has to mean
using <atype>ArrayList&lt;Integer&gt;</atype>, since an ArrayList can't contain values of
type <ptype>int</ptype>.  The problem is pretty easy: Start with an empty list,
then generate random integers and add them to the list until you have as many integers as you
want.  Since all the integers in the list must be different, before adding an integer to the
list, we need to test whether that integer is already in the list.  One way to do that is
with the <code>indexOf()</code> method from the ArrayList class.  If <code>numbers</code>
is an <atype>ArrayList&lt;Integer&gt;</atype> and <code>num</code> is an <ptype>int</ptype>,
then <code>numbers.indexOf(num)</code> returns -1 if <code>num</code> is <b>not</b> in the list.
(Note that this relies on autoboxing to convert <code>num</code> into an object of type
<classname>Integer</classname>, since <code>indexOf()</code> requires an object as its parameter.)
To create the list of numbers, we just add integers to the list until it reaches the desired size.
Assuming that <code>count</code> is the desired number of integers and <code>max</code> is the
maximum allowed value for the integers, this can be done with</p>
<pre>ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
while (numbers.size() &lt; count) {
    int num = (int)(Math.random()*max) + 1;
    if ( numbers.indexOf(num) == -1 )
        numbers.add( num );
}</pre>
<np>This code is the heart of the solution.  There is one problem, however.
If <code>count&nbsp;&gt;&nbsp;max</code>, then it's impossible to get <code>count</code>
different integers in the range from 1 to <code>max</code>, because there aren't that
many different numbers in the range!  In fact, the <code>while</code> loop will be
an infinite loop in that case since the size of the ArrayList can never become larger than
<code>max</code>.  My solution avoids the infinite loop by throwing
an <classname>IllegalArgumentException</classname> when <code>count&nbsp;&gt;&nbsp;max</code>.
You can see the complete subroutine, and a <code>main()</code> routine that tests it, below.</np>
</exercise-discuss>
<exercise-code>
<pre><prog name="SeveralRandomIntegers">import java.util.ArrayList;


public class SeveralRandomIntegers {
    
    /**
     * Creates an ArrayList that contains several integers chosen at
     * random from a specified range of values.  All the integers
     * in the list are different.
     * @param count  the number of random integers to be created
     * @param max  the integers are chosen in the range 1 to max, inclusive
     * @return an ArrayList containing the integers.  The integers are
     *    random and are in a random order.
     * @throws IllegalArgumentException if max is greater than count.  In
     *    that case there are fewer than count different integers in the
     *    range 1 to max.
     */
    public static ArrayList&lt;Integer&gt; makeRandomInts( int count, int max ) {
        if (count &gt; max) {
            throw new IllegalArgumentException("Can't have " + count + 
                    " different integers in the range  1 to " + max);
        }
        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
        while (numbers.size() &lt; count) {
            int num = (int)(Math.random()*max) + 1;
            if ( numbers.indexOf(num) == -1 )
                numbers.add( num );
        }
        return numbers;
    }
    
    private static void printList( ArrayList&lt;Integer&gt; numbers ) {
        System.out.print("    [ ");
        for (int i = 0; i &lt; numbers.size(); i++) {
            if (i &gt; 0)
                System.out.print(", ");
            System.out.print( numbers.get(i) );
        }
        System.out.println(" ]");
    }
    
    public static void main(String[] args) {
        System.out.println("10 integers chosen from the range 1 to 100:");
        for (int i = 0; i &lt; 8; i++)
            printList( makeRandomInts(10,100) );
        System.out.println();
        System.out.println("10 integers chosen from the range 1 to 10:");
        for (int i = 0; i &lt; 3; i++)
            printList( makeRandomInts(10,10) );
        System.out.println();
        System.out.println("25 integers chosen from the range 1 to 10000:");
        printList( makeRandomInts(25,10000) );
        System.out.println();
        System.out.println("End with an exception!");
        makeRandomInts(10,9);
    }

}
</prog></pre>
</exercise-code>
</exercise>



<exercise>
<exercise-question><p>Suppose that <code>M</code> is a two-dimensional array that
has <code>R</code> rows and <code>C</code> columns.  The <newword>transpose</newword>
of <code>M</code> is defined to be an array <code>T</code> that has <code>C</code> rows
and <code>R</code> columns such that <code>T[i][j]&nbsp;=&nbsp;M[j][i]</code> for 
each <code>i</code> and <code>j</code>.  Write a function that takes an array
of type <atype>int[][]</atype> as a parameter, and returns the transpose of that array.
(Assume that the parameter is a typical 2D array in which all the rows have the same length.)
Also write a subroutine to print a 2D array of integers in neat rows and columns, and
include a <code>main()</code> routine to test your work.</p>
</exercise-question>
<exercise-discuss><p>To create the transpose, we need to know how many rows and
how many columns are in the original array.  As noted in <localref href="arrays.5.1"/>,
the number of rows in a 2D array <code>A</code> is given by <code>A.length</code>,
and the number of columns is <code>A[0].length</code>.  (<code>A[0].length</code> is
the length of the first row of <code>A</code>, which is the same as the number of
columns in <code>A</code>.  Remember that all rows have the same length.)  Given that,
we can create a transpose array of the correct size, and&mdash;with a little care to get
the indices right&mdash;we can copy all the items
from the original array into the transpose.  If <code>matrix</code> is the original
array, then the transpose can be created with</p>
<pre>int[][] transpose;
int R = matrix.length;     // the number of rows in matrix
int C = matrix[0].length;  // the number of columns in matrix
transpose = new int[C][R];
for ( int i = 0; i &lt; C; i++) { // goes through ROWS of the transpose
    for ( int j = 0; j &lt; R; j++ ) { // goes through COLUMNS of the transpose
        transpose[i][j] = matrix[j][i];
    }
}</pre>
<p>One other note of interest is in the code for printing the array.  See the 
comments on the source code below.</p>
<p>By the way, one purpose of this exercise was to remind you that arrays can be parameters and
they can be the return value of a function.  In this case, the parameter type
and the return type for the function are both given by <atype>int[][]</atype>.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="TransposeMatrix">
public class TransposeMatrix {
    
    /**
     * Creates the transpose of a given 2D array of integers.
     * @param matrix  the original array
     * @return the transpose of matrix
     */
    public static int[][] computeTranspose( int[][] matrix ) {
        int[][] transpose;
        int R = matrix.length;     // the number of rows in matrix
        int C = matrix[0].length;  // the number of columns in matrix
        transpose = new int[C][R];
        for ( int i = 0; i &lt; C; i++) { // goes through ROWS of the transpose
            for ( int j = 0; j &lt; R; j++ ) { // goes through COLUMNS of the transpose
                transpose[i][j] = matrix[j][i];
            }
        }
        return transpose;
    }
    
    /**
     * Prints out the items of a 2D array of ints in rows and columns,
     * with 6 spaces in each column.
     */
    public static void print( int[][] array ) {
            // Note that this uses a for-each loop where the loop
            // control variable is of type int[].  This works because
            // a 2D array is actually a 1D array of 1D arrays, where
            // each 1D array is one of the rows of the 2D array.
        for ( int[] row : array ) { 
                // print out one row from the array
            System.out.print("   ");
            for ( int item : row ) {
                   // print with 1 blank space and 5 spaces for the integer;
                   // if an integer needs more than 5 spaces, the columns will
                   // be messed up, but all the integers will still be readable.
                System.out.printf(" %5d", item); 
            }
            System.out.println();
        }
    }
    
    /**
     * Test the subroutines by creating two arrays and printing them and
     * their transposes.  The arrays are constructed so that it is easy
     * to see that the transposes are correct.
     */
    public static void main(String[] args) {
        int[][] orig = {
                { 1, 2, 3, 4, 5, 6 },
                { 10, 20, 30, 40, 50, 60 },
                { 100, 200, 300, 400, 500, 600 }
        };
        System.out.println("Original matrix:");
        System.out.println();
        print(orig);
        System.out.println();
        System.out.println("The transpose:");
        System.out.println();
        print( computeTranspose(orig) );
        System.out.println();
        System.out.println();

        orig = new int[][] {
                {1, 1, 1, 1, 1, 1, 1},
                {2, 2, 2, 2, 2, 2, 2},
                {3, 3, 3, 3, 3, 3, 3},
                {4, 4, 4, 4, 4, 4, 4},
                {5, 5, 5, 5, 5, 5, 5},
                {6, 6, 6, 6, 6, 6, 6},
                {7, 7, 7, 7, 7, 7, 7},
        };
        System.out.println("Original matrix:");
        System.out.println();
        print(orig);
        System.out.println();
        System.out.println("The transpose:");
        System.out.println();
        print( computeTranspose(orig) );
        System.out.println();

    }

}
</prog></pre>
</exercise-code>
</exercise>



<exercise>
<exercise-question><p>In <localref href="arrays.4.4"/>, it is mentioned that the
standard sorting method <code>Arrays.sort()</code> is much faster and efficient
than selection sort.  Write a program to test this claim.  To be specific, your
program should create a large array filled with random real numbers.  It should
use both <code>Arrays.sort()</code> and <code>selectionSort()</code> to sort
the array, and it should time how long it takes to perform each sort.  Furthermore,
it should do the same thing for a large array of random <classname>Strings</classname>.
To find the times, you can use <code>System.currentTimeMillis()</code>
(see <localref href="basics.3.1"/> and the example <sourceref chapter="2" href="TimedComputation.java"/>).</p>
</exercise-question>
<exercise-discuss><p>This exercise is most interesting for the results of the timing
experiments, but one point of interest is how to make a "random string."  In my program, 
I make a string containing uppercase letters, with a random length:</p>
<pre>private static String randomString() {
    int length = 5 + (int)(21*Math.random());
    StringBuilder str = new StringBuilder();
    for (int i = 0; i &lt; length; i++) {
        char ch = (char)('A' + (int)(26*Math.random())); // a random letter
        str.append(ch);
    }
    return str.toString();
}</pre>
<np>This method is then used to fill an array with random strings.  I wrote methods for
creating random arrays of a given size.  I used <code>Arrays.copyOf()</code> to make
copies of the arrays.  I need two copies of each random array, since I
want to apply <code>selectionSort()</code> and <code>Arrays.sort()</code> to identical data.
So the arrays are created with</np>
<pre>numberList1 = randomNumbers(SIZE);
numberList2 = Arrays.copyOf(numberList1, SIZE);
stringList1 = randomStrings(SIZE);
stringList2 = Arrays.copyOf(stringList1, SIZE);
</pre>
<np>where <code>SIZE</code> is a constant.  (By using a constant here, I can easily adapt
the program to run with different array sizes.)</np>
<p>The selection sort algorithm is copied from <localref href="arrays.4.4"/>.  We actually need
two <code>selectionSort</code> methods, one to sort numbers an one to sort strings.
You will see that my program includes tests of those methods.  Without that test, I wouldn't
have been confident that my subroutines were sorting the arrays correctly.</p>
<p>The code for timing the sorting algorithms is straightforward.
Here are sort times from my program.  Note that <code>Arrays.sort()</code> is much faster than
<code>selectionSort</code>.  Also, it takes longer to sort strings that it takes to
sort numbers, since comparing two strings takes longer than comparing two numbers.
The advantage of <code>Arrays.sort()</code> is greater for strings than it is for numbers.
I'm not sure why that happens.</p>
<pre>Milliseconds to sort 100000 numbers with selectionSort: 14299
Milliseconds to sort 100000 numbers with Arrays.sort(): 79
Milliseconds to sort 100000 strings with selectionSort: 251792
Milliseconds to sort 100000 strings with Arrays.sort(): 216</pre>
<p>You can try running the program with different array sizes.  A large difference is
noticeable even for arrays of size 1000, although all of the times are rather short in that
case.  The advantage of <code>Arrays.sort()</code> increases as the array size increases.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="SortExperiments">import java.util.Arrays;

public class SortExperiments {
    
    final static int SIZE = 100000; // The length of arrays that will be sorted.
    
    /**
     * Creates a random string.  The length of the string is between 5 and 25,
     * and it is made up of randomly selected uppercase letters.
     */
    private static String randomString() {
        int length = 5 + (int)(21*Math.random());
        StringBuilder str = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            char ch = (char)('A' + (int)(26*Math.random()));
            str.append(ch);
        }
        return str.toString();
    }
    
    /**
     * Creates an array of random real numbers.  The items in the array
     * are random numbers in the range 0.0 to 1.0.
     * @param count The length of the array that is created.
     */
    private static double[] randomNumbers(int count) {
        double[] numbers = new double[count];
        for (int i = 0; i &lt; count; i++)
            numbers[i] = Math.random();
        return numbers;
    }
    
    /**
     * Creates an array of random strings. The items in the
     * array are created by calling the function randomString();
     * @param count the size of the array that is created
     */
    private static String[] randomStrings(int count) {
        String[] strings = new String[count];
        for (int i = 0; i &lt; count; i++)
            strings[i] = randomString();
        return strings;
    }
    
    /**
     * Sort an array of real numbers using the selection sort algorithm.
     */
    private static void selectionSort(double[] numbers) {
        for (int top = numbers.length-1; top > 0; top-- ) {
            int maxloc = 0;
            for (int i = 1; i &lt;= top; i++) {
                if (numbers[i] &gt; numbers[maxloc])
                    maxloc = i;
            }
            double temp = numbers[top];
            numbers[top] = numbers[maxloc];
            numbers[maxloc] = temp;
        }
    }
            
    /**
     * Sort an array of strings using the selection sort algorithm.
     */
    private static void selectionSort(String[] numbers) {
        for (int top = numbers.length-1; top > 0; top-- ) {
            int maxloc = 0;
            for (int i = 1; i &lt;= top; i++) {
                if (numbers[i].compareTo(numbers[maxloc]) > 0)
                    maxloc = i;
            }
            String temp = numbers[top];
            numbers[top] = numbers[maxloc];
            numbers[maxloc] = temp;
        }
    }
            
    public static void main(String[] args) {
        
        long startTime;  // time when a sort begin.
        long endTime;    // time when a sort ends.
        
        double[] numberList1;  // An array of random numbers.
        double[] numberList2;  // A copy of numberList1.
        
        String[] stringList1;  // An array of random strings.
        String[] stringList2;  // A copy of stringList1.
        
        /* Make sure the selection sort methods are correct.  The outputs
           should be correctly sorted. */
        
        System.out.println("First, test that selection sort works on doubles.");
        System.out.println("The 10 output numbers should be in increasing order.");
        numberList1 = randomNumbers(10);
        selectionSort(numberList1);
        for (double n : numberList1)
            System.out.println( "   " + n );
        System.out.println();
        
        System.out.println("Next, test that selection sort works on strings.");
        System.out.println("The 10 output strings should be in alphabetical order.");
        System.out.println("(Also tests that random strings are made correctly.");
        stringList1 = randomStrings(10);
        selectionSort(stringList1);
        for (String str : stringList1)
            System.out.println( "   " + str );
        System.out.println();
        
        System.out.println();
        System.out.println("Times for sorting arrays of size " + SIZE + ":");
        System.out.println();
        
        /* Create the arrays. */
        
        numberList1 = randomNumbers(SIZE);
        numberList2 = Arrays.copyOf(numberList1, SIZE);
        stringList1 = randomStrings(SIZE);
        stringList2 = Arrays.copyOf(stringList1, SIZE);
        
        /* Do the sorts and output the times. */
        
        startTime = System.currentTimeMillis();
        selectionSort(numberList1);
        endTime = System.currentTimeMillis();
        System.out.printf("Milliseconds to sort %d numbers with selectionSort: %d",
                                SIZE, endTime-startTime);
        System.out.println();
        
        startTime = System.currentTimeMillis();
        Arrays.sort(numberList2);
        endTime = System.currentTimeMillis();
        System.out.printf("Milliseconds to sort %d numbers with Arrays.sort(): %d",
                                SIZE, endTime-startTime);
        System.out.println();
        
        startTime = System.currentTimeMillis();
        selectionSort(stringList1);
        endTime = System.currentTimeMillis();
        System.out.printf("Milliseconds to sort %d strings with selectionSort: %d",
                                SIZE, endTime-startTime);
        System.out.println();
        
        startTime = System.currentTimeMillis();
        Arrays.sort(stringList2);
        endTime = System.currentTimeMillis();
        System.out.printf("Milliseconds to sort %d strings with Arrays.sort(): %d",
                                SIZE, endTime-startTime);
        System.out.println();
        System.out.println();
        
        
    }

}
</prog></pre>
</exercise-code>
</exercise>





<exercise>
<exercise-question><p>In <localref href="GUI1.ex.1"/>, you wrote a
program <code>SimpleStamperWithDrag</code> that allows the user to
place red rectangles and blue ovals in a panel by clicking and dragging
the mouse.  However, that program does not store any information about
what has been drawn, so the panel cannot repaint itself correctly.  Revise the program
to use an <classname>ArrayList</classname> to store data about the contents of the panel.  All
drawing should be done in a <code>paintComponent()</code> method.
</p></exercise-question>
<exercise-discuss>
<p>We need three pieces
of information in order to draw a shape:  its x-coordinate, its y-coordinate,
and whether it is a red rectangle or a blue oval.  We can pack the three pieces 
of information into a class.  I've added
a constructor to the class to make it easier to create an object and set the
values of its instance variables at the same time:</p>
<pre>/**
 * A class to hold information about one shape.
 */
private static class ShapeInfo {
    int x,y;  // The location of a shape
    boolean rect;  // true if it's a red rectangle, false for a blue oval
    ShapeInfo(int x, int y, boolean isRect) {
        this.x = x;
        this.y = y;
        rect = isRect;
    }
}</pre>
<np>The data for the whole collection of shapes is then stored using a variable
named <code>shapes</code> of type <atype>ArrayList&lt;ShapeInfo&gt;</atype>.
By using an ArrayList, we allow for an unlimited number of shapes.</np>

<p>Given this data structure, it's easy to write the <code>paintComponent()</code>
method.  It uses a for-each loop to go through the ArrayList.  The loop control
variable, <code>shape</code>, is of type <classname>ShapeInfo</classname>, and 
the data needed to draw the shape is given by its three instance variables
<code>shape.x</code>, <code>shape.y</code>, and <code>shapes.rect</code>.
You can look at the method in the program below.</p>

<p>In the original program, the <code>mousePressed()</code> and <code>mouseDragged()</code>
methods actually draw the shapes.  In the new version, these methods simply add an
item to the <code>shapes</code> ArrayList, and they call <code>repaint()</code> to
make the change show up on the screen. (I will admit that in my first attempt,
I forgot the <code>repaint()</code>, with the result that the mouse actions had
no visible effect even though the shape was correctly added to the list.)</p>
<p>If the user is holding down the shift key in <code>mousePressed()</code>,
the panel has to be cleared.  I do that by calling <code>shapes.clear()</code>,
which removes all the items from the ArrayList and sets its size to zero.</p>

<p>(By the way, one of the reasons to use an ArrayList in this program is to avoid
avoid using the <code>getGraphics()</code> method to get a graphics context for
drawing on the panel.  The use of this method is frowned upon.  The new program
follows the recommended rule, to do all drawing in the <code>paintComponent()</code>
method.)</p>
</exercise-discuss>
<exercise-code>
<p>Changes from <code>SimpleStamperWithDrag</code> are shown in &newcodestyle;.</p>
<pre><prog name="SimpleStamperWithArrayList">import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
<newcode>import java.util.ArrayList;</newcode>

/**
 * A simple demonstration of MouseEvents.  Shapes are drawn
 * on a black background when the user clicks the panel.  If
 * the user Shift-clicks, the panel is cleared.  If the user
 * right-clicks the panel, a blue oval is drawn.  Otherwise,
 * when the user clicks, a red rectangle is drawn.  <newcode>Information
 * about the shapes that have been drawn is stored in an ArrayList,
 * which is used in paintComponent() to draw the contents of
 * the panel.</newcode>
 */
public class SimpleStamperWithArrayList extends JPanel 
                               implements MouseListener, MouseMotionListener {

    public static void main(String[] args) {
        JFrame window = new JFrame("Simple Stamper");
        SimpleStamperWithArrayList content = new SimpleStamperWithArrayList();
        window.setContentPane(content);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setLocation(120,70);
        window.setSize(400,300);
        window.setVisible(true);
    }

    // ----------------------------------------------------------------------
    
    <newcode>/**
     * A class to hold information about one shape.
     */
    private static class ShapeInfo {
        int x,y;  // The location of a shape
        boolean rect;  // true if it's a red rectangle, false for a blue oval
        ShapeInfo(int x, int y, boolean isRect) {
            this.x = x;
            this.y = y;
            rect = isRect;
        }
    }
    
    private ArrayList&lt;ShapeInfo&gt; shapes;  // Holds shapes that have been added.</newcode>

    /**
     * This variable is set to true during a drag operation, unless the
     * user was holding down the shift key when the mouse was first
     * pressed (since in that case, the mouse gesture simply clears the
     * panel and no figures should be drawn if the user drags the mouse).
     */
    private boolean dragging;
    

    /**
     * This constructor simply sets the background color of the panel to be black
     * and sets the panel to listen for mouse events on itself.
     */
    public SimpleStamperWithArrayList() {
        setBackground(Color.WHITE);
        addMouseListener(this);
        addMouseMotionListener(this);
        <newcode>shapes = new ArrayList&lt;ShapeInfo&gt;();</newcode>
    }


    <newcode>protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        for ( ShapeInfo shape : shapes ) {
            if ( shape.rect ) {
                    // Draw a red rectangle centered at (x,y).
                g.setColor(Color.RED);   // Red interior.
                g.fillRect( shape.x - 30, shape.y - 15, 60, 30 );
                g.setColor(Color.BLACK); // Black outline.
                g.drawRect( shape.x - 30, shape.y - 15, 60, 30 );
            }
            else {
                    // draw a blue oval centered at (x,y)
                g.setColor(Color.BLUE);  // Blue interior.
                g.fillOval( shape.x - 30, shape.y - 15, 60, 30 );
                g.setColor(Color.BLACK); // Black outline.
                g.drawOval( shape.x - 30, shape.y - 15, 60, 30 );
            }
        }
    }</newcode>
    
    /**
     *  This method will be called when the user clicks the mouse on the panel.
     *  If the shift key is down, the panel is cleared.  Otherwise, it adds
     *  a shape to the panel and starts a drag operation.
     */
    public void mousePressed(MouseEvent evt) {

        if ( evt.isShiftDown() ) {
                // The user was holding down the Shift key.
                // Set shapeCount to 0 to record that there are no shapes.
            dragging = false;
            <newcode>shapes.clear();</newcode>
            repaint();
            return;
        }

        dragging = true;

        int x = evt.getX();  // x-coordinate where user clicked.
        int y = evt.getY();  // y-coordinate where user clicked.

        <newcode>ShapeInfo newShape;
        if ( evt.isMetaDown() ) {
            newShape = new ShapeInfo(x,y,false);
        }
        else {
            newShape = new ShapeInfo(x,y,true);
        }
        shapes.add(newShape);
        repaint();  // repaint so that user can see the new shape!</newcode>

    } // end mousePressed();


    /**
     *  This method is called when the user drags the mouse.  If a the value of the
     *  instance variable dragging is true, it will add a shape to the panel.
     */
    public void mouseDragged(MouseEvent evt) {
        if ( dragging == false ) { 
            return;
        }
        int x = evt.getX();  // x-coordinate where user clicked.
        int y = evt.getY();  // y-coordinate where user clicked.

        <newcode>ShapeInfo newShape;
        if ( evt.isMetaDown() ) {
            newShape = new ShapeInfo(x,y,false);
        }
        else {
            newShape = new ShapeInfo(x,y,true);
        }
        shapes.add(newShape);</newcode>

        repaint();  // repaint so that user can see the new shape!
    } // end mouseDragged();


    // The next four empty routines are required by the MouseListener interface.
    // They don't do anything in this class, so their definitions are empty.

    public void mouseEntered(MouseEvent evt) { }
    public void mouseExited(MouseEvent evt) { }
    public void mouseClicked(MouseEvent evt) { }
    public void mouseReleased(MouseEvent evt) { }

    // The next routines is required by the MouseMotionListener interface.

    public void mouseMoved(MouseEvent evt) { }

} // end class SimpleStamperWithArrayList
</prog></pre></exercise-code>
</exercise>


<exercise>
<exercise-question><p>Write a program that will
read a sequence of positive real numbers entered by the user and will print the
same numbers in sorted order from smallest to largest. The user will input a
zero to mark the end of the input. Assume that at most 100 positive numbers
will be entered.  Do <b>not</b> use any built-in function such as 
<code>Arrays.sort()</code>. Do the sorting yourself.</p>
</exercise-question>
<exercise-discuss><p>The sample program 
<sourceref href="ReverseWithDynamicArray.java"/> from
<localref href="arrays.2.4"/> reads in up to 100 positive integers from the
user and outputs them in the reverse of the order in which the user entered
them. This is similar to what we have to do for this exercise, except that the
numbers we have to read are real numbers (of type <ptype>double</ptype>) and they
have to be output in sorted order.</p>

<p>There are two basic approaches to this problem. The first is to store all
the numbers in an array in the order in which they are input. After all the
numbers have been input, the array can be sorted, and then the contents of the
array can be output. The second approach is to always keep the array in sorted
order as numbers are added to it. When a new number is input, that number must
be inserted into its correct location in the array, in order to keep the array
sorted. After all the numbers have been input, the contents of the array are
ready to be printed.</p>

<p>Two solutions to the exercise, based on these two approaches, are shown
below. They use techniques for sorting and inserting that were covered in
<localref href="arrays.4"/>. In my first program, I've chosen to use
Selection Sort to sort the array. Insertion Sort would work just as well. The
Selection Sort subroutine is taken from <localref href="arrays.4"/> with two changes: It sorts
an array of <ptype>double</ptype> values instead of an array of <code>ints</code>, and it
has been modified to work with a "partially full" array. In order to make the
subroutine work with a partially full array, it is necessary to add a parameter
that tells the subroutine how many entries in the array are in use. The
modified Selection Sort routine is as follows, with changes from the original
version shown in &newcodestyle;</p>

<pre>static void selectionSort(<newcode>double</newcode>[] A, <newword>int count</newword>) {
      // Sort the numbers in A[0], A[1], ..., A[count-1] into
      // increasing order using Selection Sort.
   for ( int lastPlace = <newcode>count</newcode> - 1; lastPlace &gt; 0; lastPlace-- ) {
      int maxLoc = 0;
      for (int j = 1; j &lt;= lastPlace; j++) {
         if (A[j] &gt; A[maxLoc]) {
            maxLoc = j;
         }
      }
      <newcode>double</newcode> temp = A[maxLoc];
      A[maxLoc] = A[lastPlace];
      A[lastPlace] = temp;
   }
} // end selectionSort</pre>

<np>In the first version of the program, this subroutine is called just after
all the numbers have been input from the user.</np>

<p>The second version of the program is straightforward. It uses the
<code>insert()</code> subroutine from <localref href="arrays.4"/>, modified to work with an array
of <code>doubles</code> instead of an array of <code>ints</code>.</p>
</exercise-discuss>
<exercise-code><p><b>First solution, with Selection Sort:</b>
</p>

<pre><prog name="SortInputNumbers">
    /**
     * This program reads up to 100 positive integers from the user and 
     * prints them in sorted order.  Input ends when the user enters a 
     * non-positive integer.  The numbers are read and stored in an array.
     * That array is sorted using selection sort, and then the array is
     * printed.
     */
    
    public class SortInputNumbers {
    
       public static void main(String[] args) {
      
          double[] numbers;  // An array for storing the input values.
          int numCt;         // The number of numbers saved in the array.
          double num;        // One of the numbers input by the user.
        
          numbers = new double[100];   // Space for 100 numbers.
          numCt = 0;                   // No numbers have been saved yet.
        
          System.out.println("Enter up to 100 positive numbers; Enter 0 to end");
        
          while (true) {   // Get the numbers and put them in the array.
             System.out.print("? ");
             num = TextIO.getlnDouble();
             if (num &lt;= 0)
                break;
             numbers[numCt] = num;
             numCt++;
          }
          
          selectionSort(numbers, numCt);  // Sort the numbers.
        
          System.out.println("\nYour numbers in sorted order are:\n");
        
          for (int i = 0; i &lt; numCt; i++) {
              System.out.println( numbers[i] );
          }
        
       } // end main();
       
       /**
        * Sort the numbers in A[0], A[1], ..., A[count-1] into
        * increasing order using Selection Sort.
        */
       static void selectionSort(double[] A, int count) {
          for ( int lastPlace = count - 1; lastPlace &gt; 0; lastPlace-- ) {
             int maxLoc = 0;
             for (int j = 1; j &lt;= lastPlace; j++) {
                if (A[j] &gt; A[maxLoc]) {
                   maxLoc = j;
                }
             }
             double temp = A[maxLoc];
             A[maxLoc] = A[lastPlace];
             A[lastPlace] = temp;
          }
       } // end selectionSort
      
    }  // end class SortInputNumbers
</prog></pre>

<p><b>Second solution, with Insert:</b>
</p>

<pre><prog name="SortInputNumbers2">/**
 * This program reads up to 100 positive integers from the user and 
 * prints them in sorted order.  Input ends when the user enters a
 * non-positive integer.  The numbers are read and inserted into
 * an array.  The array is maintained at all times in sorted order.
 */

public class SortInputNumbers2 {

   public static void main(String[] args) {
  
      double[] numbers;  // An array for storing the input values.
      int numCt;         // The number of numbers saved in the array.
      double num;        // One of the numbers input by the user.
    
      numbers = new double[100];   // Space for 100 numbers.
      numCt = 0;                   // No numbers have been saved yet.
    
      System.out.println("Enter up to 100 positive numbers; Enter 0 to end");
    
      while (true) {   // Get the numbers and insert them into the array.
         System.out.print("? ");
         num = TextIO.getlnDouble();
         if (num &lt;= 0)
            break;
         <newcode>insert(numbers, numCt, num);</newcode>
         numCt++;
      }
      
      System.out.println("\nYour numbers in sorted order are:\n");
    
      for (int i = 0; i &lt; numCt; i++) {
          System.out.println( numbers[i] );
      }
    
   } // end main();
   
   /**
    * Assume that A contains itemsInArray in increasing order.
    * Insert newItem into its correct position in the sorted array.
    */
   static void insert(double[] A, int itemsInArray, double newItem) {
      int loc = itemsInArray - 1;
      while (loc &gt;= 0 &amp;&amp; A[loc] &gt; newItem) {
             // Move the item from A[loc] up one space.
         A[loc + 1] = A[loc];
         loc = loc - 1;
      }
      A[loc + 1] = newItem;  // Put newItem in the last vacated space.
   } // end insert
  
}  // end class SortInputNumbers2
</prog></pre>
</exercise-code>
</exercise>   

   
   
   
<exercise>
<exercise-question><p>The sample program <sourceref chapter="6" href="RandomArt.java"/> from
<localref href="GUI1.5.1"/> shows a different random "artwork" every four seconds.  There
are three types of "art", one made from lines, one from circles, and one from filled
squares.  However, the program does not save the data for the picture that is shown
on the screen.  As a result, the picture cannot be redrawn when necessary.  In fact, 
every time <code>paintComponent()</code> is called, a new picture is drawn.</p>
<p>Write a new version of <code>RandomArt.java</code> that saves the
data needed to redraw its pictures.   The <code>paintComponent()</code> method
should simply use the data to draw the picture.  New data should be recomputed
only every four seconds, in response to an event from the timer that drives the
program.</p>
<p>To make this interesting, write a separate class for each of the three different
types of art.  Also write an abstract class to serve as the common base class for
the three classes.  Since all three types of art use a random gray background, 
the background color can be defined in their superclass.  The superclass also
contains a <code>draw()</code> method that draws the picture; this is an abstract
method because its implementation depends on the particular type of art that
is being drawn.  The abstract class can be defined as:</p>
<pre>
private abstract class ArtData {
   Color backgroundColor;  // The background color for the art.
   ArtData() {  // Constructor sets background color to be a random gray.
      int x = (int)(256*Math.random());
      backgroundColor = new Color( x, x, x );
   }
   abstract void draw(Graphics g);  // Draws this artwork.
}</pre>
<p>Each of the three subclasses of <code>ArtData</code> must define its own <code>draw()</code>
method.  It must also define instance variables to hold the data necessary to draw the
picture.  I suggest that you should create random data for the picture in the constructor
of the class, so that  constructing the object will automatically create the data for the random
artwork. (One problem with this is that you can't create the data until you know the
size of the panel, so you can't create an <code>ArtData</code> object in the constructor of the panel.
One solution is to create an <code>ArtData</code> object at the beginning of the <code>paintComponent()</code>
method, if the object has not already been created.)
In each of the three subclasses, you will need to use one or more arrays or ArrayLists
to store the data.</p>
</exercise-question>
<exercise-discuss><p>In my solution, I defined subclasses <classname>LineArtData</classname>,
<classname>CircleArtData</classname>, and <classname>SquareArtData</classname> of
the basic abstract <classname>ArtData</classname> class.  An instance variable named
<code>artData</code>, of type <classname>ArtData</classname>, points to the object that
holds the data for the current picture.  When it's time to create a new artwork,
I call the following method, which changes the value of <code>artData</code>.  Note
that this method has an equal chance of producing each of the three types of art:</p>
<pre>/**
 * Creates an object belonging to one of the three subclasses of
 * ArtData, and assigns that object to the instance variable, artData.
 * The subclass to use (that is, the type of art) is chosen at random.
 */
private void createArtData() {
   switch ( (int)(3*Math.random()) ) {
   case 0:
      artData = new LineArtData();
      break;
   case 1:
      artData = new CircleArtData();
      break;
   case 2:
      artData = new SquareArtData();
      break;
   }
}</pre>
<p>This method is called by the action listener that responds to events from the timer,
so a new artwork is created every time the timer generates an event, that is, every four seconds.</p>
<p>The <code>paintComponent()</code> method uses the background color from <code>artData</code>
to fill the drawing area.  It then tells <code>artData</code> to draw itself by calling
its <code>draw()</code> method.  As suggested in the exercise, it first makes sure
that an art data object has been created by calling <code>createArtData()</code> if
<code>artData</code> is still null; this can only be true the first time <code>paintComponent()</code>
is called.  So, the <code>paintComponent()</code> method is quite simple:</p>

<pre>public void paintComponent(Graphics g) {

   if (artData == null)  // If no artdata has yet been created, create it.
      createArtData();
   
   // Note:  Since the next two lines fill the entire panel, there is
   // no need to call super.paintComponent(g), since any drawing
   // that it does will only be covered up anyway.
   
   g.setColor(artData.backgroundColor); // Fill with the art's background color.
   g.fillRect( 0, 0, getWidth(), getHeight() );

   artData.draw(g);  // Draw the art.
     
} // end paintComponent()</pre>

<np>Note in particular the last line, <code>artData.draw(g)</code>.  This is a
polymorphic method, since what gets drawn will depend on what class the object
<code>artData</code> belongs to, and that changes as the program runs.</np>

<p>The only thing that remains for discussion is the three classes that define the three
types of art.  Note that we have been able to get this far without thinking about creating
or drawing the actual art.  This is because we have been thinking "abstractly," in terms of the
abstract class.</p>
<p>Let's look in detail at <classname>LineArtData</classname>, one of the three concrete 
subclasses of <classname>ArtData</classname>.  In the original program, line art was
drawn in the <code>paintComponent()</code> method as follows:</p>
<pre>for (int i = 0; i &lt; 500; i++) {
   int x1 = (int)(getWidth() * Math.random());
   int y1 = (int)(getHeight() * Math.random());
   int x2 = (int)(getWidth() * Math.random());
   int y2 = (int)(getHeight() * Math.random());
   Color randomHue = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
   g.setColor(randomHue);
   g.drawLine(x1,y1,x2,y2);
}</pre>
<np>Here, the coordinates and colors for each line are chosen at random and the line is immediately
drawn using that data.  For the new version, we want to save the data in instance variables
so that the picture can be drawn and redrawn on demand.  The creation of the data will be split
from the drawing; the data will be created in the constructor and will be used to draw the
picture in the <code>draw()</code> method.   To save the data for all 500 lines,
we have to store the coordinates and colors in arrays.  There are several ways to do this,
but I used one array for each piece of data, <code>x1</code>, <code>y1</code>, <code>x2</code>,
<code>y2</code>, and the color.  This is an example of parallel arrays.
To store data for 500 lines, each array should be of length
500.  For example, <code>x1</code> is declared as an instance variable of type
<atype>int[]</atype>, and the array is created with the command "<code>x1 = new&nbsp;int[500];</code>".
The arrays are created in the <classname>LineArtData</classname> constructor and are filled with random data.
In the <code>draw()</code> method, the <code>i-th</code> line can be drawn with the commands:</np>
<pre>g.setColor( color[i] );    // Use the i-th color in the array
g.drawLine( x1[i], y1[i], x2[i], y2[i] );</pre>
<np>We just need a <code>for</code> loop to draw all the lines.  The complete definition of
<classname>LineArtData</classname> class is as follows:</np>
<pre>/**
 * Stores data for a picture that contains 500 random lines drawn in
 * different random colors.
 */
private class LineArtData extends ArtData {
   Color[] color;         // color[i] is the color of line number i
   int[] x1, y1, x2, y2;  // line i goes from (x1[i],y1[i]) to (x2[i],y2[i]).
   LineArtData() {  // Constructor creates arrays and fills then randomly.
      color = new Color[500];
      x1 = new int[500];
      y1 = new int[500];
      x2 = new int[500];
      y2 = new int[500];
      for (int i = 0; i &lt; 500; i++) {
         x1[i] = (int)(getWidth() * Math.random());
         y1[i] = (int)(getHeight() * Math.random());
         x2[i] = (int)(getWidth() * Math.random());
         y2[i] = (int)(getHeight() * Math.random());
         color[i] = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
      }
   }
   void draw(Graphics g) {  // Draw the picture.
      for (int i = 0; i &lt; 500; i++) {
         g.setColor(color[i]);
         g.drawLine( x1[i], y1[i], x2[i], y2[i] );
      }
   }
}</pre>
<np>This is, by the way, a <b>non-static</b> nested class in the <classname>RandomArtPanel</classname>
class.  It can't be static because it uses the instance methods <code>getWidth()</code> and
<code>getHeight()</code> from the containing class.</np>
<p>The other two classes can be approached in a similar way, but to mix things up a bit, I
decided to use an ArrayList of objects, instead of parallel arrays, for the other two classes.
For the circles, I created a class <classname>OneCircle</classname> to hold the data
for one circle, and I used an <atype>ArrayList&lt;OneCircle&gt;</atype> to hold data for
100 circles.  (An array of <classname>OneCircle</classname> would have worked just as well.)
You can see the result in the complete solution below.  Note, by the way, that <code>OneCircle</code>
is a nested class that is inside another nested class.  Java allows multiple levels of nesting.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="RandomArt2">import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.ArrayList;

/**
 * A RandomArtPanel draws random pictures which might be taken to have
 * some vague resemblance to abstract art.  A new picture is produced every
 * four seconds.  There are three types of pictures:  random lines,
 * random circles, and random 3D rects.  The figures are drawn in
 * random colors on a background that is a random shade of gray.  The
 * data for a given piece of art is stored in a data structure so
 * that the picture can be redrawn if necessary.  The data is created
 * in response to the action event from a timer.
 */
public class RandomArt2 extends JPanel {

    /**
     * A main routine to make it possible to run this program as an application.
     */
    public static void main(String[] args) {
        JFrame window = new JFrame("Random Art ??");
        RandomArt2 content = new RandomArt2();
        window.setContentPane(content);
        window.setSize(400,400);
        window.setLocation(100,100);
        window.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
        window.setVisible(true);
    }

    //---------------------------------------------------------------------
    /**
     * The data for the currently displayed picture (unless it is null).
     */
    private ArtData artData;


    /**
     * The constructor creates a timer with a delay time of four seconds
     * (4000 milliseconds), and with a RepaintAction object as its
     * ActionListener.  It also starts the timer running.  The
     * RepaintAction class is a nested class, defined below.
     */
    public RandomArt2() {
        RepaintAction action = new RepaintAction();
        Timer timer = new Timer(4000, action);
        timer.start();
    }


    /**
     * The paintComponent() method fills the panel with a random shade of
     * gray and then draws one of three types of random "art".  The data for
     * the picture is in the variable artData (if this variable is null,
     * then an artData object is created here).
     */
    public void paintComponent(Graphics g) {

        if (artData == null)  // If no artdata has yet been created, create it.
            createArtData();

        // Note:  Since the next two lines fill the entire panel, there is
        // no need to call super.paintComponent(g), since any drawing
        // that it does will only be covered up anyway.

        g.setColor(artData.backgroundColor); // Fill with the art's background color.
        g.fillRect( 0, 0, getWidth(), getHeight() );

        artData.draw(g);  // Draw the art.

    } // end paintComponent()


    /**
     * Creates an object belonging to one of the three subclasses of
     * ArtData, and assigns that object to the instance variable, artData.
     * The subclass to use (that is, the type of art) is chosen at random.
     */
    private void createArtData() {
        switch ( (int)(3*Math.random()) ) {
        case 0:
            artData = new LineArtData();
            break;
        case 1:
            artData = new CircleArtData();
            break;
        case 2:
            artData = new SquareArtData();
            break;
        }
    }


    /**
     * An abstract class that represents the data for a random work
     * of "art".  Different concrete subclasses of this class represent
     * different types of art.  This class contains a background
     * color which is a random shade of gray, selected when the object
     * is constructed.
     */
    private abstract class ArtData {
        Color backgroundColor;  // The background color for the art.
        ArtData() {  // Constructor sets background color to be a random shade of gray.
            int x = (int)(256*Math.random());
            backgroundColor = new Color( x, x, x );
        }
        abstract void draw(Graphics g);  // Draw the picture.
    }


    /**
     * Stores data for a picture that contains 500 random lines drawn in
     * different random colors.
     */
    private class LineArtData extends ArtData {

        Color[] color;         // color[i] is the color of line number i
        int[] x1, y1, x2, y2;  // line i goes from (x1[i],y1[i]) to (x2[i],y2[i]).
        LineArtData() {  // Constructor creates arrays and fills then randomly.
            color = new Color[500];
            x1 = new int[500];
            y1 = new int[500];
            x2 = new int[500];
            y2 = new int[500];
            for (int i = 0; i &lt; 500; i++) {
                x1[i] = (int)(getWidth() * Math.random());
                y1[i] = (int)(getHeight() * Math.random());
                x2[i] = (int)(getWidth() * Math.random());
                y2[i] = (int)(getHeight() * Math.random());
                color[i] = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
            }
        }
        void draw(Graphics g) {  // Draw the picture.
            for (int i = 0; i &lt; 500; i++) {
                g.setColor(color[i]);
                g.drawLine( x1[i], y1[i], x2[i], y2[i] );
            }
        }
    }


    /**
     * Stores data for a picture that contains 200 circles with 
     * radius 50, with random centers, and drawn in random colors.
     */
    private class CircleArtData extends ArtData {
        class OneCircle {
            Color color;  // the color of the th circle
            int centerX;  // center of circle is at (centerX, centerY)
            int centerY;
        }
        ArrayList&lt;OneCircle&gt; circles;
        CircleArtData() {  // Constructor creates arrays and fills then randomly.
            circles = new ArrayList&lt;OneCircle&gt;();
            for (int i = 0; i &lt; 200; i++) {
                OneCircle c = new OneCircle();
                c.centerX =  (int)(getWidth() * Math.random());
                c.centerY = (int)(getHeight() * Math.random());
                c.color = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
                circles.add(c);
            }
        }
        void draw(Graphics g) {  // Draw the picture.
            for (OneCircle circle : circles) {
                g.setColor(circle.color);
                g.drawOval(circle.centerX - 50, circle.centerY - 50, 100, 100);
            }
        }
    }


    /**
     * Stores data for a picture that contains 25 filled squares with 
     * random sizes and  with random centers, and drawn in random colors.
     */
    private class SquareArtData extends ArtData {
        class OneSquare {
            Color color;  // the color of the square
            int centerX;  // the center of square is (centerX, centerY)
            int centerY; 
            int size;     // the length of a side of the square
        }
        ArrayList&lt;OneSquare&gt; squares = new ArrayList&lt;OneSquare&gt;();
        SquareArtData() {  // Constructor creates arrays and fills then randomly.
            for (int i = 0; i &lt; 25; i++) {
                OneSquare s = new OneSquare();
                s.centerX =  (int)(getWidth() * Math.random());
                s.centerY = (int)(getHeight() * Math.random());
                s.size = 30 + (int)(170*Math.random());
                s.color = new Color( (int)(256*Math.random()), 
                        (int)(256*Math.random()), (int)(256*Math.random()) );
                squares.add(s);
            }
        }
        void draw(Graphics g) {  // Draw the picture.
            for ( OneSquare square : squares ) {
                g.setColor(square.color);
                g.fill3DRect(square.centerX - square.size/2, square.centerY - square.size/2, 
                        square.size, square.size, true);
            }
        }
    }


    /**
     * A RepaintAction object creates a new artData object and calls the repaint 
     * method of this panel each time its actionPerformed() method is called.  
     * An object of this type is used as an action listener for a Timer that 
     * generates an ActionEvent every four seconds.  The result is a new work of
     * art every four seconds.
     */
    private class RepaintAction implements ActionListener {
        public void actionPerformed(ActionEvent evt) {
            createArtData();
            repaint();
        }
    }


} // end class RandomArt2
</prog></pre>
</exercise-code>
</exercise>
   
   
   
<exercise id="arrays.ex.6">
<exercise-question><p>Write a program that will read a text file selected by the user,
and will make an alphabetical list of all the different words in that file.  All words
should be converted to lower case, and duplicates should be eliminated from the list.
The list should be written to an output file selected by the user.  As discussed
in <localref href="basics.4.4"/>, you can use <classname>TextIO</classname> to read and
write files.  Use a variable of type <atype>ArrayList&lt;String&gt;</atype> to
store the words.  It is not easy to separate a file into words as you are reading
it.  You can use the following method:</p>
<pre>/**
 * Read the next word from TextIO, if there is one.  First, skip past
 * any non-letters in the input.  If an end-of-file is encountered before 
 * a word is found, return null.  Otherwise, read and return the word.
 * A word is defined as a sequence of letters.  Also, a word can include
 * an apostrophe if the apostrophe is surrounded by letters on each side.
 * @return the next word from TextIO, or null if an end-of-file is 
 *     encountered
 */
private static String readNextWord() {
   char ch = TextIO.peek(); // Look at next character in input.
   while (ch != TextIO.EOF &amp;&amp; ! Character.isLetter(ch)) {
          // Skip past non-letters.
      TextIO.getAnyChar();  // Read the character.
      ch = TextIO.peek();   // Look at the next character.
   }
   if (ch == TextIO.EOF) // Encountered end-of-file
      return null;
   // At this point, we know the next character is a letter, so read a word.
   String word = "";  // This will be the word that is read.
   while (true) {
      word += TextIO.getAnyChar();  // Append the letter onto word.
      ch = TextIO.peek();  // Look at next character.
      if ( ch == '\'' ) {
            // The next character is an apostrophe.  Read it, and
            // if the following character is a letter, add both the
            // apostrophe and the letter onto the word and continue
            // reading the word.  If the character after the apostrophe
            // is not a letter, the word is done, so break out of the loop.
         TextIO.getAnyChar();   // Read the apostrophe.
         ch = TextIO.peek();    // Look at char that follows apostrophe.
         if (Character.isLetter(ch)) {
            word += "\'" + TextIO.getAnyChar();
            ch = TextIO.peek();  // Look at next char.
         }
         else
            break;
      }
      if ( ! Character.isLetter(ch) ) {
            // If the next character is not a letter, the word is
            // finished, so break out of the loop.
         break;
      }
      // If we haven't broken out of the loop, next char is a letter.
   }
   return word;  // Return the word that has been read.
}</pre>
<np>Note that this method will return <code>null</code> when the file has been
entirely read.  You can use this as a signal to stop processing the input file.</np>
</exercise-question>
<exercise-discuss><p>This is actually not a very difficult program to write.
The main point of the exercise is to get you to use a list of strings and
to do something with files.</p>
<p>There are several possible approaches to this problem.  One approach is to simply dump
all the words from the file into a list, without worrying about eliminating
duplicates or keeping the list in order.  After the file has been read, the list
can be sorted and printed.  Although the list can contain duplicates, the output
file should list each word only once.  However, it's easy to leave out the duplicates
as the file is being written.  If <code>wordList</code> is the variable of
type <atype>ArrayList&lt;String&gt;</atype> that holds the already sorted list of words,
then the following code will output the list without duplicates.  The idea is
that a word is written only if it is different from the previous word in the list.
Word number 0 is a special case, because there is no previous location in the list
in that case:</p>
<pre>for (int i = 0; i &lt; wordlist.size(); i++) {
   if (i == 0 || ! wordlist.get(i).equals(wordList.get(i-1) )  
      System.out.println(wordlist.get(i));
}</pre>
<p>A second approach to the problem would be to keep the list of words in sorted
order as it is being constructed.  This can be done by applying the <code>insert()</code>
routine from <localref href="arrays.4.3"/> to insert each word into the list.</p>
<p>A third approach, and the one that I use in my solution, is to eliminate duplicates
from the list as it being constructed.  Each time a word is read from the input file,
I first check whether the word is already in the list.  If so, I discard it; if not,
I add it to the end of the list.  The function <code>wordList.indexOf(word)</code>
can be used to test whether a given word is already in the list; this function returns
the value <code>-1</code> if <code>word</code> is not in the list.  After the
input file has been read, the list contains one copy of each word that was found
in the file.  At this point the list still has to be sorted.  I use a
selection sort algorithm (<localref href="arrays.4.4"/>), adapted to work for an ArrayList, 
to do the sorting.  (Another option would be to copy the strings into an array, and use
<code>Arrays.sort()</code> to sort the array.  A third would be to discover that there is a
standard method <code>Collections.sort(arraylist)</code>, which can be used to sort the
ArrayList directly.)
Then, all the elements of the list are output using a for-each loop:</p>
<pre>for (String w : wordList)
   TextIO.putln("   " + w);</pre>
<p>To let the user select the input and the output files, I use the methods
<code>TextIO.readUserSelectedFile()</code> and <code>TextIO.writeUserSelectedFile()</code>,
which are discussed in <localref href="basics.4.4"/>.  These methods put up a file
dialog where the user can select a file.  After the user selects an input file, <code>TextIO</code>
reads from that file instead of from the user's input.  After the user selects an output
file, <code>TextIO</code> writes to that file instead of to standard output.
If the user cancels the input file dialog,  then there is no input file to process, 
so I exit the program.  If the user cancels the output file dialog, I write the list of
words anyway&mdash;it will go to standard output so the user will see it on the screen.</p>
<p>When <code>TextIO</code> is working with files and an error occurs, it will generate
an error of type <classname>IllegalArgumentException</classname>.  My program catches
the error if one occurs, and it prints an error message. An error is not very likely
in this case but one could occur if, for example, the user selects an input file that
the user does not have permission to read.</p>
<p>The complete code for my solution is shown below.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="ListAllWordsFromFile">import java.util.ArrayList;

/**
 * Makes an alphabetical list of all the words in a file selected
 * by the user.  The list can be written to a file.
 */
public class ListAllWordsFromFile {
   
   
   public static void main(String[] args) {
      
      System.out.println("\n\nThis program will ask you to select an input file");
      System.out.println("It will read that file and make an alphabetical");
      System.out.println("list of all the words in the file.  After reading");
      System.out.println("the file, the program asks you to select an output");
      System.out.println("file.  If you select a file, the list of words will");
      System.out.println("be written to that file; if you cancel, the list");
      System.out.println("be written to standard output.  All words are converted");
      System.out.println("lower case, and duplicates are eliminated from the list.\n\n");
      System.out.print("Press return to begin.");
      TextIO.getln();  // Wait for user to press return.
      
      try {
         if (TextIO.readUserSelectedFile() == false) {
            System.out.println("No input file selected.  Exiting.");
             System.exit(1);
         }
         ArrayList&lt;String&gt; wordList = new ArrayList&lt;String&gt;();
         String word = readNextWord();
         while (word != null) {
            word = word.toLowerCase();  // convert word to lower case
            if ( wordList.indexOf(word) == -1 ) {
                  // This is a new word, so add it to the list
               wordList.add(word);
            }
            word = readNextWord();
         }
         System.out.println("Number of different words found in file:  " 
               + wordList.size());
         System.out.println();
         if (wordList.size() == 0) {
            System.out.println("No words found in file.");
            System.out.println("Exiting without saving data.");
            System.exit(0);
         }
         selectionSort(wordList);
         TextIO.writeUserSelectedFile(); // If user cancels, output automatically
                                         // goes to standard output.
         TextIO.putln(wordList.size() + " words found in file:\n");
         for (String w : wordList)
            TextIO.putln("   " + w);
         System.out.println("\n\nDone.\n\n");
      }
      catch (Exception e) {
         System.out.println("Sorry, an error has occurred.");
         System.out.println("Error Message:  " + e.getMessage());
      }
      System.exit(0);  // Might be necessary, because of use of file dialogs.
   }


   /**
    * Sorts a list of strings into lexicographical order, using
    * selection sort and treating the list much like an array.  In this 
    * program, the list only contains words made up of lower case
    * letters, so lexicographic order is the same as alphabetical order.
    */
   private static void selectionSort(ArrayList&lt;String&gt; list) {
      for (int top = list.size() - 1; top &gt; 0; top--) {
         int indexOfBiggest = 0;
         for (int j = 0; j &lt; top; j++) {
            String str = list.get(j);
            if (str.compareTo( list.get(indexOfBiggest) ) > 0) {
               indexOfBiggest = j;
            }
         }
         String temp = list.get(top);
         list.set( top, list.get(indexOfBiggest) );
         list.set( indexOfBiggest, temp );
      }
   }


   /**
    * Read the next word from TextIO, if there is one.  First, skip past
    * any non-letters in the input.  If an end-of-file is encountered before 
    * a word is found, return null.  Otherwise, read and return the word.
    * A word is defined as a sequence of letters.  Also, a word can include
    * an apostrophe if the apostrophe is surrounded by letters on each side.
    * @return the next word from TextIO, or null if an end-of-file is encountered
    */
   private static String readNextWord() {
      char ch = TextIO.peek(); // Look at next character in input.
      while (ch != TextIO.EOF &amp;&amp; ! Character.isLetter(ch)) {
             // Skip past non-letters.
         TextIO.getAnyChar();  // Read the character.
         ch = TextIO.peek();   // Look at the next character.
      }
      if (ch == TextIO.EOF) // Encountered end-of-file
         return null;
      // At this point, we know that the next character, so read a word.
      String word = "";  // This will be the word that is read.
      while (true) {
         word += TextIO.getAnyChar();  // Append the letter onto word.
         ch = TextIO.peek();  // Look at next character.
         if ( ch == '\'' ) {
               // The next character is an apostrophe.  Read it, and
               // if the following character is a letter, add both the
               // apostrophe and the letter onto the word and continue
               // reading the word.  If the character after the apostrophe
               // is not a letter, the word is done, so break out of the loop.
            TextIO.getAnyChar();   // Read the apostrophe.
            ch = TextIO.peek();    // Look at char that follows apostrophe.
            if (Character.isLetter(ch)) {
               word += "\'" + TextIO.getAnyChar();
               ch = TextIO.peek();  // Look at next char.
            }
            else
               break;
         }
         if ( ! Character.isLetter(ch) ) {
               // If the next character is not a letter, the word is
               // finished, so break out of the loop.
            break;
         }
         // If we haven't broken out of the loop, next char is a letter.
      }
      return word;  // Return the word that has been read.
   }
   
} // end ListAllWordsFromFile
</prog></pre>
</exercise-code>
</exercise>
   
   

<exercise>
<exercise-question><p>The game of Go Moku (also
known as Pente or Five Stones) is similar to Tic-Tac-Toe, except that it is played
on a much larger board and the object is to get five squares in a row rather
than three. Players take turns placing pieces on a board. A piece can be placed
in any empty square. The first player to get five pieces in a row&mdash;horizontally, 
vertically, or diagonally&mdash;wins. If all squares are filled
before either player wins, then the game is a draw. Write a program that lets
two players play Go Moku against each other.</p>

<p>Your program will be simpler than the <classname>Checkers</classname> program from
<localref href="arrays.5.3"/>. Play alternates strictly between the two players,
and there is no need to highlight the legal moves. You will only need two classes,
a short panel class to set up the interface and a <classname>Board</classname> class to draw
the board and do all the work of the game. Nevertheless, you will probably want
to look at the source code for the checkers program,
<sourceref href="Checkers.java"/>, for ideas about the general
outline of the program.</p>

<p>The hardest part of the program is checking whether the move that a player
makes is a winning move. To do this, you have to look in each of the four
possible directions from the square where the user has placed a piece. You have
to count how many pieces that player has in a row in that direction. If the
number is five or more in any direction, then that player wins. As a hint, here
is part of the code from my program. This code counts the number of pieces that
the user has in a row in a specified direction. The direction is specified by
two integers, <code>dirX</code> and <code>dirY</code>. The values of these variables
are 0, 1, or -1, and at least one of them is non-zero. For example, to look in
the horizontal direction, <code>dirX</code> is 1 and <code>dirY</code> is 0.</p>

<pre>int ct = 1;  // Number of pieces in a row belonging to the player.

int r, c;    // A row and column to be examined

r = row + dirX;  // Look at square in specified direction.
c = col + dirY;
while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 
                                  &amp;&amp; board[r][c] == player ) {
        // Square is on the board, and it 
        // contains one of the players' pieces.
   ct++;
   r += dirX;  // Go on to next square in this direction.
   c += dirY;
}

r = row - dirX;  // Now, look in the opposite direction.
c = col - dirY;
while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 
                                 &amp;&amp; board[r][c] == player ) {
   ct++;
   r -= dirX;   // Go on to next square in this direction.
   c -= dirY;
}</pre>

<p>Here is a picture of my program, just after black has won the game.</p>

<img src="gomoku-board.png" width="350" height="250" alt="gomoku game showing a winning position"
    tex="gomoku-board" texscale="0.6"/>

</exercise-question>
<exercise-discuss><p>This is a fairly complicated program, but it's possible to design and build
it in stages, testing each stage separately. The first stage, the general
layout of the panel, is already done in the 
<sourceref href="Checkers.java"/> program. With just a few changes, the
main panel class, the layout of the panel, and the button and message
handling come directly from that program. Let's take the rest of the Go Moku
game one stage at a time.</p>

<p>A two-dimensional array is used to store the contents of the board. This
array is of type <atype>int[][]</atype> and is named <code>board</code>. It is defined as
an instance variable in the <classname>Board</classname> class, and it is initialized
in the constructor of that class to be a 13-by-13 array. The value in each
position of the array is one of three constants: <code>EMPTY</code>,
<code>WHITE</code>, or <code>BLACK</code>. When a game begins, each of the entries in
the array is set to empty. When a player clicks on an empty square, the
corresponding entry in the array is changed from <code>EMPTY</code> to the player's
color, <code>BLACK</code> or <code>WHITE</code>. In the <code>paintComponent()</code>
method, the contents of the <code>board</code> array are used to decide what pieces
to draw on the board.</p>



<np><b><u>Drawing the Board</u></b></np>

<p>We need a <code>paintComponent()</code> method for the <classname>Board</classname> class that
can draw the board. The board has 13 rows and 13 columns of spaces. How wide
should the board be? If each square in the board is <code>x</code> pixels wide, we
need a total of <code>13*x</code> pixels just for the spaces. But there are also
lines between the spaces. These require another 12 pixels. And there is a
2-pixel border on each side, for another 4 pixels added to the width. So, with
squares of side <code>x</code>, we need a board that is <code>13*x+16</code> pixels
wide. Since I wanted something about the same size as the original
checkerboard, I choose <code>x</code> to be 12, giving a board width of 172 pixels. The
height is also 172. The dimension of the board is actually set in the constructor for the
main class, which uses a null layout and so has to set the sizes of all the components
that it contains by hand.</p>

<p>The left edge of the <code>col</code>-th column of squares in the board is
<code>2+13*col</code>. This allows for the two-pixel border on the left and for 13
pixels for each of the preceding columns of squares. (That's 12 pixels for the
square plus one pixel for the line between that column and the next.) The lines
between the columns are drawn one pixel to the left of each column, at
<code>x</code> values <code>1&nbsp;+&nbsp;13*i</code>, for <code>i</code> from 1 to 12. Rows work the
same way. To draw a piece in row number <code>row</code> and column number
<code>col</code>, the command</p>

<pre>g.fillOval(3 + 13*col, 3 + 13*row, 10, 10);</pre>

<np>can be used. This allows a one-pixel border between the oval that represents
that piece and the side of the square. In my program, I defined a method to draw
a piece:</np>

<pre>private void drawPiece(Graphics g, int piece, int row, int col) {
   if (piece == WHITE)
      g.setColor(Color.WHITE);
   else
      g.setColor(Color.BLACK);
   g.fillOval(3 + 13*col, 3 + 13*row, 10, 10);
}</pre>

<p>The background of the canvas is gray, so the <code>paintComponent()</code>
method only has to draw the black border around the board, the lines between
the squares, and all the pieces on the board. Remember that the piece in a
given row and column is recorded in the <code>board</code> array as
<code>board[row][col]</code>. The board can be drawn by the following
<code>paintComponent()</code> method:</p>

<pre>public void paintComponent(Graphics g) {

   super.paintComponent(g); // Fill with background color, lightGray.
   
   /* Draw grid lines in dark gray.  */
   
   g.setColor(Color.DARK_GRAY);
   for (int i = 1; i &lt; 13; i++) {
      g.drawLine(1 + 13*i, 0, 1 + 13*i, getSize().height);
      g.drawLine(0, 1 + 13*i, getSize().width, 1 + 13*i);
   }
   
   /* Draw a two-pixel black border around the edges of the board. */

   g.setColor(Color.BLACK;
   g.drawRect(0,0,getSize().width-1,getSize().height-1);
   g.drawRect(1,1,getSize().width-3,getSize().height-3);
   
   /* Draw the pieces that are on the board. */
   
   for (int row = 0; row &lt; 13; row++)
      for (int col = 0; col &lt; 13; col++)
         if (board[row][col] != EMPTY)
            drawPiece(g, board[row][col], row, col);
            
}  // end paintComponent()</pre>

<break/>

<np><b><u>Playing the Game</u></b></np>

<p>The logic of the GoMoku game itself is mostly in the method "<code>void
doClickSquare(int row, int&nbsp;col)</code>", which is called by the
<code>mousePressed()</code> method when the user clicks on the square in row number
<code>row</code> and column number <code>col</code>. This method must check whether the
move is legal. If so, the move is made. The method then checks whether the move
wins the game. If so, the game ends. The game will also end if the board has
become completely full. Otherwise, play passes to the other player.</p>

<p>The current player is recorded in an instance variable named
<code>currentPlayer</code>. The value of this variable is one of the two constants
<code>WHITE</code> or <code>BLACK</code>. The game can be ended by calling a method
named <code>gameOver()</code>. I wrote a <ptype>boolean</ptype>-valued method called
<code>winner()</code> to check whether a move wins the game. (When I first wrote
this method, it did nothing but "<code>return false</code>". This let me try out
the program at this stage of development, before I started working on the
difficult problem of testing for a winner.) The <code>doClickSquare()</code> method
can be written:</p>

<pre>void doClickSquare(int row, int col) {
       // This is called by mousePressed() when a player clicks 
       // on the square in the specified row and col.  It has already 
       // been checked that a game is, in fact, in progress.
       
    /* Check that the user clicked an empty square.  If not, show an
       error message and exit. */
       
    if ( board[row][col] != EMPTY ) {
       if (currentPlayer == BLACK)
          message.setText("BLACK:  Please click an empty square.");
       else
          message.setText("WHITE:  Please click an empty square.");
       return;
    }
    
    /* Make the move.  Check if the board is full or if the move
       is a winning move.  If so, the game ends.  If not, then it's
       the other user's turn. */
       
    board[row][col] = currentPlayer;  // Make the move.
    repaint();
    
    if (winner(row,col)) {  // First, check for a winner.
       if (currentPlayer == WHITE)
          gameOver("WHITE wins the game!");
       else
          gameOver("BLACK wins the game!");
       return;
    }
    
    boolean emptySpace = false;     // Check if the board is full.
    for (int i = 0; i &lt; 13; i++)
       for (int j = 0; j &lt; 13; j++)
          if (board[i][j] == EMPTY)
             emptySpace = true;  // The board contains an empty space.
    if (emptySpace == false) {
       gameOver("The game ends in a draw.");
       return;
    }
    
    /* Continue the game.  It's the other player's turn. */
    
    if (currentPlayer == BLACK) {
       currentPlayer = WHITE;
       message.setText("WHITE:  Make your move.");
    }
    else {  
       currentPlayer = BLACK;
       message.setText("BLACK:  Make your move.");
    }
 
}  // end doClickSquare()</pre>

<break/>

<np><b><u>Determining the Winner</u></b></np>

<p>The <code>winner()</code> method is certainly the hardest part of the program.
The method must look in each of the four possible directions from the square
where the user has placed a piece. If the player has five or more pieces in a
row in that direction, then the player has won. As indicated in the exercise, a
direction can be indicated by two variables, <code>dirX</code> and <code>dirY</code>.
The values of these variables for each of the four directions are:</p>

<pre>                      dirX    dirY    Why?
                      ----    ----    --------------------------------
horizontal direction    1       0       Only x changes.
vertical direction      0       1       Only y changes.
falling diagonal        1       1       Both x and y change.
rising diagonal         1      -1       Change in opposing directions.</pre>

<p>I wrote a method "<code>int count(int player, int row, int col, int dirX, int
dirY)</code> that counts the number of pieces the specified player has in a row,
starting from the square in row number <code>row</code> and column number
<code>col</code> and looking in the direction indicated by <code>dirX</code> and
<code>dirY</code>. This method contains the code given in the exercise. It returns
the number of pieces found. My <code>winner</code> method just calls this method
for each of the four directions:</p>

<pre>/**
 * This is called just after a piece has been played on the
 * square in the specified row and column.  It determines
 * whether that was a winning move by counting the number
 * of squares in a line in each of the four possible
 * directions from (row,col).  If there are 5 squares (or more)
 * in a row in any direction, then the game is won.
 */
private boolean winner(int row, int col) {
     
   if (count( board[row][col], row, col, 1, 0 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 0, 1 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 1, -1 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 1, 1 ) &gt;= 5)
      return true;
      
   /* When we get to this point, we know that the game is not won. */

   return false;
   
}  // end winner()</pre>

<p>When I first wrote this method, I checked whether the number of pieces was
"<code>== 5</code>" instead of "<code>&gt;= 5</code>". This was a bug. It's possible
for a player to get more than 5 pieces in a row, if the player plays a piece in
an empty square that joins two shorter rows of pieces together.</p>

<break/>

<np><b><u>Marking the Winning Pieces</u></b></np>

<p>In my program, when a player wins, the row of pieces that wins the game is
marked with a red line. To do this, I added four instance variables of type
<ptype>int</ptype> to the <classname>Board</classname> class. The instance variables are
named <code>win_r1</code>, <code>win_c1</code>, <code>win_r2</code>, and <code>win_c2</code>.
If the game has not yet been won, then the value of <code>win_r1</code> is <code>-1</code>. The
<code>paintComponent()</code> method uses this value as a signal that it should not
draw any red line. After a player has won the game, the values of these
variables are set to mark the squares at the two ends of the winning row of
pieces. The positions of these squares are given by <code>(win_r1,win_c1)</code>
and <code>(win_r2,win_c2)</code>. If <code>win_r1</code> is greater than -1, then the
<code>paintComponent()</code> method draws a red line between these two
squares.</p>

<p>I added some code to the <code>winner()</code> and <code>count()</code> methods to
set the values of these variables properly. As the <code>count()</code> method
counts pieces in a row, it sets <code>win_r1</code>, <code>win_c1</code>,
<code>win_r2</code>, and <code>win_c2</code> to mark the location of the last piece it
finds in the two directions it checks. If the game is won, this will set the
values correctly. To handle the case where the game is not won, I added the
line "<code>win_r1&nbsp;=&nbsp;-1;</code>" to the <code>winner()</code> method, just before the
"<code>return false;</code>" statement. This ensures that the value of this
variable will be <code>-1</code> whenever the game is not yet won. (Perhaps this is all too
tricky, but I really wanted to mark the winning pieces&dots;)</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="GoMoku">import java.awt.*;
import java.awt.event.*;
import javax.swing.*;    

/**
 * This panel lets two users play Go Moku (a.k.a Pente) against each 
 * other.  Black always starts the game.  When a player gets five-in-a-row,
 * that player wins.  The game ends in a draw if the board is filled
 * before either player wins.
 *
 * The class has a main() routine that lets it be run as a stand-alone
 * application.  The application just opens a window that uses an object
 * of type GoMoku as its content pane.
 * 
 */

public class GoMoku extends JPanel {
   
   /**
    * Main routine makes it possible to run GoMoku as a stand-alone
    * application.  Opens a window showing a GoMoku panel; the program
    * ends when the user closes the window.
    */
   public static void main(String[] args) {
      JFrame window = new JFrame("GoMoku");
      GoMoku content = new GoMoku();
      window.setContentPane(content);
      window.pack();
      Dimension screensize = Toolkit.getDefaultToolkit().getScreenSize();
      window.setLocation( (screensize.width - window.getWidth())/2,
            (screensize.height - window.getHeight())/2 );
      window.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
      window.setResizable(false);  
      window.setVisible(true);
   }
   

   private JButton newGameButton;  // Button for starting a new game.

   private JButton resignButton;   // Button that a player can use to end the 
                                   //   game by resigning.
   
   private JLabel message;  // Label for displaying messages to the user.
   
   
   /**
    *  The constructor lays out the panel.  The work of
    *  the game is all done in the Board object.  A null layout
    *  is used, and all setup of sizes and positions is done here.
    */
   public GoMoku() {
      
      setLayout(null);  // I will do the layout myself.
      
      setPreferredSize( new Dimension(350,250) );
      
      setBackground(new Color(0,150,0));  // Dark green background.
      
      /* Create the components and add them to the panel. */
      
      Board board = new Board();  // Note: The constructor for the
                                  //   board also creates the buttons
                                  //   and label.
      add(board);
      add(newGameButton);
      add(resignButton);
      add(message);
      
      /* Set the position and size of each component by calling
         its setBounds() method. */
      
      board.setBounds(16,16,172,172); // Note:  size MUST be 172-by-172 !
      newGameButton.setBounds(210, 60, 120, 30);
      resignButton.setBounds(210, 120, 120, 30);
      message.setBounds(0, 200, 350, 30);
   }
   
   
   // ----------------------- Nested class -----------------------------------
   
   /**
    * This panel displays a 168-by-168 pixel checkerboard pattern with
    * a 2-pixel black border.  It is assumed that the size of the
    * canvas is set to exactly 172-by-172 pixels.  This class does
    * the work of letting the users play Go Moku, and it displays
    * the checkerboard.  In this program, the board has 13 rows and
    * columns of squares.
    */
   class Board extends JPanel implements ActionListener, MouseListener {
      
      int[][] board;   // The data for the board is kept here.  The values
                      //   in this array are chosen from the following constants.
      
      static final int EMPTY = 0,       // Represents an empty square.
                       WHITE = 1,       // A white piece.
                       BLACK = 2;       // A black piece.
      
      boolean gameInProgress; // Is a game currently in progress?
      
      int currentPlayer;      // Whose turn is it now?  The possible values
                              //    are WHITE and BLACK.  (This is valid only while
                              //    a game is in progress.)
      
      int win_r1, win_c1, win_r2, win_c2;  // When a player wins by getting five or more
                                           // pieces in a row, the squares at the
                                           // ends of the row are (win_r1,win_c1)
                                           // and (win_r2,win_c2).  A red line is
                                           // drawn between these squares.  When there
                                           // are not five pieces in a row, the value of
                                           // win_r1 is -1.  The values are set in the
                                           // count() method.  The value of win_r1 is
                                           // tested in the paintComponent() method.
      
      /**
       * Constructor.  Create the buttons and label.  Listen for mouse
       * clicks and for clicks on the buttons.  Create the board and
       * start the first game.
       */
      public Board() {
         setBackground(Color.LIGHT_GRAY);
         addMouseListener(this);
         resignButton = new JButton("Resign");
         resignButton.addActionListener(this);
         newGameButton = new JButton("New Game");
         newGameButton.addActionListener(this);
         message = new JLabel("",JLabel.CENTER);
         message.setFont(new  Font("Serif", Font.BOLD, 14));
         message.setForeground(Color.GREEN);
         board = new int[13][13];
         doNewGame();
      }
      

      /**
       * Respond to user's click on one of the two buttons.
       */
      public void actionPerformed(ActionEvent evt) {
         Object src = evt.getSource();
         if (src == newGameButton)
            doNewGame();
         else if (src == resignButton)
            doResign();
      }
      
      
      /**
       * Begin a new game; this is called by the actionPerformed()
       * method when a user clicks the New Game button.
       */
      void doNewGame() {
         if (gameInProgress == true) {
               // This should not be possible because New Game button
               // is enabled only when it is legal to use it, but it doesn't 
               // hurt to check.
            message.setText("Finish the current game first!");
            return;
         }
         for (int row = 0; row &lt; 13; row++)       // Fill the board with EMPTYs
            for (int col = 0; col &lt; 13; col++)
               board[row][col] = EMPTY;
         currentPlayer = BLACK;   // BLACK moves first.
         message.setText("BLACK:  Make your move.");
         gameInProgress = true;
         newGameButton.setEnabled(false);
         resignButton.setEnabled(true);
         win_r1 = -1;  // This value indicates that no red line is to be drawn.
         repaint();
      }
      
      
      /**
       * Current player resigns; this is called by the actionPerformed()
       * method when a user clicks the Resign button.  Game ends, and
       * opponent wins.
       */
      void doResign() {
         if (gameInProgress == false) {
                // This should not be possible.
            message.setText("There is no game in progress!");
            return;
         }
         if (currentPlayer == WHITE)
            message.setText("WHITE resigns.  BLACK wins.");
         else
            message.setText("BLACK resigns.  WHITE wins.");
         newGameButton.setEnabled(true);
         resignButton.setEnabled(false);
         gameInProgress = false;
      }
      
      
      /**
       * This method is called whenever the game ends.  The parameter, str,
       * is displayed as a message, and the buttons are enabled/disabled
       * to reflect the fact that a game is not currently in progress.
       */
      void gameOver(String str) {
         message.setText(str);
         newGameButton.setEnabled(true);
         resignButton.setEnabled(false);
         gameInProgress = false;
      }
      
      
      /**
       * This is called by mousePressed() when a player clicks on the
       * square in the specified row and col.  It has already been checked
       * that a game is, in fact, in progress.
       */
      void doClickSquare(int row, int col) {
         
         /* Check that the user clicked an empty square.  If not, show an
          error message and exit. */
         
         if ( board[row][col] != EMPTY ) {
            if (currentPlayer == BLACK)
               message.setText("BLACK:  Please click an empty square.");
            else
               message.setText("WHITE:  Please click an empty square.");
            return;
         }
         
         /* Make the move.  Check if the board is full or if the move
          is a winning move.  If so, the game ends.  If not, then it's
          the other user's turn. */
         
         board[row][col] = currentPlayer;  // Make the move.
         repaint();
         
         if (winner(row,col)) {  // First, check for a winner.
            if (currentPlayer == WHITE)
               gameOver("WHITE wins the game!");
            else
               gameOver("BLACK wins the game!");
            return;
         }
         
         boolean emptySpace = false;     // Check if the board is full.
         for (int i = 0; i &lt; 13; i++)
            for (int j = 0; j &lt; 13; j++)
               if (board[i][j] == EMPTY)
                  emptySpace = true;
         if (emptySpace == false) {
            gameOver("The game ends in a draw.");
            return;
         }
         
         /* Continue the game.  It's the other player's turn. */
         
         if (currentPlayer == BLACK) {
            currentPlayer = WHITE;
            message.setText("WHITE:  Make your move.");
         }
         else {  
            currentPlayer = BLACK;
            message.setText("BLACK:  Make your move.");
         }
         
      }  // end doClickSquare()
      
      
      /**
       * This is called just after a piece has been played on the
       * square in the specified row and column.  It determines
       * whether that was a winning move by counting the number
       * of squares in a line in each of the four possible
       * directions from (row,col).  If there are 5 squares (or more)
       * in a row in any direction, then the game is won.
       */
      private boolean winner(int row, int col) {
         
         if (count( board[row][col], row, col, 1, 0 ) &gt;= 5)
            return true;
         if (count( board[row][col], row, col, 0, 1 ) &gt;= 5)
            return true;
         if (count( board[row][col], row, col, 1, -1 ) &gt;= 5)
            return true;
         if (count( board[row][col], row, col, 1, 1 ) &gt;= 5)
            return true;
         
         /* When we get to this point, we know that the game is not
          won.  The value of win_r1, which was changed in the count()
          method, has to be reset to -1, to avoid drawing a red line
          on the board. */
         
         win_r1 = -1;
         return false;
         
      }  // end winner()
      
      
      /**
       * Counts the number of the specified player's pieces starting at
       * square (row,col) and extending along the direction specified by
       * (dirX,dirY).  It is assumed that the player has a piece at
       * (row,col).  This method looks at the squares (row + dirX, col + dirY),
       * (row + 2*dirX, col + 2*dirY), ... until it hits a square that is
       * off the board or is not occupied by one of the player's pieces.
       * It counts the squares that are occupied by the player's pieces.
       * Furthermore, it sets (win_r1,win_c1) to mark last position where
       * it saw one of the player's pieces.  Then, it looks in the
       * opposite direction, at squares (row - dirX, col-dirY),
       * (row - 2*dirX, col - 2*dirY), ... and does the same thing.
       * Except, this time it sets (win_r2,win_c2) to mark the last piece.
       * Note:  The values of dirX and dirY must be 0, 1, or -1.  At least
       * one of them must be non-zero.
       */
      private int count(int player, int row, int col, int dirX, int dirY) {
         
         int ct = 1;  // Number of pieces in a row belonging to the player.
         
         int r, c;    // A row and column to be examined
         
         r = row + dirX;  // Look at square in specified direction.
         c = col + dirY;
         while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 &amp;&amp; board[r][c] == player ) {
            // Square is on the board and contains one of the players's pieces.
            ct++;
            r += dirX;  // Go on to next square in this direction.
            c += dirY;
         }
         
         win_r1 = r - dirX;  // The next-to-last square looked at.
         win_c1 = c - dirY;  //    (The LAST one looked at was off the board or
         //    did not contain one of the player's pieces.
         
         r = row - dirX;  // Look in the opposite direction.
         c = col - dirY;
         while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 &amp;&amp; board[r][c] == player ) {
            // Square is on the board and contains one of the players's pieces.
            ct++;
            r -= dirX;   // Go on to next square in this direction.
            c -= dirY;
         }
         
         win_r2 = r + dirX;
         win_c2 = c + dirY;
         
         // At this point, (win_r1,win_c1) and (win_r2,win_c2) mark the endpoints
         // of the line of pieces belonging to the player.
         
         return ct;
         
      }  // end count()
      
      
      /**
       * Draws the board and the pieces on the board.  If the game has
       * been won by getting five or more pieces in a row, draws a red line
       * through the pieces.
       */
      public void paintComponent(Graphics g) {
         
         super.paintComponent(g); // Fill with background color, lightGray
         
         /* Draw a two-pixel black border around the edges of the canvas,
          and draw grid lines in darkGray.  */
         
         g.setColor(Color.DARK_GRAY);
         for (int i = 1; i &lt; 13; i++) {
            g.drawLine(1 + 13*i, 0, 1 + 13*i, getSize().height);
            g.drawLine(0, 1 + 13*i, getSize().width, 1 + 13*i);
         }
         g.setColor(Color.BLACK);
         g.drawRect(0,0,getSize().width-1,getSize().height-1);
         g.drawRect(1,1,getSize().width-3,getSize().height-3);
         
         /* Draw the pieces that are on the board. */
         
         for (int row = 0; row &lt; 13; row++)
            for (int col = 0; col &lt; 13; col++)
               if (board[row][col] != EMPTY)
                  drawPiece(g, board[row][col], row, col);
         
         /* If the game has been won, then win_r1 &gt;= 0.  Draw a line to mark
          the five (or more) winning pieces. */
         
         if (win_r1 &gt;= 0)
            drawWinLine(g);
         
      }  // end paintComponent()
      
      
      /**
       * Draw a piece in the square at (row,col).  The color is specified
       * by the piece parameter, which should be either BLACK or WHITE.
       */
      private void drawPiece(Graphics g, int piece, int row, int col) {
         if (piece == WHITE)
            g.setColor(Color.WHITE);
         else
            g.setColor(Color.BLACK);
         g.fillOval(3 + 13*col, 3 + 13*row, 10, 10);
      }
      
      
      /**
       * Draw a 2-pixel wide red line from the middle of the square at
       * (win_r1,win_c1) to the middle of the square at (win_r2,win_c2).
       * This routine is called to mark the pieces that won the game.
       * The values of the variables are set in the count() method.
       */
      private void drawWinLine(Graphics g) {
         g.setColor(Color.RED);
         g.drawLine( 8 + 13*win_c1, 8 + 13*win_r1, 8 + 13*win_c2, 8 + 13*win_r2 );
         if (win_r1 == win_r2)
            g.drawLine( 8 + 13*win_c1, 7 + 13*win_r1, 8 + 13*win_c2, 7 + 13*win_r2 );
         else
            g.drawLine( 7 + 13*win_c1, 8 + 13*win_r1, 7 + 13*win_c2, 8 + 13*win_r2 );
      }
      
      
      /**
       * Respond to a user click on the board.  If no game is
       * in progress, show an error message.  Otherwise, find
       * the row and column that the user clicked and call
       * doClickSquare() to handle it.
       */
      public void mousePressed(MouseEvent evt) {
         if (gameInProgress == false)
            message.setText("Click \"New Game\" to start a new game.");
         else {
            int col = (evt.getX() - 2) / 13;
            int row = (evt.getY() - 2) / 13;
            if (col &gt;= 0 &amp;&amp; col &lt; 13 &amp;&amp; row &gt;= 0 &amp;&amp; row &lt; 13)
               doClickSquare(row,col);
         }
      }
      
      
      public void mouseReleased(MouseEvent evt) { }
      public void mouseClicked(MouseEvent evt) { }
      public void mouseEntered(MouseEvent evt) { }
      public void mouseExited(MouseEvent evt) { }
      
      
   }  // end nested class Board
   
   
   
} // end class GoMoku
</prog></pre>
</exercise-code>
</exercise>
   
   

</exercises>