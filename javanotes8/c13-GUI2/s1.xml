<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../javanotes8.dtd" >

<section id="GUI2.1" title="Images and Resources">
   
<p><start><big>W</big>e have seen how to use</start> the <classname>Graphics</classname>
class to draw on a GUI component that is visible on the computer's screen.  Often, however,
it is useful to be able to create a drawing <b>off-screen</b>, in the computer's
memory.  It is also important to be able to work with images that are stored
in files.</p>
   
<p>To a computer, an image is just a set of numbers. The numbers specify the
color of each pixel in the image. The numbers that represent the image on the
computer's screen are stored in a part of memory called a <newword>frame buffer</newword>. 
Many times each second, the computer's video
card reads the data in the frame buffer and colors each pixel on the screen
according to that data. Whenever the computer needs to make some change to the
screen, it writes some new numbers to the frame buffer, and the change appears
on the screen a fraction of a second later, the next time the screen is redrawn
by the video card.</p>

<p>Since it's just a set of numbers, the data for an image doesn't have to be
stored in a frame buffer. It can be stored elsewhere in the computer's memory.
It can be stored in a file on the computer's hard disk. Just like any other
data file, an image file can be downloaded over the Internet. Java includes
standard classes and subroutines that can be used to copy image data from one
part of memory to another and to get data from an image file and use it to
display the image on the screen.</p>

<subsection id="GUI2.1.1" title="Images and BufferedImages">
   
<p>The class <code>java.awt.Image</code> represents an image stored in
the computer's memory.  There are two fundamentally different types of
<classname>Image</classname>.  One kind represents an image read from
a source outside the program, such as from a file on the computer's
hard disk or over a network connection.  The second type is an image
created by the program, by drawing to it using a graphics context.  I refer to this second type as an
<newword>off-screen canvas</newword>.  An off-screen canvas is a
region of the computer's memory that can be used as a drawing surface.
It is possible to draw to an off-screen image using the same <classname>Graphics</classname>
class that is used for drawing on the screen.</p>

<p>An <classname>Image</classname> of either type can be copied onto
the screen (or onto an off-screen canvas) using methods that are defined
in the <classname>Graphics</classname> class.  This is most commonly done
in the <code>paintComponent()</code> method of a <classname>JComponent</classname>.
Suppose that <code>g</code> is the <classname>Graphics</classname> object that is
a parameter to the <code>paintComponent()</code> method, and that
<code>img</code> is of type <classname>Image</classname>.  Then the
statement</p>

<pre>g.drawImage(img, x, y, this);</pre>

<np>will draw the image <code>img</code> in a rectangular area in the component. The
integer-valued parameters <code>x</code> and <code>y</code> give the position of the upper-left corner
of the rectangle in which the image is displayed, and the rectangle is just
large enough to hold the image. The fourth parameter, <code>this</code>
is there for technical reasons.  In all cases in this book it will be either
<code>this</code> or <code>null</code>.  The parameter is of type
<classname>ImageObserver</classname> and a non-null value is needed only
when the complete image might not be available when the <code>drawImage()</code>
method is called.  This can happen, for example, if the image is being read
from a file or downloaded over the network.  You don't need it for an image
that the program has created itself in the computer's memory or for an
image that you are sure has already been completely loaded. In those
cases, the image observer parameter can be <code>null</code>.
However, even in those cases, using a non-null value does not cause
any problems.</np>

<p>(In cases where you do need a non-null image observer, the
special variable  <code>this</code>, from <localref href="OOP.6.1"/>, is
usually appropriate. The image observer parameter is there for technical reasons 
having to do with the funny way Java treats image files.  For most applications,
you don't need to understand this, but here is how it works:  <code>g.drawImage()</code> does
not actually draw the image in all cases.  In some circumstances, 
it is possible that the complete image is not available when this method is called.
In that case, <code>g.drawImage()</code> merely <b>initiates</b> the drawing of the
image and returns immediately.  Pieces of the image are drawn later, asynchronously,
as they become available.  The question is, <b>how</b> do they get drawn?
That's where the image observer comes in.  When a piece of the image becomes available
to be drawn, the system will inform the <classname>ImageObserver</classname>, and it
is the responsibility of the observer to make sure that
the new piece of the image will appear on the screen.  Any <classname>JComponent</classname> 
object can act as an <classname>ImageObserver</classname>; it will call its <code>repaint()</code>
method when notified that more of the image is available.
The <code>drawImage</code> method returns a
<ptype>boolean</ptype> value to indicate whether the image has actually been
drawn or not when the method returns.)</p>

<p>There are a few useful variations of the <code>drawImage()</code> method. For
example, it is possible to scale the image as it is drawn to a specified width
and height. This is done with the command</p>

<pre>g.drawImage(img, x, y, width, height, imageObserver);</pre>

<np>The parameters <code>width</code> and <code>height</code> give the size of the
rectangle in which the image is displayed. Another version makes it possible to
draw just part of the image. In the command:</np>

<pre>g.drawImage(img, dest_x1, dest_y1, dest_x2, dest_y2,
                 source_x1, source_y1, source_x2, source_y2, imageObserver);</pre>

<np>the integers <code>source_x1</code>, <code>source_y1</code>, <code>source_x2</code>, and
<code>source_y2</code> specify the top-left and bottom-right corners of a
rectangular region in the source image. The integers <code>dest_x1</code>,
<code>dest_y1</code>, <code>dest_x2</code>, and <code>dest_y2</code> specify opposite corners of
a region in the destination graphics context. The specified rectangle in the
image is drawn, with scaling if necessary, to the specified rectangle in the
graphics context. For an example in which this is useful, consider a card game
that needs to display 52 different cards. Dealing with 52 image files can be
cumbersome and inefficient, especially for downloading over the Internet. So,
all the cards might be put into a single image:</np>

<img src="cards.png" alt="deck of cards" width="513" height="307" 
   tex="cards.eps" texscale="0.33"/>

<np>(This image is from the Gnome desktop project,
<a href="http://www.gnome.org">http://www.gnome.org</a>, and is shown here much smaller
than its actual size.)
Now just one <classname>Image</classname> object is needed. Drawing one card means
drawing a rectangular region from the image. This technique is used in a variation of
the sample program <sourceref chapter="6" href="HighLowGUI.java"/> from <localref href="GUI1.7.6"/>.
In the original version, the cards are represented by textual descriptions such as
"King of Hearts."  In the new version, <sourceref href="HighLowWithImages.java"/>,
the cards are shown as images.  You should try the program, but here's how it looks
with the card images:</np>

<img src="high-low-with-images.png" width="" height="" alt="a card game using pictures of the cards"
      tex="high-low-with-images.eps" texscale="0.6"/>
   
<p>In the program, the pictures of the cards are drawn using the following method. The instance variable
<code>cardImages</code> is a variable of type <classname>Image</classname> that represents the
image  that is shown above, containing 52 cards, plus two
Jokers and a face-down card. Each card is 79 by 123 pixels. These
numbers are used, together with the suit and value of the card, to compute the
corners of the source rectangle for the <code>drawImage()</code>
command:</p>

<pre>/**
 * Draws a card in a 79x123 pixel picture of a card with its
 * upper left corner at a specified point (x,y).  Drawing the card 
 * requires the image file "cards.png".
 * @param g The graphics context used for drawing the card.
 * @param card The card that is to be drawn.  If the value is null, then a
 * face-down card is drawn.
 * @param x the x-coord of the upper left corner of the card
 * @param y the y-coord of the upper left corner of the card
 */
public void drawCard(Graphics g, Card card, int x, int y) {
   int cx;    // x-coord of upper left corner of the card inside cardsImage
   int cy;    // y-coord of upper left corner of the card inside cardsImage
   if (card == null) {
      cy = 4*123;   // coords for a face-down card.
      cx = 2*79;
   }
   else {
      cx = (card.getValue()-1)*79;
      switch (card.getSuit()) {
      case Card.CLUBS:    
         cy = 0; 
         break;
      case Card.DIAMONDS: 
         cy = 123; 
         break;
      case Card.HEARTS:   
         cy = 2*123; 
         break;
      default:  // spades   
         cy = 3*123; 
         break;
      }
   }
   g.drawImage(cardImages,x,y,x+79,y+123,cx,cy,cx+79,cy+123,this);
}</pre>

<np>I will tell you later in this section how the image file, <code>cards.png</code>,
can be loaded into the program.</np>
   
<break/>
   
<p>In addition to images loaded from files, it is possible to create images by
drawing to an off-screen canvas.  An off-screen canvas can be represented by
an object belonging to the class <classname>BufferedImage</classname>, which
is defined in the package <code>java.awt.image</code>.  <classname>BufferedImage</classname>
is a subclass of <classname>Image</classname>, so that once you have a <classname>BufferedImage</classname>,
you can copy it into a graphics context <code>g</code> using one of the <code>g.drawImage()</code>
methods, just as you would do with any other image.  A <classname>BufferedImage</classname>
can be created using the constructor</p>
   
<pre>public BufferedImage(int width, int height, int imageType)</pre>
   
<np>where <code>width</code> and <code>height</code> specify the width and height of
the image in pixels, and <code>imageType</code> can be one of several constants
that are defined in the <classname>BufferedImage</classname>.  The image type
specifies how the color of each pixel is represented.  One likely
value for <code>imageType</code> is <code>BufferedImage.TYPE_INT_RGB</code>,
which specifies that the color of each pixel is a usual RGB color, with red, green
and blue components in the range 0 to 255.  The image type
<code>BufferedImage.TYPE_INT_ARGB</code> represents an RGB image with "transparency."
The image type
<code>BufferedImage.TYPE_BYTE_GRAY</code> can be used to create a <newword>grayscale</newword>
image in which the only possible colors are shades of gray.</np>
   
<p>To draw to a <classname>BufferedImage</classname>, you need a graphics context
that is set up to do its drawing on the image.  If <code>OSC</code> is of type
<classname>BufferedImage</classname>, then the method</p>
   
<pre>OSC.createGraphics()</pre>
   
<np>returns an object of type <classname>Graphics2D</classname> that can be used
for drawing on the image.  (<classname>Graphics2D</classname> is a subclass of
<classname>Graphics</classname>.  See <localref href="GUI1.3.5"/>
and the <localref href="GUI2.2">next section</localref>.  This means you can
also use the object as a regular <classname>Graphics</classname> drawing
context.)</np>
   
<p>There are several reasons why a programmer might want to draw to an off-screen canvas.
One is to simply keep a copy of an image that is shown on the screen.  Remember that
a picture that is drawn on a component can be lost, for example when the component
is resized.  This means that you have to be able to redraw the
picture on demand, and that in turn means keeping enough information around to enable
you to redraw the picture.  One way to do this is to keep a copy of the picture in
an off-screen canvas.  Whenever the on-screen picture needs to be redrawn, you just
have to copy the contents of the off-screen canvas onto the screen.  Essentially,
the off-screen canvas allows you to save a copy of the color of every individual
pixel in the picture.  The sample program <sourceref href="PaintWithOffScreenCanvas.java"/> 
is a little painting program that uses an off-screen canvas in this way.  In this
program, the user can draw curves, lines, and various shapes; a "Tool" menu allows
the user to select the thing to be drawn.  There is also an "Erase" tool and a
"Smudge" tool that I will get to later.  A <classname>BufferedImage</classname> is
used to store the user's picture.  When the user changes the picture, the
changes are made to
the image, and the changed image is then copied to the screen.  No record is kept
of the shapes that the user draws; the only record is the color of the individual
pixels in the off-screen image.  (You should contrast this with the program
<sourceref chapter="7" href="SimplePaint2.java"/> in <localref href="arrays.3.3"/>, where
the user's drawing is recorded as a list of objects that represent the shapes
that the user drew.)</p>
   
<p>You should try the program.  Try drawing a Filled Rectangle on top of some other
shapes.  As you drag the mouse, the rectangle stretches from the starting
point of the mouse drag to the current mouse location.  As the mouse moves, the
underlying picture seems to be unaffected&mdash;parts of the picture can be covered up by the rectangle
and later uncovered as the mouse moves, and <i>they are still there</i>.  What this means
is that the rectangle that is shown as you drag the mouse can't actually be part of
the off-screen canvas, since drawing something into an image means changing the
color of some pixels in the image.  The previous colors of those pixels are not
stored anywhere else and so are permanently lost.  In fact, as you draw a line,
rectangle, or oval in <code>PaintWithOffScreenCanvas</code>, the shape that is shown as you drag
the mouse is not drawn to the off-screen canvas at all.  Instead, the <code>paintComponent()</code>
method draws the shape on top of the contents of the canvas.  Only when you release
the mouse does the shape become a permanent part of the off-screen canvas.
This illustrates the point that when an off-screen canvas is used, not everything
that is visible on the screen has to be drawn on the canvas.  Some extra stuff
can be drawn on top of the contents of the canvas by the <code>paintComponent()</code>
method.  The other tools are handled differently from the shape tools.  For the
curve, erase, and smudge tools, the changes are made to the canvas immediately,
as the mouse is being dragged.</p>
   
<p>Let's look at how an off-screen canvas is used in this program.  The canvas is
represented by an instance variable, <code>OSC</code>, of type
<classname>BufferedImage</classname>.  The size of the canvas must be the
same size as the panel on which the canvas is displayed.  The size
can be determined by calling the <code>getWidth()</code> and <code>getHeight()</code>
instance methods of the panel.  Furthermore, when the canvas is first created, it
should be filled with the background color, which is represented in the
program by an instance variable named <code>fillColor</code>.  All this is done
by the method:</p>
   
<pre>/**
 * This method creates the off-screen canvas and fills it with the current
 * fill color.
 */
private void createOSC() {
   OSC = new BufferedImage(getWidth(),getHeight(),BufferedImage.TYPE_INT_RGB);
   Graphics osg = OSC.createGraphics();
   osg.setColor(fillColor);
   osg.fillRect(0,0,getWidth(),getHeight());
   osg.dispose();
}</pre>
   
<np>Note how it uses <code>OSC.createGraphics()</code> to obtain a graphics context
for drawing to the image.  Also note that the graphics context is disposed at
the end of the method.  When you create a graphics context, it is good practice to dispose of it when
you are finished with it.  There still remains the problem of where to call
this method.  The problem is that the width and height of the panel object
are not set until some time after the panel object is constructed.  If
<code>createOSC()</code> is called in the constructor, <code>getWidth()</code>
and <code>getHeight()</code> will return the value zero and we won't get
an off-screen image of the correct size.  The approach that I take in
<code>PaintWithOffScreenCanvas</code> is to call <code>createOSC()</code> in the
<code>paintComponent()</code> method, the first time the <code>paintComponent()</code>
method is called.  At that time, the size of the panel has definitely been set,
but the user has not yet had a chance to draw anything.  With this in mind
you are ready to understand the <code>paintComponent()</code> method:</np> 
   
<pre>public void paintComponent(Graphics g) {

   /* First create the off-screen canvas, if it does not already exist. */ 

   if (OSC == null)
      createOSC();

   /* Copy the off-screen canvas to the panel.  Since we know that the
      image is already completely available, the fourth, "ImageObserver"
      parameter to g.drawImage() can be null.  Since the canvas completely
      fills the panel, there is no need to call super.paintComponent(g). */

   g.drawImage(OSC,0,0,null);

   /* If the user is currently dragging the mouse to draw a line, oval,
      or rectangle, draw the shape on top of the image from the off-screen
      canvas, using the current drawing color.  (This is not done if the
      user is drawing a curve or using the smudge, curve, or erase tool.) */

   if (dragging &amp;&amp; SHAPE_TOOLS.contains(currentTool)) {
      g.setColor(currentColor);
      putCurrentShape(g);
   }

}</pre>

<np>Here, <code>dragging</code> is a <ptype>boolean</ptype> instance variable that is
set to true while the user is dragging the mouse, and <code>currentTool</code>
tells which tool is currently in use.  The possible tools are defined by
an <code>enum</code> named <classname>Tool</classname>, and <code>SHAPE_TOOLS</code> 
is a variable of type <classname>EnumSet&lt;Tool&gt;</classname>
that contains the line, oval, rectangle, filled oval, and filled rectangle tools.
(See <localref href="generics.2.4"/>.)</np>
    
<p>You might notice that there is a problem if the size of the panel
is ever changed, since the size of the off-screen canvas will not be changed
to match.  The <code>PaintWithOffScreenCanvas</code> program does not allow the user
to resize the program's window, so this is not an issue in that program.
If we want to allow resizing, however, a new off-screen canvas must be
created whenever the size of the panel changes.  One simple way to do
this is to check the size of the canvas in the <code>paintComponent()</code>
method and to create a new canvas if the size of the canvas does not
match the size of the panel:</p>
   
<pre>if (OSC == null || getWidth() != OSC.getWidth() || getHeight() != OSC.getHeight())
   createOSC();</pre>
   
<np>Of course, this will discard the picture that was contained in
the old canvas unless some arrangement is made to copy the picture
from the old canvas to the new one before the old canvas is discarded.</np>

<p>The other point in the program where the off-screen canvas is used is
during a mouse-drag operation, which is handled in the <code>mousePressed()</code>,
<code>mouseDragged()</code>, and <code>mouseReleased()</code> methods.
The strategy that is implemented was discussed above.
Shapes are drawn to the off-screen canvas only at the end of the
drag operation, in the <code>mouseReleased()</code> method.  However,
as the user drags the mouse, the part of the image over which the shape
appears is re-copied from the canvas onto the screen each time the mouse is moved.  
Then the <code>paintComponent()</code> method draws the shape that the user is creating 
on top of the image from the canvas.  
For the non-shape (curve, smudge, and erase) tools, on the other hand,
changes are made directly to the canvas,
and the region that was changed is repainted so that the change will
appear on the screen.  (By the way, the program uses a version of the
<code>repaint()</code> method that repaints just a part of a component.
The command <code>repaint(x,y,width,height)</code> tells the system to
repaint the rectangle with upper left corner <code>(x,y)</code> and with
the specified width and height.  This can be substantially faster than
repainting the entire component.) See the source code,
<sourceref href="PaintWithOffScreenCanvas.java"/>, if you want to
see how it's all done.</p>

<break/>
   
<p>One traditional use of off-screen canvasses is for <newword>double buffering</newword>.
In double-buffering, the off-screen image is an exact copy of the image that
appears on screen; whenever the on-screen picture needs 
to be redrawn, the new picture is
drawn step-by-step to an off-screen image. This can take some time. If all this
drawing were done on screen, the user might see the image flicker as it is
drawn. Instead, the long drawing process takes place off-screen and the completed image is
then copied very quickly onto the screen.
The user doesn't see all the steps involved in redrawing.  This
technique can be used to implement smooth, flicker-free animation.</p>

<p>The term "double buffering" comes from the term "frame buffer," which refers to the region in
memory that holds the image on the screen. In fact, true double buffering uses
two frame buffers. The video card can display either frame buffer on the screen
and can switch instantaneously from one frame buffer to the other. One frame
buffer is used to draw a new image for the screen. Then the video card is told
to switch from one frame buffer to the other. No copying of memory is involved.
Double-buffering as it is implemented in Java does require copying, which takes
some time and is not perfectly flicker-free.</p>

<p>In Java's older AWT graphical API, it was up to the programmer to do
double buffering by hand.  In the Swing graphical API, double buffering is applied
automatically by the system, and the programmer doesn't have to worry about it.  (It is
possible to turn this automatic double buffering off in Swing, but there
is seldom a good reason to do so.)</p>
   
<p>One final historical note about off-screen canvasses: There is an
alternative way to create them.  The <classname>Component</classname> class
defines the following instance method, which can be used in any GUI
component object:</p>

<pre>public Image createImage(int width, int height)</pre>
   
<np>This method creates an <classname>Image</classname> with a specified
width and height.  You can use this image as an off-screen canvas in the
same way that you would a <classname>BufferedImage</classname>. In fact,
you can expect that in a modern version of Java, the image that is returned
by this method is in fact a <classname>BufferedImage</classname>.
The <code>createImage()</code> method was part of Java from the beginning,
before the <classname>BufferedImage</classname> class was introduced.</np>

</subsection>
      
<subsection id="GUI2.1.2" title="Working With Pixels">

<p>One good reason to use a <classname>BufferedImage</classname> is that it
allows easy access to the colors of individual pixels.  If <code>image</code>
is of type <classname>BufferedImage</classname>, then we have the
methods:</p>
   
<ul>
<li><codedef>image.getRGB(x,y)</codedef> &mdash; returns an <ptype>int</ptype>
that encodes the color of the pixel at coordinates <code>(x,y)</code> in the
image.  The values of the integers <code>x</code> and <code>y</code> must lie within
the image. That is, it must be true that <code>0&nbsp;&lt;=&nbsp;x&nbsp;&lt; image.getWidth()</code>
and <code>0&nbsp;&lt;=&nbsp;y&nbsp;&lt; image.getHeight()</code>; if not, then an
exception is thrown.</li>
<li><codedef>image.setRGB(x,y,rgb)</codedef> &mdash; sets the color of the pixel
at coordinates <code>(x,y)</code> to the color encoded by <code>rgb</code>.  Again,
<code>x</code> and <code>y</code> must be in the valid range.  The third parameter,
<code>rgb</code>, is  an integer that encodes the color.</li>
</ul>
   
<np>These methods use integer codes for colors.  If <code>c</code> is of type
<classname>Color</classname>, the integer code for the color can be obtained by
calling <code>c.getRGB()</code>.  Conversely, if <code>rgb</code> is an integer
that encodes a color, the corresponding <classname>Color</classname> object
can be obtained with the constructor call <code>new&nbsp;Color(rgb)</code>.
This means that you can use
</np>
   
<pre>Color c = new Color( image.getRGB(x,y) )</pre>
   
<np>to get the color of a pixel as a value of type <classname>Color</classname>.  And
if <code>c</code> is of type <classname>Color</classname>, you can set a pixel
to that color with</np>
   
<pre>image.setRGB( x, y, c.getRGB() );</pre>
   
<p>The red, green, and blue components of a color are represented as 8-bit integers,
in the range 0 to 255.  When a color is encoded as a single <ptype>int</ptype>,
the blue component is contained in the eight low-order bits of the <ptype>int</ptype>,
the green component in the next lowest eight bits, and the red component in
the next eight bits.  (The eight high order bits store the "alpha component" of
the color, which we'll encounter in the next section.)  
It is easy to translate between the two representations using the
<newword>shift operators</newword> <code>&lt;&lt;</code> and&nbsp;<code>&gt;&gt;</code>
and the <newword>bitwise logical operators</newword> <code>&amp;</code> and&nbsp;<code>|</code>.
(I have not covered these operators previously in this book.  Briefly: If <code>A</code> and
<code>B</code> are integers, then <code>A&nbsp;&lt;&lt;&nbsp;B</code> is the integer
obtained by shifting each bit of <code>A</code>, <code>B</code> bit positions to
the left; <code>A&nbsp;&gt;&gt;&nbsp;B</code> is the integer
obtained by shifting each bit of <code>A</code>, <code>B</code> bit positions to
the right; <code>A&nbsp;&amp;&nbsp;B</code> is the integer obtained by applying the
logical <b>and</b> operation to each pair of bits in <code>A</code> and <code>B</code>;
and <code>A&nbsp;|&nbsp;B</code> is obtained similarly, using the logical <b>or</b>
operation.  For example, using 8-bit binary numbers, we have:
<code>01100101&nbsp;&amp;&nbsp;10100001</code> is <code>00100001</code>,
while <code>01100101&nbsp;|&nbsp;10100001</code> is <code>11100101</code>.)
You don't necessarily need to understand these operators. Here
are incantations that you can use to work with color codes:</p>

<pre>/* Suppose that rgb is an int that encodes a color.
   To get separate red, green, and blue color components: */
   
int red = (rgb &gt;&gt; 16) &amp; 0xFF;
int green = (rgb &gt;&gt; 8) &amp; 0xFF;
int blue = rgb &amp; 0xFF;
   
/* Suppose that red, green, and blue are color components in
   the range 0 to 255.  To combine them into a single int: */
   
int rgb = (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue;</pre>
   
<break/>

<p>An example of using pixel colors in a <classname>BufferedImage</classname> is provided
by the smudge tool in the sample program <sourceref href="PaintWithOffScreenCanvas.java"/>.
The purpose of this tool is to smear the colors of an image, as if it were drawn in
wet paint.  For example, if you rub the middle of a black rectangle with the
smudge tool, you'll get something like this:
</p>
   
<img src="smudgedRectangle.png" width="138" height="75" alt="Picture of smudged rectangle"
   tex="smudgedRectangle.eps" texscale="0.75"/>
   
<np>This is an effect that can only be achieved by manipulating the colors of
individual pixels!  Here's how it works: when the user presses the mouse using
the smudge tool, the color components of a 7-by-7 block of pixels are copied
from the off-screen canvas into arrays named <code>smudgeRed</code>,
<code>smudgeGreen</code> and <code>smudgeBlue</code>.  This is done
in the <code>mousePressed()</code> routine with the following code:</np>

<pre>int w = OSC.getWidth();
int h = OSC.getHeight();
int x = evt.getX();
int y = evt.getY();
for (int i = 0; i &lt; 7; i++)
   for (int j = 0; j &lt; 7; j++) {
      int r = y + j - 3;
      int c = x + i - 3;
      if (r &lt; 0 || r &gt;= h || c &lt; 0 || c &gt;= w) {
            // A -1 in the smudgeRed array indicates that the
            // corresponding pixel was outside the canvas.
         smudgeRed[i][j] = -1;
      }
      else {
         int color = OSC.getRGB(c,r);
         smudgeRed[i][j] = (color >> 16) &amp; 0xFF;
         smudgeGreen[i][j] = (color >> 8) &amp; 0xFF;
         smudgeBlue[i][j] = color &amp; 0xFF;
      }
   }</pre>
   
<np>The arrays are of type <atype>double[][]</atype> because I am going to
do some computations with them that require real numbers.  As the user
moves the mouse, the colors in the array are blended with the colors in
the image, just as if you were mixing wet paint by smudging it with your
finger.  That is, the colors at the new mouse position in the image are replaced with a weighted average
of the current colors in the image and the colors in the arrays.  This has
the effect of moving some of the color from the previous mouse position to
the new mouse position.  At the same time, the colors in the arrays are
replaced by a weighted average of the old colors in the arrays and the colors
from the image.  This has the effect of moving some color from the image
into the arrays.  This is done using the following code for each pixel position,
<code>(c,r)</code>, in a 7-by-7 block around the new mouse location:</np>
   
<pre>int curCol = OSC.getRGB(c,r);
int curRed = (curCol &gt;&gt; 16) &amp; 0xFF;
int curGreen = (curCol &gt;&gt; 8) &amp; 0xFF;
int curBlue = curCol &amp; 0xFF;
int newRed = (int)(curRed*0.7 + smudgeRed[i][j]*0.3);
int newGreen = (int)(curGreen*0.7 + smudgeGreen[i][j]*0.3);
int newBlue = (int)(curBlue*0.7 + smudgeBlue[i][j]*0.3);
int newCol = newRed &lt;&lt; 16 | newGreen &lt;&lt; 8 | newBlue;
OSC.setRGB(c,r,newCol);
smudgeRed[i][j] = curRed*0.3 + smudgeRed[i][j]*0.7;
smudgeGreen[i][j] = curGreen*0.3 + smudgeGreen[i][j]*0.7;
smudgeBlue[i][j] = curBlue*0.3 + smudgeBlue[i][j]*0.7;</pre>
   
</subsection>
      
<subsection id="GUI2.1.3" title="Resources">

<p>Throughout this textbook, up until now, we have been thinking of a program
as made up entirely of Java code.  However, programs often use
other types of data, including images, sounds, and text, as part of
their basic structure.  These data are referred to as <newword>resources</newword>.
An example is the image file, <code>cards.png</code>, that was used in the
<sourceref href="HighLowWithImages.java"/> program earlier in this section.  This file is
part of the program.  The program needs it in order to run.  The user of
the program doesn't need to know that this file exists or where it is
located; as far as the user is concerned, it is just part of the program.
The program of course, does need some way of locating the resource file and
loading its data.</p>
   
<p>Resources are ordinarily stored in files that are in the same locations
as the compiled class files for the program.  Class files are located
and loaded by something called a <newword>class loader</newword>, which
is represented in Java by an object of type <classname>ClassLoader</classname>.
A class loader has a list of locations where it will look for class files.
This list is called the <newword>class path</newword>.  It includes the
location where Java's standard classes are stored.  It generally includes
the current directory.  If the program is stored in a jar file, the jar
file is included on the class path.  In addition to class files, a
<classname>ClassLoader</classname> is capable of finding resource files
that are located on the class path or in subdirectories of locations that
are on the class path.</p>
   
<p>The first step in using a resource is to obtain a <classname>ClassLoader</classname>
and to use it to locate the resource file.  In the <code>HighLowWithImages</code> program,
this is done with:</p>
   
<pre>ClassLoader cl = getClass().getClassLoader();
URL imageURL = cl.getResource("cards.png");</pre>
   
<np>The idea of the first line is that in order to get a class loader,
you have to ask a class that was loaded by the class loader.  Here,
<code>getClass()</code> is a reference to the object that
represents the actual class, <classname>HighLowWithImages</classname>.
The <code>getClass()</code> method is an instance method in class <classname>Object</classname>
and so can be used with any object.  Another way to get a reference to
a class loader is to use <code>ClassName.class</code>, where <classname>ClassName</classname>
is the name of any class.  For example, I could have used
<code>HighLoadWithImages.class.getClassLoader()</code> to get
the class loader in this case.</np>

<p>The second line in the above code uses the class loader to locate the resource
file named <code>cards.png</code>.  The return value of <code>cl.getResource()</code>
is of type <code>java.net.URL</code>, and it represents the location of
the resource rather than the resource itself.  If the resource file
cannot be found, then the return value is null.
The class <classname>URL</classname> was discussed in <localref href="IO.4.1"/>.</p>
   
<p>Often, resources are stored not directly on the class path but in a
subdirectory.  In that case, the parameter to <code>getResource()</code>
must be a path name that includes the directory path to the resource.
For example, suppose that the image file "cards.png" were stored in
a directory named <code>images</code> inside a directory named
<code>resources</code>, where <code>resources</code> is directly on
the class path.  Then the path to the file is "resources/images/cards.png"
and the command for locating the resource would be</p>
   
<pre>URL imageURL = cl.getResource("resources/images/cards.png");</pre>
   
<p>Once you have a <classname>URL</classname> that represents the location of
a resource file, you could use a <classname>URLConnection</classname>,
as discussed in <localref href="IO.4.1"/>, to read the contents of
that file.  However, Java provides more convenient methods for loading
several types of resources.  For loading image resources, a
convenient method is available in the class <code>java.awt.Toolkit</code>.
It can be used as in the following line from <code>HighLowWithImages</code>,
where <code>cardImages</code> is an instance variable of type
<classname>Image</classname> and <code>imageURL</code> is the
<classname>URL</classname> that represents the location of the image
file:</p>
   
<pre>cardImages = Toolkit.getDefaultToolkit().createImage(imageURL);</pre>
   
<np>This still does not load the image completely&mdash;that will only be
done later, for example when <code>cardImages</code> is used in a
<code>drawImage</code> command.  Another technique, which does read
the image completely, is to use the <code>ImageIO.read()</code>
method, which will be discussed below in <localref href="GUI2.1.5"/></np>
   
<break/>
   
<p>Sounds represent another kind of resource that a program might want to use.
For some reason, the easiest way to playing a sound is to use a static method
in the <classname>Applet</classname> class, in package <code>java.awt</code>:</p>
   
<pre>public static AudioClip newAudioClip(URL soundURL)</pre>
   
<np>
Since this is a <code>static</code> method, it can be used in any
program, not just in applets, simply by calling it as <code>Applet.newAudioClip(soundURL)</code>.
The parameter is the URL of a sound resource, and the return value is of type
<code>java.applet.AudioClip</code>.  Once you have an <classname>AudioClip</classname>,
you can call its <code>play()</code> method to play the audio clip from the
beginning.</np>

<p>Here is a method that puts all this together to load and play
the sound from an audio resource file:</p>
   
<pre>private void playAudioResource(String audioResourceName) {
   ClassLoader cl = getClass().getClassLoader();
   URL resourceURL = cl.getResource(audioResourceName);
   if (resourceURL != null) {
      AudioClip sound = Applet.newAudioClip(resourceURL);
      sound.play();
   }
}</pre>
   
<np>This method is from a sample program <sourceref href="SoundAndCursorDemo.java"/> that
will be discussed in the next subsection.  Of course, if you plan to reuse
the sound often, it would be better to load the sound once into an
instance variable of type <classname>AudioClip</classname>, which could then
be used to play the sound any number of times, without the need to reload
it each time.</np>

<p>The <classname>AudioClip</classname> class supports audio files in the
common WAV, AIFF, and AU formats.</p>

</subsection>

<subsection id="GUI2.1.4" title="Cursors and Icons">

<p>The position of the mouse is represented on the computer's screen by
a small image called a <newword>cursor</newword>.  In Java, the cursor
is represented by an object of type <code>java.awt.Cursor</code>.
A <classname>Cursor</classname> has an associated image.  It also
has a <newword>hot spot</newword>, which is a <classname>Point</classname>
that specifies the pixel within the image that corresponds to the exact
position on the screen where the mouse is pointing.  For example, for a
typical "arrow" cursor, the hot spot is the tip of the arrow.  For
a "crosshair" cursor, the hot spot is the center of the crosshairs.</p>

<p>The <classname>Cursor</classname> class defines several standard
cursors, which are identified by constants such as
<code>Cursor.CROSSHAIR_CURSOR</code> and <code>Cursor.DEFAULT_CURSOR</code>.
You can get a standard cursor by calling the <code>static</code>
method <code>Cursor.getPredefinedCursor(code)</code>, where <code>code</code>
is one of the constants that identify the standard cursors.  It is
also possible to create a custom cursor from an <classname>Image</classname>.
The <classname>Image</classname> might be obtained as an image resource,
as described in the previous subsection.  It could even be a <classname>BufferedImage</classname>
that you create in your program.  It should be small, maybe 16-by-16 or
24-by-24 pixels.  (Some platforms might only be able to handle certain
cursor sizes; see the documentation for
<code>Toolkit.getBestCursorSize()</code> for more information.)
A custom cursor can be created by calling the <code>static</code> method
<code>createCustomCursor()</code> in the <classname>Toolkit</classname> class:</p>
   
<pre>Cursor c = Toolkit.getDefaultToolkit().createCustomCursor(image,hotSpot,name);</pre>

<np>where <code>hotSpot</code> is of type <classname>Point</classname> and
<code>name</code> is a <classname>String</classname> that will act as
a name for the cursor (and which serves no real purpose that I know of).</np>
   
<p>Cursors are associated with GUI components.  When the mouse moves over a
component, the cursor changes to whatever <classname>Cursor</classname> is associated with that
component.  To associate a <classname>Cursor</classname> with a component,
call the component's instance method <code>setCursor(cursor)</code>.  For example,
to set the cursor for a <classname>JPanel</classname>, <code>panel</code>, to
be the standard "wait" cursor:</p>

<pre>panel.setCursor( Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR) );</pre>
   
<np>To reset the cursor to be the default cursor, you can use:</np>
   
<pre>panel.setCursor( Cursor.getDefaultCursor() );</pre>

<np>To set the cursor to be an image that is defined in an image resource
file named <code>imageResource</code>, you might use:</np>
   
<pre>ClassLoader cl = getClass().getClassLoader();
URL resourceURL = cl.getResource(imageResource);
if (resourceURL != null) {
   Toolkit toolkit = Toolkit.getDefaultToolkit();
   Image image = toolkit.createImage(resourceURL);
   Point hotSpot = new Point(7,7);
   Cursor cursor = toolkit.createCustomCursor(image, hotSpot, "mycursor");
   panel.setCursor(cursor);
}</pre>
   
<p>The sample program <sourceref href="SoundAndCursorDemo.java"/> shows how
to use predefined and custom cursors and how to play sounds from resource
files.  The program has several buttons that you can click.  Some of the
buttons change the cursor that is associated with the main panel of the
program.  Some of the buttons play sounds.  When you play a sound, the
cursor is reset to be the default cursor.</p>
    
<p>Another standard use of images in GUI interfaces is for <newword>icons</newword>.
An icon is simply a small picture.  As we'll see in <localref href="GUI2.3"/>, icons can be used
on Java's buttons, menu items, and labels; in fact, for our purposes, an icon is
simply an image that can be used in this way.</p>
   
<p>An icon is represented by an object of type
<classname>Icon</classname>, which is actually an <code>interface</code> rather than a class.
The class <classname>ImageIcon</classname>, which implements the <classname>Icon</classname>
interface, is used to create icons from <classname>Images</classname>.
If <code>image</code> is a (rather small) <classname>Image</classname>, then
the constructor call <code>new&nbsp;ImageIcon(image)</code> creates an
<classname>ImageIcon</classname> whose picture is the specified image.
Often, the image comes from a resource file.  We will see examples of this
later in this chapter.</p>
   
</subsection>
   
<subsection id="GUI2.1.5" title="Image File I/O">
   
<p>The class <code>javax.imageio.ImageIO</code> makes it easy to save images
from a program into files and to read images from files into a program.
This would be useful in a program such as <code>PaintWithOffScreenCanvas</code>,
so that the users would be able to save their work and to open and edit
existing images. (See <localref href="GUI2.ex.1"/>.)</p>
   
<p>There are many ways that the data for an image could be stored in a file.
Many standard formats have been created for doing this.  Java supports at
least three standard image formats: PNG, JPEG, and GIF.
(Individual implementations of Java might support more.)
The JPEG format is "lossy," which means that the picture that you
get when you read a JPEG file is only an approximation of the picture
that was saved.  Some information in the picture has been lost.  Allowing some
information to be lost makes it possible to compress the image into
a lot fewer bits than would otherwise be necessary.  Usually, the
approximation is quite good.  It works best for photographic images
and worst for simple line drawings.  The PNG format, on the other
hand is "lossless," meaning that the picture in the file is an exact
duplicate of the picture that was saved.  A PNG file is compressed,
but not in a way that loses information.  The compression works best
for images made up mostly of large blocks of uniform color; it works
<b>worst</b> for photographic images.  GIF is an older format that is limited
to just 256 colors in an image; it has mostly been superseded by PNG.</p>
   
<p>Suppose that <code>image</code> is a <classname>BufferedImage</classname>.
The image can be saved to a file simply by calling</p>

<pre>ImageIO.write( image, format, file )</pre>
   
<np>where <code>format</code> is a <classname>String</classname> that specifies
the image format of the file and <code>file</code> is a <classname>File</classname>
that specifies the file that is to be written. (See <localref href="IO.2.2"/> for
information about the <classname>File</classname> class.)  The <code>format</code>
string should ordinarily be either <code>"PNG"</code> or <code>"JPEG"</code>,
although other formats might be supported.</np>
   
<p><code>ImageIO.write()</code> is a <code>static</code> method in the <classname>ImageIO</classname>
class.  It returns a <ptype>boolean</ptype> value that is <code>false</code> if
the image format is not supported.  That is, if the specified image format is
not supported, then the image is <b>not</b> saved, but no exception is thrown.
This means that you should always check the return value!  For example:</p>
   
<pre>boolean hasFormat = ImageIO.write(OSC,format,selectedFile);
if ( ! hasFormat )
   throw new Exception(format + " format is not available.");</pre>
   
<np>If the image format <b>is</b> recognized, it is still possible that
an <classname>IOException</classname> might be thrown when the attempt is made
to send the data to the file.</np>
   
<p>Usually, the file to be used in <code>ImageIO.write()</code> will be selected by
the user using a <classname>JFileChooser</classname>, as discussed in
<localref href="IO.2.3"/>.  For example, here is a typical method for
saving an image.  (The use of "this" as a parameter in several places
assumes that this method is defined in a subclass of <classname>JComponent</classname>.)</p>

<pre>/**
 * Attempts to save an image to a file selected by the user. 
 * @param image the BufferedImage to be saved to the file
 * @param format the format of the image, probably either "PNG" or "JPEG"
 */
private void doSaveFile(BufferedImage image, String format) {
   if (fileDialog == null)
      fileDialog = new JFileChooser();
   fileDialog.setSelectedFile(new File("image." + format.toLowerCase())); 
   fileDialog.setDialogTitle("Select File For Saved Image");
   int option = fileDialog.showSaveDialog(this);
   if (option != JFileChooser.APPROVE_OPTION)
      return;  // User canceled or clicked the dialog's close box.
   File selectedFile = fileDialog.getSelectedFile();
   if (selectedFile.exists()) {  // Ask the user whether to replace the file.
      int response = JOptionPane.showConfirmDialog( null,
            "The file \"" + selectedFile.getName()
            + "\" already exists.\nDo you want to replace it?", 
            "Confirm Save",
            JOptionPane.YES_NO_OPTION, 
            JOptionPane.WARNING_MESSAGE );
      if (response != JOptionPane.YES_OPTION)
         return;  // User does not want to replace the file.
   }
   try {
      boolean hasFormat = ImageIO.write(image,format,selectedFile);
      if ( ! hasFormat )
         throw new Exception(format + " format is not available.");
   }
   catch (Exception e) {
      JOptionPane.showMessageDialog(this,
                      "Sorry, an error occurred while trying to save image.");
      e.printStackTrace();
   }
}</pre>   

<break/>
   
<p>The <classname>ImageIO</classname> class also has a <code>static</code> <code>read()</code>
method for reading an image from a file into a program.  The method</p>
   
<pre>ImageIO.read( inputFile )</pre>
   
<np>takes a variable of type <classname>File</classname> as a parameter and returns
a <classname>BufferedImage</classname>.  The return value is <code>null</code> if
the file does not contain an image that is stored in a supported format.  Again,
no exception is thrown in this case, so you should always be careful to check the
return value.  It is also possible for an <classname>IOException</classname> to
occur when the attempt is made to read the file.  There is another version of the
<code>read()</code> method that takes an <classname>InputStream</classname> instead
of a file as its parameter, and a third version that takes a <classname>URL</classname>.</np>
   
<p>Earlier in this section, we encountered another method for reading an image
from a <classname>URL</classname>, the <code>createImage()</code> method from
the <classname>Toolkit</classname> class.  The difference is that <code>ImageIO.read()</code>
reads the image data completely and stores the result in a <classname>BufferedImage</classname>.
On the other hand, <code>createImage()</code> does not actually read the data;
it really just stores the image location and the data won't be read until later,
when the image is used.  This has the advantage that the <code>createImage()</code> method
itself can complete very quickly.  <code>ImageIO.read()</code>, on the other hand,
can take some time to execute.</p>
   
</subsection>
   
</section>