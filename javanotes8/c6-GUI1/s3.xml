<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../javanotes8.dtd" >

<section id="GUI1.3" title="Basic Events">

<p><start><big>E</big>vents are central</start> to programming for a graphical
user interface. A GUI program doesn't have a <code>main()</code> routine that
outlines what will happen when the program is run, in a step-by-step process
from beginning to end. Instead, the program must be prepared to respond to
various kinds of events that can happen at unpredictable times and in an order
that the program doesn't control. The most basic kinds of events are generated
by the mouse and keyboard. The user can press any key on the keyboard, move the
mouse, or press a button on the mouse. The user can do any of these things at
any time, and the computer has to respond appropriately.</p>

<p>In Java, events are represented by objects. When an event occurs, the system
collects all the information relevant to the event and constructs an object to
contain that information. Different types of events are represented by objects
belonging to different classes. For example, when the user presses one of the
buttons on a mouse, an object belonging to a class called <classname>MouseEvent</classname>
is constructed. The object contains information such as the target of the event (that is, the component on
which the user clicked), the <code>(x,y)</code> coordinates of the point in the
component where the click occurred, which modifier keys (such as the shift key) are being held down,
and which button on the mouse was pressed.
When the user presses a key on the keyboard, on the other hand, it is 
a <classname>KeyEvent</classname> object that is created, containing information
relevant to an event generated by using the keyboard.
After the event object is constructed, it can be passed as a parameter to a
designated method.  That method is called an <newword>event handler</newword> for the
event.  In JavaFX, event handlers are often written as lambda expressions.
By writing an event handler, the programmer says what should happen when the event occurs.</p>

<p>As a Java programmer, you get a fairly high-level view of events. There is a
lot of processing that goes on between the time that the user presses a key or
moves the mouse and the time that a method in your program is called to
respond to the event. Fortunately, you don't need to know much about that
processing. But you should understand this much: Even though you didn't
write it, there is a routine running somewhere that executes a loop of the form</p>

<pre>while the program is still running:
    Wait for the next event to occur
    Handle the event</pre>

<p>This loop is called an <newword>event loop</newword>. Every GUI
program has an event loop. In Java, you don't have to write the loop. It's part
of "the system." If you write a GUI program in some other language, you might
have to provide a main routine that runs the event loop.</p>

<p>In this section, we'll look at handling mouse and key events in Java, and we'll
cover the framework for handling events in general.  We will also see how to
make an animation.</p>


<subsection id="GUI1.3.1" title="Event Handling">

<p>For an event to have any effect, a program must detect the event and react
to it. In order to detect an event, the program must "listen" for it.  
Listening for events is something that is done by an an <newword>event listener</newword>,
which contains an event handler method that can respond to the event.
An event listener is defined by an interface that specifies the event handling
methods that it contains.  Listeners for different kinds of events are defined by
different interfaces.  In most cases, the interface is a functional interface,
defining a single event handler method; in that case, the listener can be given
by a lambda expression.</p>

<p>For many kinds of events in JavaFX, listeners are defined by a functional interface
named <classname>EventHandler</classname>, which defines the method <code>handle(event)</code>.
The parameter to this method, <code>event</code>, is the event object that contains
information about the event.  When you provide a definition for <code>handle()</code>,
you write the code that will be executed to handle the event.</p>

<p>(<classname>EventHandler</classname> is actually a parameterized type, something that
we have not encountered before and will not encounter officially until <localref href="arrays.3"/>.
Basically, all this really means is that <classname>EventHandler</classname> really
defines many different types, with names like <classname>EventHandler&lt;MouseEvent&gt;</classname>,
<classname>EventHandler&lt;KeyEvent&gt;</classname>, and <classname>EventHandler&lt;ActionEvent&gt;</classname>.
The type <classname>EventHandler&lt;MouseEvent&gt;</classname> defines a <code>handle(event)</code>
method in which the <code>event</code> is of type <classname>MouseEvent</classname>,
the type <classname>EventHandler&lt;KeyEvent&gt;</classname> defines a <code>handle(event)</code>
method in which the <code>event</code> is of type <classname>KeyEvent</classname>, and so
on.  Fortunately, you don't need to understand parameterized types in this chapter; you only
need to know that the event object that you use when handling an event will have the appropriate
type for that event.  For example, when handling a mouse event, the
event object is of type <classname>MouseEvent</classname>.)</p>

<p>Many events in JavaFX are associated with GUI components. For example, when
the user presses a button on the mouse, the associated component is the one
that contains the mouse cursor when the button is pressed.  This object is 
called the <newword>target</newword> of the event.  In order to respond to the
event, you need to register a listener either with the target of the event
or with some other object that knows about the event.  For example, lets look again at
this statement from <sourceref href="HelloWorldFX.java"/>, our first GUI program
from <localref href="GUI1.1"/>:</p>

<pre>helloButton.setOnAction( e -> message.setText("Hello World!") );</pre>

<np>Here, <code>helloButton</code> is an object of type <classname>Button</classname>.
When the user clicks on the button, an event of type <classname>ActionEvent</classname>
is generated.  The target of that event is <code>helloButton</code>.
The method <code>helloButton.setOnAction()</code> registers an event listener that will
receive notification of any <classname>ActionEvents</classname> from the button.
The listener in this case is defined by a lambda expression.  In the lambda 
expression, the parameter, <code>e</code>, is the <classname>ActionEvent</classname>
object, and the code in the lambda expression is what happens in response to the
event.  Most event handling in this chapter will be set up in a similar way.</np>

<p>For key events and some mouse events, it's not just the event target
that gets a chance to respond to the event.  For example, suppose
that you press a mouse button over a <classname>Canvas</classname> that is
inside a <classname>BorderPane</classname> that is in turn inside a 
<classname>Scene</classname>.  The target of the mouse event is the <classname>Canvas</classname>
but the <classname>BorderPane</classname> and the <classname>Scene</classname> also have
a chance to respond to the event.  That is, you can register a mouse event listener on any
or all of these objects to respond to the event.  The object that the listener is registered
with is called the <newword>source</newword> of the event.  The event object parameter, <code>evt</code>,
in an event handler method has both a source, given by <code>evt.getSource()</code>,
and a target, given by <code>evt.getTarget()</code>; often they are the same, but they
don't have to be.  Note that the same event can be sent to several handlers.
A handler can "consume" an event, by calling <code>evt.consume()</code>, to stop it
from being sent to any additional handlers. For example, when you are typing in a 
text input box, the input box consumes the key events that you generate by typing,
so that the scene doesn't get a chance to handle them.</p>

<p>(Actually, it's more complicated than that.  For key events and some kinds of mouse
events, the event first travels down through the scene and then through scene graph nodes that contain
the event target; this is called the "event filtering" or "bubble down" phase of event processing.
After reaching the target, the event travels back up through the scene graph and finally to the scene;
this is the "event handling" or "bubble up" phase.  The event can be consumed at any point
along the way, and if that happens, the process stops. None of this is used in this chapter,
but for more information, see the documentation for the <code>addEventFilter()</code>
and <code>addEventHandler()</code> methods in the <classname>Scene</classname>
and <classname>Node</classname> classes.)</p>

<p>Most of this section is concerned with mouse and key events.  It is important to understand
that many GUI programs do not need to deal with such events directly.  Instead, you
work with GUI components that are already programmed to handle mouse and key events on
their own.  For example, when the user clicks a <classname>Button</classname>, it is
the button that listens for mouse events and responds to them.  When the button
detects that it has been clicked, it generates an <classname>ActionEvent</classname>.
When you write an application that uses buttons, you program responses to <classname>ActionEvents</classname>,
not to mouse events.  Similarly, when the user types in a text input box, it is the input box
that listens for key events and responds to them.  Nevertheless, at base, it's mouse and
keyboard events that drive the action in a program.  It's useful to understand them&mdash;and
you can do some interesting things by processing them directly.</p>

</subsection>

<subsection title="Mouse Events" id="GUI1.3.2">

<p>A mouse event is represented by an object of type <classname>MouseEvent</classname>.
(In fact, mouse events can actually be generated by other input devices, such as
a trackpad or touch screen; events from these devices are translated by the system
into <classname>MouseEvents</classname>.)  That class, and all of the classes related 
to mouse and key events, can be found in
package <code>javafx.scene.input</code>.  As the user manipulates the mouse, several
kinds of event are generated.  For example, clicking a mouse button generates three
events, a "mouse pressed" event, a "mouse released" event, and a "mouse clicked" event.
Simply moving the mouse generates a sequence of events as the mouse cursor moves from point
to point on the screen.  To respond to mouse events on a
component, you can register listeners with that component.  You can register a separate
listener for each kind of mouse event on a component <code>c</code> using instance methods 
such as <code>c.setOnMousePressed(handler)</code> and <code>c.setOnMouseMoved(handler)</code>.
The parameter is a mouse event handler, generally given as a lambda expression.  Suppose,
for example, that <code>canvas</code> is a component of type <classname>canvas</classname>,
and that you would like a method, <code>redraw()</code>, to be called when the user
clicks the canvas.  You can make that happen by saying</p>

<pre>canvas.setOnMousePressed( evt -&gt; redraw() );</pre>

<np>Generally, you would put this statement in the <code>start()</code> method of
an <classname>Application</classname>, while setting up the GUI for the program.
Mouse clicks on the canvas could be also be handled by the scene or by any
scene graph node that contains the canvas, directly or indirectly, but it is much more usual for the target of
a mouse event to handle the event.</np>

<p>Mouse event types include:
<code>MouseEntered</code>, generated when the mouse cursor moves from outside a component into the component;
<code>MouseExited</code>, generated when the mouse cursor moves out of a component;
<code>MousePressed</code>, generated when the user presses one of the buttons on the mouse;
<code>MouseReleased</code>, generated when the user releases one of the buttons on the mouse;
<code>MouseClicked</code>, generated after a mouse released event if the user pressed and released the mouse button on the same component;
<code>MouseDragged</code>, generated when the user moves the mouse while holding down a mouse button; and
<code>MouseMoved</code>, generated when the user moves the mouse without holding down a button.</p>

<p>The target of a <code>MouseDragged</code>, <code>MouseReleased</code>, or <code>MouseClicked</code>
event is the same component where the mouse button was pressed, even if the mouse has moved outside
of that component.  The target of a <code>MousePressed</code> or <code>MouseMoved</code> event is
the component that contains the mouse cursor when the event occurs.  And for <code>MouseEntered</code>
and <code>MouseExited</code>, the target is the component that is being entered or exited.</p>

<p>Often, when a mouse event occurs, you want to know the location of the mouse
cursor. This information is available from the <classname>MouseEvent</classname>
parameter in the event-handling method, which
contains instance methods that return information about the event. 
If <code>evt</code> is the parameter, then you can find out
the coordinates of the mouse cursor by calling  <code>evt.getX()</code> and
<code>evt.getY()</code>. These methods return values of type <ptype>double</ptype> 
that give the <code>x</code> and <code>y</code> coordinates where the mouse cursor 
was positioned at the time when the event occurred. The
coordinates are expressed in the coordinate system of the source of the
event, where the top left corner of the component is (0,0).  (The source is
the component on which the event listener is registered; this is not necessarily
the same as the event target, but it usually is.)</p>

<p>The user can hold down certain <newword>modifier keys</newword>
while using the mouse. The possible modifier keys include: the Shift key, the
Control key, the Alt key (called the Option key on the Mac), and the Meta
key (called the Command or Apple key on the Mac).  Not every computer has a Meta key.
You might want to respond to a mouse event differently when the user
is holding down a modifier key. The boolean-valued instance methods
<code>evt.isShiftDown()</code>, <code>evt.isControlDown()</code>,
<code>evt.isAltDown()</code>, and <code>evt.isMetaDown()</code> can be called to test
whether the modifier keys are pressed.</p>

<p>You might also want to have different responses depending on whether the
user presses the left mouse button, the middle mouse button, or the right mouse
button.   For events triggered by a mouse button, 
you can determine which button was pressed or released by calling
<code>evt.getButton()</code>, which returns one of the enumerated type constants
<code>MouseButton.PRIMARY</code>, <code>MouseButton.MIDDLE</code>, or <code>MouseButton.SECONDARY</code>.
Generally, the left mouse button is the primary button and the right mouse button is secondary.
For events such as mouseEntered and mouseExited that are not triggered by buttons,
<code>evt.getButton()</code> returns <code>MouseButton.NONE</code>.</p>

<p>The user can hold down several mouse buttons at the same time.  If you want to know
which mouse buttons are actually down at the time of an event, you can use the
boolean-valued functions <code>evt.isPrimaryButtonDown()</code>, <code>evt.isMiddleButtonDown()</code>,
and <code>evt.isSecondaryButtonDown()</code>.</p>

<p>As a simple example, suppose that when the user clicks a <classname>Canvas</classname>,
<code>canvas</code>, you would like to draw a red rectangle at the point where the user clicked.
But if the shift key is down, you want to draw a blue oval instead.
An event handler to do that can be defined as:</p>

<pre>canvas.setOnMousePressed( evt -&gt; {
    GraphicsContext g = canvas.getGraphicsContext2D();
    if ( evt.isShiftDown() ) {
        g.setFill( Color.BLUE );
        g.fillOval( evt.getX() - 30, evt.getY() - 15, 60, 30 )
    }
    else {
        g.setFill( Color.RED );
        g.fillRect( evt.getX() - 30, evt.getY() - 15, 60, 30 );
    }
} );</pre>

<p>To get a better idea of how mouse events work, you should try the sample program
<sourceref href="SimpleTrackMouse.java"/>.  This program
responds to any of the seven different kinds of mouse events
by displaying the coordinates of the mouse, the type of event, and a list of
the modifier keys and buttons that are down. 
You can experiment with the program to see what happens as you do various
things with the mouse.  I also encourage you to read the source code.</p>

</subsection>

<subsection title="Dragging" id="GUI1.3.3">

<p>A drag gesture occurs when the user moves the mouse while holding down
one of the buttons on the mouse.  It is interesting to look at what a program needs to do in order to respond
to dragging operations. The drag gesture starts when the user presses a mouse button, it continues
while the mouse is dragged, and it ends when the user releases the button. This
means that the programming for the response to one dragging gesture must be
spread out over the three event handlers, one for <code>MousePressed</code>,
one for <code>MouseDragged</code>, and one for <code>MouseReleased</code>! 
Furthermore, the <code>MouseDragged</code> handler
can be called many times as the mouse moves. To keep track of what is
going on between one method call and the next, you need to set up some instance
variables. In many applications, for example, in order to process a
<code>MouseDragged</code> event, you need to remember the previous coordinates of
the mouse. You can store this information in two instance variables
<code>prevX</code> and <code>prevY</code> of type <ptype>double</ptype>.  It can also
be useful to save the starting coordinates, where the original <code>MousePressed</code> event
occurred, in instance variables.   And I suggest having a
<ptype>boolean</ptype> variable, <code>dragging</code>, which is set to <code>true</code>
while a dragging gesture is being processed. This is necessary because in many applications, not
every <code>MousePressed</code> event starts a dragging operation to which you want to respond.
Also, if the user presses a second mouse button without releasing the first, there will be
two <code>MousePressed</code> events before the <code>MouseReleased</code> event; usually,
you don't want the second <code>MousePressed</code> to start a new drag operation. The
event-handling methods can use the value of
<code>dragging</code> to check whether a drag operation is actually in progress.
Often, I will write instance methods to handle the events, which in outline
look something like this:</p>

<pre>private double startX, startY; // Point where original mouse press occurred. 
private double prevX, prevY;   // Most recently processed mouse coords.
private boolean dragging;      // Set to true when dragging is in progress.
. . . // other instance variables for use in dragging

public void mousePressed(MouseEvent evt) {
   if (dragging) {
         // The user pressed a second mouse button before releasing the first.
         // Ignore the second button press.
       return;
   }
   if ( <bnf>we-want-to-start-dragging</bnf> ) {
       dragging = true;
       startX = evt.getX();  // Remember starting position.
       startY = evt.getY();
       prevX = startX;       // Remember most recent coords.
       prevY = startY;
          . 
          . // Other processing.
          .
   }
}

public void mouseDragged(MouseEvent evt) {
    if ( dragging == false )  // First, check if we are 
        return;               //   processing a dragging gesture.
    int x = evt.getX(); // Current position of Mouse.
    int y = evt.getY();
      .  
      .  // Process a mouse movement from (prevX, prevY) to (x,y).
      .
    prevX = x;  // Remember the current position for the next call.
    prevY = y;
}

public void mouseReleased(MouseEvent evt) {
    if ( dragging == false )  // First, check if we are 
        return;               //   processing a dragging gesture.
    dragging = false;  // We are done dragging.
     .
     .  // Other processing and clean-up.
     .
}</pre>

<np>I will then install event handlers on the relevant component that simply
call these methods:</np>

<pre>c.setOnMousePressed( e -&gt; mousePressed(e) );
c.setOnMouseDragged( e -&gt; mouseDragged(e) );
c.setOnMouseReleased( e -&gt; mouseReleased(e) );</pre>

<np>Note that the event handlers in these statements simply call another method in
the same class, and that method has the same parameter as the event handler.
That means that it's possible to write the lambda expressions as method 
references (<localref href="subroutines.4a.4"/>).  The methods that are called are instance
methods in the object "<code>this</code>", so the method references would
have names like <code>this::mousePressed</code>, and the event handlers
could be installed using
</np>

<pre>c.setOnMousePressed( this::mousePressed );
c.setOnMouseDragged( this::mouseDragged );
c.setOnMouseReleased( this::mouseReleased );</pre>

<break/>

<p>As an example, let's look at a typical use of dragging: allowing the user to
sketch a curve by dragging the mouse. This example also shows many other
features of graphics and mouse processing. In the program, you can
draw a curve by dragging the mouse on a large white drawing area, and you can
select a color for
drawing by clicking on one of several colored rectangles to the right of the
drawing area. The complete source code can be found in <sourceref href="SimplePaint.java"/>.
Here is a picture of the program window after some drawing has been done:</p>

<img src="simple-paint.png" width="450" height="300" alt="screenshot from SimplePaing showing a sample drawing"
      tex="simple-paint.eps" texscale="0.6"/>

<p>I will discuss a few aspects of the source code
here, but I encourage you to read it carefully in its entirety. There are
lots of informative comments in the source code.  </p>

<p>In this program, all drawing is done on a single canvas that fills the entire
window.  The program is designed to work for any reasonable canvas
size, that is, unless the canvas is too small. This means that
coordinates are computed in terms of the actual width and height of the canvas.
(The width and height are obtained by calling <code>canvas.getWidth()</code> and
<code>canvas.getHeight()</code>.) This makes things quite a bit harder than they
would be if we assumed some particular fixed size for the canvas. Let's look at
some of these computations in detail. For example, the large white drawing
area extends from <code>y&nbsp;=&nbsp;3</code> to <code>y&nbsp;=&nbsp;height&nbsp;-&nbsp;3</code> vertically and
from <code>x&nbsp;=&nbsp;3</code> to <code>x&nbsp;=&nbsp;width&nbsp;-&nbsp;56</code> horizontally.  These numbers
are needed in order to interpret the meaning of a mouse click.  They take into
account a gray border around the canvas and the color palette along the right
edge of the canvas. The gray border is 3 pixels wide.  The colored rectangles are 50
pixels wide.  Together with the 3-pixel border around the canvas and 
a 3-pixel divider between the drawing area and the colored
rectangles, this adds up to put the right edge of the drawing area 56
pixels from the right edge of the canvas.</p>

<p>A white square labeled "<code>CLEAR</code>" occupies the region
beneath the colored rectangles on the right edge of the canvas.
Allowing for this region, we can figure out how
much vertical space is available for the seven colored rectangles, and then
divide that space by 7 to get the vertical space available for each rectangle.
This quantity is represented by a variable, <code>colorSpace</code>. Out of this
space, 3 pixels are used as spacing between the rectangles, so the height of
each rectangle is <code>colorSpacing&nbsp;-&nbsp;3</code>. The top of the <code>N</code>-th
rectangle is located <code>(N*colorSpacing&nbsp;+&nbsp;3)</code> pixels down from the top of
the canvas, assuming that we count the rectangles starting with zero. This is because there are
<code>N</code> rectangles above the <code>N</code>-th rectangle, each of which uses
<code>colorSpace</code> pixels. The extra 3 is for the border at the top of the
canvas. After all that, we can write down the command for drawing the
<code>N</code>-th rectangle:</p>

<pre>g.fillRect(width - 53, N*colorSpace + 3, 50, colorSpace - 3);</pre>
   
<np>That was not easy! But it shows the kind of careful thinking and precision
graphics that are sometimes necessary to get good results.</np>

<p>The mouse in this program is used to do three different things: Select a
color, clear the drawing, and draw a curve. Only the third of these involves
dragging, so not every mouse click will start a dragging operation. The
<code>mousePressed()</code> method has to look at the <code>(x,y)</code> coordinates
where the mouse was clicked and decide how to respond. If the user clicked on
the <code>CLEAR</code> rectangle, the drawing area is cleared by calling a
<code>clearAndDrawPalette()</code> method that redraws the entire canvas. 
If the user clicked somewhere in the strip of colored
rectangles, the corresponding color is selected for drawing. This involves computing which color
the user clicked on, which is done by dividing the <code>y</code> coordinate by
<code>colorSpacing</code>. Finally, if the user clicked on the drawing area, a drag
operation is initiated. In this case, a boolean variable, <code>dragging</code>, is set to
<code>true</code> so that the <code>mouseDragged</code> and <code>mouseReleased</code>
methods will know that a curve is being drawn. The code for this follows the
general form given above. The actual drawing of the curve is done in the
<code>mouseDragged()</code> method, which draws a line from the previous location of
the mouse to its current location. Some effort is required to make sure that
the line does not extend beyond the white drawing area of the canvas. This is
not automatic, since as far as the computer is concerned, the border and the
color bar are part of the canvas. If the user drags the mouse outside
the white drawing area while drawing a curve, the <code>mouseDragged()</code> routine
changes the <code>x</code> and <code>y</code> coordinates to make them lie within the
drawing area.</p>

</subsection>


<subsection title="Key Events" id="GUI1.3.4">

<p>In Java, user actions become events in a program, with a GUI component
as the target of the event.  When the user presses a button on the mouse,
the component that contains the mouse cursor is the target of the event. 
But what about keyboard events? When the user presses a key, what component is 
the target of the <classname>KeyEvent</classname> that is generated?</p>

<p>A GUI uses the idea of <newword>input focus</newword> to determine
the target of keyboard events. At any given time, just one
interface element on the screen can have the input focus, and that is where
keyboard events are directed.  If the interface element happens to be a JavaFX
component, then the information about the keyboard event becomes an object
of type <classname>KeyEvent</classname>, and it is delivered to any key event handlers that are
listening for <code>KeyEvents</code> associated with that component.
Note that because of the way key events are processed, the <classname>Scene</classname>
object in the window that contains the focused component also gets a chance
to handle a key event.  If there is no other focused component in the window, then
the scene itself will be the target for key events.  In my sample programs,
I will usually add key event handlers to the scene object.</p>

<p>A program generally gives some visual feedback to the user about which component
has the input focus. For example, if the component is a text-input box,
the feedback is usually in the form of a blinking text cursor.
Another possible visual clue is to draw a brightly colored border around the edge
of a component when it has the input focus.  You might see that on a button that
has focus.  When a button has focus, pressing the space bar is equivalent to
clicking the button.</p>

<p>If <code>comp</code> is any component, and you would like it to have the
input focus, you can call <code>comp.requestFocus()</code>.  
In a typical user interface, the user can choose to give the focus to a component by
clicking on that component with the mouse. And pressing the tab key will often
move the focus from one component to another.  This is handled automatically by
the components involved, without any programming on your part.
However, some components do not automatically request the input focus when the user
clicks on them.  That includes, for example, a <classname>Canvas</classname>.
Such a component can still receive the input focus if its <code>requestFocus()</code>
is called.  However, you can't automatically move the focus to that component
with the tab key.  To enable that, you can call <code>comp.setFocusTraversable(true)</code>.
And you can test whether a component is focused by calling
<code>comp.isFocused()</code>.</p>

<p>The focused component is contained in&mdash;or sometimes is itself&mdash;a window.
That window is said to be the "focused" or "active" window.  It is usually the front
window on the screen.  In JavaFX a <classname>Stage</classname> object is a window.
You can call <code>stage.requestFocus()</code> to request that the window be moved to
the front of the screen and become the active window.  And you can call
<code>stage.isFocused()</code> to test whether the window is active.</p>

<break/>

<p>Java makes a careful distinction between <i>the keys that you press</i> and
<i>the characters that you type</i>. There are lots of keys on a keyboard:
letter keys, number keys, modifier keys such as Control and Shift, arrow keys,
page up and page down keys, keypad keys, function keys, and so on. In some cases, such as the shift key,
pressing a key does not type a character. On the other hand, typing a character
sometimes involves pressing several keys. For example, to type an uppercase
"A", you have to press the Shift key and then press the A key before releasing
the Shift key. On my Mac&nbsp;OS computer, I can type an accented e, by
holding down the Option key, pressing the E key, releasing the Option key, and
pressing E again. Only one character was typed, but I had to perform three
key-presses and I had to release a key at the right time.</p>

<p>In JavaFX, there are three types of key event:  <code>KeyPressed</code>, which is generated when
the user depresses any key on the keyboard; <code>KeyReleased</code>, which is generated
when the user releases a key that had been pressed; and <code>KeyTyped</code>, which
is generated when the user types a character, possibly using a series of key presses and
key releases.  Note that one user action, such as pressing the E
key, can be responsible for two events, a <code>keyPressed</code> event and a
<code>keyTyped</code> event. Typing an upper case "A" can generate two
<code>keyPressed</code> events, two <code>keyReleased</code> events, and one <code>keyTyped</code>
event.</p>

<p>Usually, it is better to think in terms of two separate streams of events,
one consisting of <code>keyPressed</code> and <code>keyReleased</code> events and the
other consisting of <code>keyTyped</code> events. For some applications, you want
to monitor the first stream; for other applications, you want to monitor the
second one. Of course, the information in the <code>keyTyped</code> stream could be
extracted from the <code>keyPressed/keyReleased</code> stream, but it would be
difficult (and also system-dependent to some extent). Some user actions, such
as pressing the Shift key, can only be detected as <code>keyPressed</code> events.
I used to have a computer solitaire game that highlighted every card that could be
moved, when I held down the Shift key. You can do something like that in Java
by highlighting the cards when the Shift key is pressed and removing the highlight
when the Shift key is released.</p>

<p>There is one more complication. When you hold down a key on the
keyboard, that key might <newword>auto-repeat</newword>. This means
that it will generate multiple <code>KeyPressed</code> events with just one
<code>KeyReleased</code> at the end of the sequence. 
It can also generate multiple <code>KeyTyped</code> events. For the most
part, this will not affect your programming, but you should not expect every
<code>KeyPressed</code> event to have a corresponding <code>KeyReleased</code>
event.</p>

<p>Each key on the keyboard has a code that identifies it.  In JavaFX, 
key codes are represented by enumerated type constants from the enum <classname>KeyCode</classname>.
When an event handler for a <code>KeyPressed</code> or <code>KeyReleased</code>
event is called, the parameter, <code>evt</code>, contains the code of the key
that was pressed or released. The code can be obtained by calling the function
<code>evt.getCode()</code>.  For example, when the user presses the shift key,
this function will return the value <code>KeyCode.SHIFT</code>.  You can find all the
codes in the documentation for <classname>KeyCode</classname>, but names for most keys
are easy to guess.  Letter keys have names like <code>KeyCode.A</code> and <code>KeyCode.Q</code>.
The arrow keys are named <code>KeyCode.LEFT</code>, <code>KeyCode.RIGHT</code>, <code>KeyCode.UP</code>, 
and <code>KeyCode.DOWN</code>.  The space bar is <code>KeyCode.SPACE</code>.  And
function keys have names like <code>KeyCode.F7</code>.</p>

<p>In the case of a <code>KeyTyped</code> event, you want to know which character
was typed. This information can be obtained by calling the function
<code>evt.getCharacter()</code>. This function returns a value of type <ptype>String</ptype>
that contains the character that was typed.</p>

<p>As a first example, you can check out the sample program
<sourceref href="KeyboardEventDemo.java"/>.  This program draws a
small square on a canvas.  The user can move the square left, right, up,
and down by pressing arrow keys.  This is implemented in a method
</p>

<pre>private void keyPressed( KeyEvent evt )</pre>

<np>that is called by an event handler for <code>KeyPressed</code> events.  The
handler is installed on the <classname>Scene</classname> object in the <code>start()</code>
method with the statement</np>

<pre>scene.setOnKeyPressed( e -> keyPressed(e) );</pre>

<np>In the <code>keyPressed()</code> method, the value of 
<code>evt.getCode()</code> is checked.  If it's one of the arrow keys that
was pressed, the canvas is redrawn to show the square in a different position.</np>

<p>The program also installs handlers for <code>KeyReleased</code> and
<code>KeyTyped</code> events in a similar way.  To give the <code>KeyTyped</code>
handler something to do, it changes the color of the square when the user types
"r", "g", "b", or "k".  I encourage you to run the program and to read the
entire source code.</p>

</subsection>


<subsection title="AnimationTimer" id="GUI1.3.5">

<p>There is another kind of basic event that I would like to introduce before
turning to a more interesting example; that is, events that are used to drive
an animation.  The events in this case happen in the background, and you don't have 
to register a listener to respond to them.  However, you do need to write a
method that will be called by the system when the events occur.</p>

<p>A computer animation is just a sequence of still images, presented to the user
one after the other.  If the time between images is short, and if the change from one
image to another is not too great, then the user perceives continuous motion.
In JavaFX, you can program an animation using an object of type <classname>AnimationTimer</classname> 
from package <code>javafx.animation</code>.  An <classname>AnimationTimer</classname>, <code>animator</code>,
has a method <code>animator.start()</code> that you can call to start the animation running or
to restart it if it has been paused. It has the method <code>animator.stop()</code> to pause the animation.
It also has a method <code>handle(time)</code>, but <code>handle()</code> is not a
method that you call; it's one that you need to write to say what happens in the animation.
The system will call your <code>handle()</code> method once for each frame of the animation.
Its job is to do whatever is necessary to implement each frame.</p>

<p>The <code>handle()</code> method will be called on the JavaFX application thread,
which means that you can do things like draw on a canvas or manipulate a 
GUI component.  However, whatever you do should not take very long, since
JavaFX animations are meant to run at 60 frames per second, which means
<code>handle()</code> will ideally be called every 1/60 second.  </p>

<p><classname>AnimationTimer</classname> itself is
an abstract class, and <code>handle()</code> is an abstract method.  This means that
to make an animation, you need to write a subclass of <classname>AnimationTimer</classname>
and provide a definition for the <code>handle()</code> method.  Suppose, for example, that
you simply want to call a <code>draw()</code> method for each frame.  This could be
done as follows, using an anonymous subclass of <classname>AnimationTimer</classname>
(see <localref href="OOP.8.3"/>):</p>

<pre>AnimationTimer animator = new AnimationTimer() {
    public void handle( long time ) {
        draw();
    }
};</pre>

<np>Then, to get the animation started, you would need to call
<code>animator.start()</code>.  This could all be done in an application's
<code>start()</code> method.</np>

<p>The parameter, <code>time</code>, gives the current time, measured as the
number of nanoseconds since some arbitrary time in the past (the same arbitrary
time that is used by <code>System.nanoTime()</code>).  You might use <code>time</code> 
in the calculations that you do for the frame, as a way of making each frame
different from the next.</p>

</subsection>


<subsection title="State Machines" id="GUI1.3.6">

<p>We are ready to look at an a program that uses animation and key events
to implement a simple game.  The program uses an <classname>AnimationTimer</classname>
to drive the animation, and it uses a number of instance variables to keep track
of the current state of the game.  The idea of "state" is an important one.</p>

<p>The information stored in an object's instance variables is said to
represent the <newword>state</newword> of that object. When one of
the object's methods is called, the action taken by the object can depend on
its state. (Or, in the terminology we have been using, the definition of the
method can look at the instance variables to decide what to do.) Furthermore,
the state can change. (That is, the definition of the method can assign new
values to the instance variables.) In computer science, there is the idea of a
<newword>state machine</newword>, which is just something that has a
state and can change state in response to events or inputs. The response of a
state machine to an event depends on what state it's in when the event occurs.
An object is a kind of state machine. Sometimes, this point of view can be very useful in
designing classes.</p>

<p>The state machine point of view can be especially useful in the type of
event-oriented programming that is required by graphical user interfaces. When
designing a GUI program, you can ask yourself: What information about state do I
need to keep track of? What events can change the state of the program? How will
my response to a given event depend on the current state? Should the appearance
of the GUI be changed to reflect a change in state? How should the
the state be taken into account when drawing the content of a canvas? All this is an
alternative to the top-down, step-wise-refinement style of program design,
which does not apply to the overall design of an event-oriented program.</p>

<p>In the <classname>KeyboardEventDemo</classname> program, discussed above, the state of the
program is recorded in instance variables such as <code>squareColor</code>,
<code>squareLeft</code>, and <code>squareTop</code>, which record the color and position 
of the colored square. These state variables are used in
a <code>draw()</code> method that draws the square on a canvas. Their values are
changed in the  key-event-handling methods.</p>

<p>In the rest of this section, we'll look at another example, where the state
plays an even bigger role. In this example, the user plays a
simple arcade-style game by pressing the arrow keys.  The
program is defined in the source code file <sourceref href="SubKiller.java"/>.
As usual, it would be a good idea to compile and run the program as well
as read the full source code.  Here is a picture:</p>

<img src="sub-killer.png" width="398" height="275" alt="the SubKiller window, showing a 'boat' and a 'submarine'"
           tex="sub-killer.eps" texscale="0.5"/>

<p>The entire application window is filled by a canvas.
The program shows a black "submarine" near the bottom of the canvas.
The submarine moves erratically back and forth  near the bottom of the window.   Near the top,
there is a blue "boat." You can move this boat back and forth by pressing the
left and right arrow keys. Attached to the boat is a red "bomb" (or "depth charge"). You
can drop the bomb by hitting the down arrow key. The objective is to
blow up the submarine by hitting it with the bomb. If the bomb
falls off the bottom of the screen, you get a new one. If the submarine explodes, a
new sub is created and you get a new bomb. Try it! Make sure to hit the
sub at least once, so you can see the explosion.</p>

<p>Let's think about how this game can be programmed. First of all, since we
are doing object-oriented programming, I decided to represent the boat, the depth
charge, and the submarine as objects.  Each of these objects is defined by a
separate nested class inside the main application class, and each object has its own
state which is represented by the instance variables in the corresponding class.
I use variables <code>boat</code>, <code>bomb</code>, and <code>sub</code>
to refer to the boat, bomb, and submarine objects.</p>

<p>Now, what constitutes the
"state" of the program? That is, what things change from time to time and affect
the appearance or behavior of the program? Of course, the state includes the
positions of the boat, submarine, and bomb, so those objects have instance
variables to store the positions.  Anything else, possibly less obvious? Well,
sometimes the bomb is falling, and sometimes it's not. That is a
difference in state. Since there are two possibilities, I represent this aspect
of the state with a boolean variable in the <code>bomb</code> object, 
<code>bomb.isFalling</code>. Sometimes the
submarine is moving left and sometimes it is moving right. The difference is
represented by another boolean variable, <code>sub.isMovingLeft</code>. Sometimes,
the sub is exploding. This is also part of the state, and it  is represented
by a boolean variable, <code>sub.isExploding</code>.  However, the explosions
require a little more thought.   An explosion is something that takes place
over a series of frames.  While an explosion is in progress, the sub
looks different in each frame, as the size of the explosion increases. Also,
I need to know when the explosion is over so that I can go back to moving and drawing the
sub as usual. So, I use an integer variable, <code>sub.explosionFrameNumber</code>
to record how many frames have been drawn since the explosion
started; the value of this variable is used only when an explosion is in progress.</p>

<p>How and when do the values of these state variables change?  Some of them seem
to change on their own:  For example, as the sub moves left and right, the state variables
that specify its position change.  Of course, these variables are changing
because of an animation, and that animation is driven by an <classname>AnimationTimer</classname>.  Each time 
the animator's <code>handle()</code> method is called, some of the state variables have to change to
get ready to draw next frame of the animation.  The changes are made
in the <code>handle</code>() method before redrawing the canvas.  The <code>boat</code>,
<code>bomb</code>, and <code>sub</code> objects each contain an
<code>updateForNextFrame()</code> method that updates the state variables of
the object to get ready for the next frame of the animation.  The <code>handle()</code> 
method calls these methods with the statements</p>
   
<pre>boat.updateForNewFrame();
bomb.updateForNewFrame();
sub.updateForNewFrame();</pre>

<np>There are several state variables that change
in these update methods, in addition to the position of the sub:  If the bomb is
falling, then its y-coordinate increases from one frame to the next.  If the
bomb hits the sub, then the <code>isExploding</code> variable of the sub
changes to true, and the <code>isFalling</code> variable of the bomb becomes <code>false</code>.
The <code>isFalling</code> variable also becomes false when the bomb falls off the
bottom of the screen.  If the sub is exploding, then its <code>explosionFrameNumber</code>
increases by one in each frame, and if it has reached a certain value, the
explosion ends and <code>isExploding</code> is reset to false.  At random times,
the sub switches between moving to the left and moving to the right.  Its
direction of motion is recorded in the sub's <code>isMovingLeft</code> variable.
The sub's <code>updateForNewFrame()</code> method includes the following lines to
change the value of <code>isMovingLeft</code> at random times:</np>
   
<pre>if ( Math.random() &lt; 0.02 ) {
    isMovingLeft = ! isMovingLeft;
}</pre>

<np>There is a 1 in 50 chance that <code>Math.random()</code> will be less than
0.02, so the statement "<code>isMovingLeft = !&nbsp;isMovingLeft</code>" is executed
in one out of every fifty frames, on average.  The effect of this statement
is to reverse the value of <code>isMovingLeft</code>, from false to true or from
true to false.  That is, the direction of motion of the sub is reversed.</np>
      
<p>In addition to changes in state that take place from one frame to the next, a few state
variables change when the user presses certain keys. In the program, this is checked
in a handler for <code>KeyPressed</code> events. 
If the user presses the left or right
arrow key, the position of the boat is changed. If the user presses the down
arrow key, the bomb changes from not-falling to falling.  The handler is a long
lambda expression that is registered with the <code>scene</code> in the application's 
<code>start()</code> method:</p>

<pre>scene.setOnKeyPressed( evt -> {
           // The key listener responds to keyPressed events on the canvas.
           // The left- and right-arrow keys move the boat while down-arrow 
           // releases the bomb.
       KeyCode code = evt.getCode();  // Which key was pressed?
       if (code == KeyCode.LEFT) {
           boat.centerX -= 15;
       }
       else if (code == KeyCode.RIGHT) {  
           boat.centerX += 15;
       }
       else if (code == KeyCode.DOWN) {
           if ( bomb.isFalling == false )
               bomb.isFalling = true;
       }
   } );</pre>

<np>Note that it's not necessary to redraw the canvas in this method,
since this canvas shows an animation that is constantly being redrawn
anyway. Any changes in the state will become visible to the user as soon as the
next frame is drawn. At some point in the program, I have to make sure that the
user does not move the boat off the screen. I could have done this in the key
event handler, but I chose to check for this in another routine, in
the boat object.</np>

<p>I encourage you to read the source code in <sourceref href="SubKiller.java"/>.
Although a few points are tricky, you should  with some effort be able to read and
understand the entire program.  Try to understand the program in terms of state
machines.  Note how the state of each of the three objects in the program changes
in response to events from the timer and from the user.</p>
   
<p>While it's not at all sophisticated as arcade games go, the
SubKiller game does use some interesting programming. And it
nicely illustrates how to apply state-machine thinking in event-oriented
programming.</p>
   
</subsection>

<subsection title="Observable Values" id="GUI1.3.7">

<p>There is one more kind of basic event that plays an important role
in JavaFX:  events that are generated when an <newword>observable value</newword>
is modified.  There is an example in the <code>SubKiller</code> program.
A <classname>Stage</classname>, <code>stage</code>, has a property of type
<classname>ObservableBooleanValue</classname> that tells whether or not <code>stage</code>
is currently the focused window.  You can access the property by calling
<code>stage.focusedProperty()</code>.  When the value of an <classname>ObservableBooleanProperty</classname>
changes, an event is generated.  You can register a <classname>ChangeListener</classname> with the property, 
containing an event handler method that will be called when the event occurs. 
The handler method in this case has three parameters:  the observable property that
generated the event, the previous value of the property, and the new value.
For an <classname>ObservableBooleanValue</classname>, the old and new values are
of type <ptype>boolean</ptype>.  There are other observable value types, such
as <classname>ObservableIntegerValue</classname>, <classname>ObservableStringValue</classname>,
and <classname>ObservableObjectValue</classname>.</p>

<p>When I first wrote <code>SubKiller</code>, the animation would continue to run 
even when the <code>SubKiller</code> window was not the focused window, which I found
annoying when I was trying to work in another window.  I decided to pause the animation
when the window loses the input focus and to restart it when the window regains focus.
When the window loses or gains focus, the value of the observable boolean property
<code>stage.focusedProperty()</code> changes.  To react to that change, I added a change listener
to the property, which stops the animation when the value of the property changes to <code>false</code>
and starts the animation when the value changes to <code>true</code>.  So, I added this
code to the <code>start()</code> method:</p>

<pre>stage.focusedProperty().addListener( (obj,oldVal,newVal) -&gt; {
            // This listener turns the animation off when this program's
            // window does not have the input focus.
        if (newVal) { // The window has gained focus.
            timer.start();
        }
        else {  // The window has lost focus.
            timer.stop();
        }
        draw(); // Redraw canvas. (Appearance changes depending on focus.)
    });</pre>
    
<np>The <code>addListener()</code> method of an observable property registers a
change listener with the property.
Note that the lambda expression for the event handler takes three parameters.
The only one that I need here is <code>newVal</code> which represents the current
value of the stage's <code>focused</code> property.</np>

<p>JavaFX GUI components have many observable properties, of various types.  For example,
the text on a <classname>Button</classname> is  a property of type
<classname>ObservableStringProperty</classname>, and the width and the height of a canvas 
are values of type <classname>ObservableDoubleProperty</classname>.  We will encounter
more examples in the next <localref href="GUI1.4">section</localref>.</p>

</subsection>

</section>
