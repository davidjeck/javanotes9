<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE exercises SYSTEM "../javanotes8.dtd" >

<exercises>

   
   
<exercise id="GUI1.ex.1">
<exercise-question><p>In <localref href="GUI1.3.2"/>, the following code was
given as an example.  It installs a <code>MousePressed</code> event handler
on a canvas.  The handler lets the user draw a red rectangle at the point
where the user clicks the mouse, or, by holding the shift key down,
a blue oval:</p>
<pre>canvas.setOnMousePressed( evt -&gt; {
    GraphicsContext g = canvas.getGraphicsContext2D();
    if ( evt.isShiftDown() ) {
        g.setFill( Color.BLUE );
        fillRect( evt.getX() - 30, evt.getY() - 15, 60, 30 )
    }
    else {
        g.setFill( Color.BLUE );
        fillOval( evt.getX() - 30, evt.getY() - 15, 60, 30 );
    }
} );</pre>
<np>Write a complete program that does the same, but in addition, the program
will continue to draw figures if the user drags the mouse.  
That is, the mouse will leave a trail of figures as the user
drags.  However, if the user right-clicks the canvas, then the canvas should simply be
cleared and no figures should be drawn even if the user drags the mouse after
right-clicking. See the discussion of dragging in <localref href="GUI1.3.3"/>.
Here is a picture of my solution:</np>
<img src="simple-stamper-with-drag.png" width="400" height="305" alt="the program showing trails of ovals and rects"
      tex="simple-stamper-with-drag.eps" texscale="0.5"/>
<np>Note that a black border has been added around each shape to make them more distinct.</np>
<p>To make the problem a little more challenging, when drawing shapes
during a drag operation, make sure that the shapes that are drawn are at least, say,
5 pixels apart.  To implement this, you have to keep track of the position of the
last shape that was drawn.</p>
</exercise-question>
<exercise-discuss><p>In order to implement dragging, we need to add a handler
for <code>MouseDragged</code> events, in addition to the handler for <code>MousePressed</code> events.
Since the code for handling the events is rather long, I wrote separate methods to handle
the events, and the event handlers that I register with the canvas simply call
those methods:</p>

<pre>canvas.setOnMousePressed( e -> mousePressed(e) );
canvas.setOnMouseDragged( e -> mouseDragged(e) );</pre>

<np>I also decided to use a global variable, <code>canvasGraphics</code>,
of type <classname>GraphicsContext</classname> to represent the graphics
context for drawing on the canvas.  I get the graphics context in the
<code>start()</code> method when I create the canvas, 
and I fill the canvas with white:</np>

<pre>Canvas canvas = new Canvas(500,380);
canvasGraphics = canvas.getGraphicsContext2D();
canvasGraphics.setFill(Color.WHITE);
canvasGraphics.fillRect(0,0,500,380);
canvasGraphics.setStroke(Color.BLACK); // stroke color never changes</pre>

<p>I wanted to have a black border around the canvas (more for the screenshot
than for anything else).  I could have drawn the border on the canvas itself,
but I decided to apply the border to the pane that is used as the root of
the scene graph.  This led me to use a <classname>BorderPane</classname>
for the root rather than a simple <classname>Pane</classname>.  When a <classname>BorderPane</classname>
computes its preferred size, it allows space for any border or padding that have been applied
to the pane, and the content is correctly placed inside the border and padding.  A
<classname>Pane</classname> would not take care of that for me.  (When I first 
wrote the program, using a <classname>Pane</classname>, the canvas covered part of
the border.)  So, the root pane is created with</p>

<pre>BorderPane root = new BorderPane(canvas);
root.setStyle("-fx-border-color: black; -fx-border-width: 2px");</pre>

<p>The <code>mousePressed()</code> method can use the code given in the
exercise, except that the graphics context is named <code>canvasGraphics</code>
instead of <code>g</code>, and code should be added to stroke the shapes with black
after filling them.
However, before drawing anything, the method must check
whether the user right-clicked the canvas; if so, the canvas should be
cleared and nothing should be drawn.  The test that is needed is
if <code>evt.getButton() == MouseButton.SECONDARY</code>.
</p>

<p>Furthermore, we need to add some global variables to the program to
keep track of what is happening as the user drags the mouse.
First of all, <code>mouseDragged()</code> does not always
draw shapes; if the user used the right mouse button, no shapes are
drawn.  We can implement that with the typical <ptype>boolean</ptype> instance
variable, <code>dragging</code>.  This variable is set to <code>false</code>
in <code>mousePressed()</code> if the user right-clicked, and it is set
to <code>true</code> otherwise.  If <code>dragging</code> is false
in <code>mouseDragged()</code>, then that method returns without
drawing anything.</p>

<p>In addition, even when <code>dragging</code> is <code>true</code>,
<code>mouseDragged()</code> should not draw anything unless the mouse
has moved at least 5 pixels since the previous shape was drawn.
We need two more global variables, of type <ptype>double</ptype>,
to keep track of the mouse position where a shape was most recently
drawn.  In my program, the variables are <code>prevShapeX</code> and <code>prevShapeY</code>.
The variables' values should be set every time a shape is drawn,
in either <code>mousePressed()</code> or <code>mouseDragged()</code>,
and <code>mouseDragged()</code> should compare their values to the
current mouse location to decide whether the mouse has moved far
enough to draw the next shape.  It is not completely clear what  "move at least 5 pixels" 
means, but I take it to
mean "move at least 5 pixels vertically or at least 5 pixels horizontally".
So, <code>mouseDragged()</code> starts off like this:</p>

<pre>public void mouseDragged(MouseEvent evt) {
    if ( dragging == false ) { 
        return;
    }
    
    double x = evt.getX();  // x-coordinate where user clicked.
    double y = evt.getY();  // y-coordinate where user clicked.
    
    if ( Math.abs(x - prevShapeX) &lt; 5 &amp;&amp; Math.abs(y - prevShapeY) &lt; 5 ) {
            // The mouse has not moved at least 5 pixels horizontally
            // or vertically, so don't draw another shape yet.
        return;
    }
    
    prevShapeX = x;  // Save coords where the next shape is being drawn.
    prevShapeY = y;</pre>

</exercise-discuss>
<exercise-code><pre>
<prog name="SimpleStamperWithDrag">import java.awt.*;

import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.layout.BorderPane;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;


/**
 * A simple demonstration of MouseEvents.  Shapes are drawn
 * on a white background when the user clicks the canvas.  If
 * the user right-clicks, the canvas is cleared.  If the user
 * shift-clicks the canvas, a blue oval is drawn.  Otherwise,
 * when the user clicks, a red rectangle is drawn.  If the user
 * did not right-click, then ovals or rects continue to be 
 * drawn as the user drags the mouse.
 */
public class SimpleStamperWithDrag extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    // ----------------------------------------------------------------------

    /**
     * This variable is set to true during a drag operation, unless the
     * user was holding down the shift key when the mouse was first
     * pressed (since in that case, the mouse gesture simply clears the
     * canvas and no figures should be drawn if the user drags the mouse).
     */
    private boolean dragging;
    
    /**
     * While dragging, prevShapeX and prevShapeY are the the coordinates
     * at which the previous shape was drawn.  They are used to avoid 
     * drawing the next shape until the mouse has moved at least 5 pixels
     * horizontally or vertically.
     */
    private double prevShapeX, prevShapeY;
    
    /**
     * A graphics context for drawing on the canvas that fills the screen.
     */
    private GraphicsContext canvasGraphics;

    
    /**
     * This start() method sets up the GUI to show a canvas where the shapes
     * are drawn, and it installs mouse handlers on the canvas to draw shapes
     * as the user presses and drags the mouse.
     */
    public void start(Stage stage) {
        
        Canvas canvas = new Canvas(500,380);
        canvasGraphics = canvas.getGraphicsContext2D();
        canvasGraphics.setFill(Color.WHITE);
        canvasGraphics.fillRect(0,0,500,380);
        canvasGraphics.setStroke(Color.BLACK); // stroke color never changes
        
        canvas.setOnMousePressed( e -> mousePressed(e) );
        canvas.setOnMouseDragged( e -> mouseDragged(e) );
        
        BorderPane root = new BorderPane(canvas);
        root.setStyle("-fx-border-color: black; -fx-border-width: 2px");
        
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Mouse Drag Demo");
        stage.setResizable(false);
        stage.show();
        
    } // end start()


    /**
     *  This method will be called when the user clicks the mouse on the canvas.
     *  If the user right-clicked, it clears the canvas.  Otherwise, it draws
     *  a shape and starts a drag operation, but only if the mouse has moved
     *  sufficiently far since drawing the previous shape.
     */
    public void mousePressed(MouseEvent evt) {

        if ( evt.getButton() == MouseButton.SECONDARY ) {
                // The user right-clicked the canvas.  Fill the canvas with white
                // to erase its current contents.
            dragging = false;
            canvasGraphics.setFill(Color.WHITE);
            canvasGraphics.fillRect(0,0,500,380);
            return;
        }

        dragging = true;

        double x = evt.getX();  // x-coordinate where user clicked.
        double y = evt.getY();  // y-coordinate where user clicked.
        
        prevShapeX = x;  // Save coordinates where first shape is drawn.
        prevShapeY = y;

        if ( evt.isShiftDown() ) {
                // User was holding down the shift key. Draw a blue oval centered 
                // at the point (x,y). (A black outline around the oval will make it 
                // more distinct when shapes overlap.)
            canvasGraphics.setFill(Color.BLUE);  // Blue interior.
            canvasGraphics.fillOval( x - 30, y - 15, 60, 30 );
            canvasGraphics.strokeOval( x - 30, y - 15, 60, 30 );
        }
        else {
                // Draw a red rectangle centered at (x,y).
            canvasGraphics.setFill(Color.RED);   // Red interior.
            canvasGraphics.fillRect( x - 30, y - 15, 60, 30 );
            canvasGraphics.strokeRect( x - 30, y - 15, 60, 30 );
        }

    } // end mousePressed();


    /**
     *  This method is called when the user drags the mouse.  If a the value of the
     *  instance variable dragging is true, it will draw a rect or oval at the
     *  current mouse position.
     */
    public void mouseDragged(MouseEvent evt) {
        if ( dragging == false ) { 
            return;
        }
        
        double x = evt.getX();  // x-coordinate where user clicked.
        double y = evt.getY();  // y-coordinate where user clicked.
        
        if ( Math.abs(x - prevShapeX) &lt; 5 &amp;&amp; Math.abs(y - prevShapeY) &lt; 5 ) {
                // The mouse has not moved at least 5 pixels horizontally
                // or vertically, so don't draw another shape yet.
            return;
        }
        
        prevShapeX = x;  // Save coords where the next shape is being drawn.
        prevShapeY = y;

        if (evt.isShiftDown() ) {
                // User was holding down the shift key. Draw a blue oval centered 
                // at the point (x,y). (A black outline around the oval will make it 
                // more distinct when shapes overlap.)
            canvasGraphics.setFill(Color.BLUE);  // Blue interior.
            canvasGraphics.fillOval( x - 30, y - 15, 60, 30 );
            canvasGraphics.strokeOval( x - 30, y - 15, 60, 30 );
        }
        else {
                // Draw a red rectangle centered at (x,y).
            canvasGraphics.setFill(Color.RED);   // Red interior.
            canvasGraphics.fillRect( x - 30, y - 15, 60, 30 );
            canvasGraphics.strokeRect( x - 30, y - 15, 60, 30 );
        }
        
    } // end mouseDragged();


} // end class SimpleStamperWithDrag
</prog>
</pre>
</exercise-code>
</exercise>
   
   

<exercise id="GUI1.ex.2">
<exercise-question><p>Write a program that shows a small red square and a small blue
square. The user should be able to drag either square with the mouse.
(You'll need an instance variable to remember which square the user is
dragging.) The user can drag the square out of the window if she wants, and it will
disappear.  To allow the user to get the squares back into the window,
add a <code>KeyPressed</code> event handler that will restore the
squares to their original positions when the user presses the Escape key.
The key code for the Escape key is <code>KeyCode.ESCAPE</code>.</p>
</exercise-question>
<exercise-discuss><p>Since the squares can move, the program needs global
variables to keep track of the current location of each square.  I do that
with instance variables <code>x1</code> and
<code>y1</code> for the upper left corner of the red square and <code>x2</code> and
<code>y2</code> for the upper left corner of the blue square.  These variables
are of type <ptype>double</ptype> since mouse positions are given as real
numbers in JavaFX.  The canvas is also a global variable.
I wrote a method, <code>draw()</code>,
to completely redraw the content of the canvas.  It is called in the <code>start()</code> method
and whenever one of the squares is moved.  The <code>draw()</code> method can get
the graphics context that it needs to do its drawing from the canvas:</p>

<pre>private void draw() {
    GraphicsContext g = canvas.getGraphicsContext2D();
    g.setFill(Color.rgb(230,255,230)); // light green
    g.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
    g.setFill(Color.RED);
    g.fillRect(x1, y1, 30, 30);
    g.setFill(Color.BLUE);
    g.fillRect(x2, y2, 30, 30);
}</pre>

<p>To implement dragging, the program needs event handlers for
<code>MousePressed</code>, <code>MouseDragged</code>, and (maybe) <code>MouseReleased</code>
events.  The handlers need to be added to the canvas that fills the window.
My event handlers simply call methods such as <code>mousePressed(evt)</code> that
are defined elsewhere in the program.</p>
<p>For this simple application of dragging, the program doesn't need to keep
track of the previous or starting positions of the mouse.
But as usual for dragging, I use a boolean variable,
<code>dragging</code>, to keep track of whether or not a drag operation is in
progress. Not every mouse press starts a drag operation. If the user clicks the
canvas outside of the squares, there is nothing to drag, and so <code>dragging</code>
is set to false in the <code>mousePressed</code> method.  If the user clicks one 
of the squares, <code>dragging</code> is set to true. Since there are two
squares to be dragged, we have to keep track of which is being dragged. I use a
boolean variable, <code>dragRedSquare</code>, which is true if the red square is
being dragged and is false if the blue square is being dragged. (A boolean
variable is actually not the best choice in this case. It would be a problem if
we wanted to add another square. A boolean variable only has two possible
values, so an integer variable would probably be a better choice.  Better yet,
the rectangles could be represented by objects, and a the global variable would
refer to the object that is being dragged, or would be <code>null</code> when
no object is being dragged.) </p>

<p>There is one little problem. The mouse location is a single <code>(x,y)</code>
point. A square occupies a whole bunch of points. When we move the square to
follow the mouse, where exactly should we put the square? One possibility is to
put the upper left corner of the square at the mouse location. If we did this,
the <code>mouseDragged</code> routine would look like:</p>

<pre>public void mouseDragged(MouseEvent evt) { 
    if (dragging == false)  
      return;
    double x = evt.getX();  // Get mouse position.
    double y = evt.getY();
    if (dragRedSquare) {  // Move the red square.
       x1 = x;  // Put top-left corner at mouse position.
       y1 = y;
    }
    else {   // Move the blue square.
       x2 = x;  // Put top-left corner at mouse position.
       y2 = y;
    }
    draw();  // redraw canvas with square in new location
}</pre>

<np>This works, but it is not very aesthetic. When the user starts dragging a
square, no matter where in the square the user clicks, the square will jump so
that its top-left corner is at the mouse position. This is not what a user
typically expects. If I grab a square by clicking its center, then I want the
center to stay under the mouse cursor as I move it. If I grab the lower right
corner, I want the lower right corner to follow the mouse, not the upper left
corner. There is a solution to this, and it's one that is often needed for
dragging operations. We need to record the original position of the mouse
relative to the upper left corner of the square. This tells us where in the
square the user clicked. This is done in the <code>mousePressed()</code> method by
assigning appropriate values to two new instance variables <code>offsetX</code> and
<code>offsetY</code>:</np>

<pre>double x = evt.getX();  // Location where user clicked.
double y = evt.getY();

if (x &gt;= x2 &amp;&amp; x &lt; x2+30 &amp;&amp; y &gt;= y2 &amp;&amp; y &lt; y2+30) {
      // It's the blue square (which should be checked first,
      // since it's drawn on top of the red square.)
   dragging = true;
   dragRedSquare = false;
   offsetX = x - x2;  // Distance from corner of square to (x,y).
   offsetY = y - y2;
}
else if (x &gt;= x1 &amp;&amp; x &lt; x1+30 &amp;&amp; y &gt;= y1 &amp;&amp; y &lt; y1+30) {
      // It's the red square.
   dragging = true;
   dragRedSquare = true;
   offsetX = x - x1;  // Distance from corner of square to (x,y).
   offsetY = y - y1;
}</pre>

<np>In <code>mouseDragged()</code>, when the mouse moves to a new <code>(x,y)</code>
point, we move the square so that the vertical and horizontal distances between
the mouse location and the top left corner of the square remain the same,
as given by <code>offsetX</code> and <code>offsetY</code>:</np>

<pre>if (dragRedSquare) {  // Move the red square.
   x1 = x - offsetX;  // Offset corner from mouse location.
   y1 = y - offsetY;
}
else {   // Move the blue square.
   x2 = x - offsetX;  // Offset corner from mouse location.
   y2 = y - offsetY;
}</pre>

<p>By the way, if you wanted to stop the user from dragging the square outside
the window, you would just have to add code to the <code>mouseDragged</code>
routine to "clamp" the variables <code>x1</code>, <code>y1</code>, <code>x2</code>, and
<code>y2</code> so that they lie in the acceptable range. Here is a modified
routine that keeps the square entirely within the canvas:</p>

<pre>public void mouseDragged(MouseEvent evt) { 
    if (dragging == false)  
      return;
    double x = evt.getX();
    double y = evt.getY();
    if (dragRedSquare) {  // Move the red square.
       x1 = x - offsetX;
       y1 = y - offsetY;
       if (x1 &lt; 0)  // Clamp (x1,y1) so the square lies in the canvas.
          x1 = 0;
       else if (x1 &gt;= canvas.getWidth() - 30)
          x1 = canvas.getWidth() - 30;
       if (y1 &lt; 0)
          y1 = 0;
       else if (y1 &gt;= canvas.getHeight() - 30)
          y1 = canvas.getHeight() - 30;
    }
    else {   // Move the blue square.
       x2 = x - offsetX;
       y2 = y - offsetY;
       if (x2 &lt; 0)  // Clamp (x2,y2) so the square lies in the canvas.
          x2 = 0;
       else if (x2 &gt;= canvas.getWidth() - 30)
          x2 = canvas.getWidth() - 30;
       if (y2 &lt; 0)
          y2 = 0;
       else if (y2 &gt;= canvas.getHeight() - 30)
          y2 = canvas.getHeight() - 30;
    }
    draw();
}</pre>
<p>Finally, we need to program a response to the Escape key.
As discussed in <localref href="GUI1.3.4"/>, we can register the
<code>KeyPressed</code> event handler with the scene.  The handler
simply has to reset the variables <code>x1</code>, <code>y1</code>,
<code>x2</code>, and <code>y2</code> to their original values
and redraw the canvas.  I define the handler in the <code>start()</code>
method after creating the <code>scene</code>:</p>

<pre>Scene scene = new Scene(root);
scene.setOnKeyPressed( e -> {
       // If user pressed ESCAPE, move squares
       // back to starting positions, and redraw.
    if ( e.getCode() == KeyCode.ESCAPE ) {
        x1 = 10;
        y1 = 10;
        x2 = 50;
        y2 = 10;
        draw();
    }
});</pre>

</exercise-discuss>
<exercise-code><pre>
<prog name="DragTwoSquares">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseEvent;

/**
 * A program that shows a red square and a blue square that the user
 * can drag with the mouse.   The user can drag the squares off
 * the canvas and drop them.  Pressing the escape key will restore
 * both squares to their original positions.
 */
public class DragTwoSquares extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------


    private double x1 = 10, y1 = 10;   // Coords of top-left corner of the red square.
    private double x2 = 50, y2 = 10;   // Coords of top-left corner of the blue square.

    private Canvas canvas;  // The canvas where the sqaures are drawn.


    /**
     *  The start method sets up the GUI.  It adds mouse event handlers to
     *  the canvas to implement dragging.  It adds a key pressed handler
     *  to the scene that will restore the squares to their original 
     *  positions when the user presses the escape key.
     */
    public void start(Stage stage) {

        canvas = new Canvas(300,250);
        draw(); // show squares in original positions
        
        canvas.setOnMousePressed( e -> mousePressed(e) );
        canvas.setOnMouseDragged( e -> mouseDragged(e) );
        canvas.setOnMouseReleased( e -> mouseReleased(e) );
        
        Pane root = new Pane(canvas);
        
        Scene scene = new Scene(root);
        
        scene.setOnKeyPressed( e -> {
               // If user pressed ESCAPE, move squares
               // back to starting positions, and redraw.
            if ( e.getCode() == KeyCode.ESCAPE ) {
                x1 = 10;
                y1 = 10;
                x2 = 50;
                y2 = 10;
                draw();
            }
        });
        
        stage.setScene(scene);
        stage.setTitle("Drag the squares!");
        stage.setResizable(false);
        stage.show();
    } 


    /**
     * Draw the canvas, showing the squares in their current positions.
     */
    private void draw() {
        GraphicsContext g = canvas.getGraphicsContext2D();
        g.setFill(Color.rgb(230,255,230)); // light green
        g.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
        g.setFill(Color.RED);
        g.fillRect(x1, y1, 30, 30);
        g.setFill(Color.BLUE);
        g.fillRect(x2, y2, 30, 30);
    }

    
    //-----------------  Variables and methods for responding to drags -----------

    private boolean dragging;      // Set to true when a drag is in progress.

    private boolean dragRedSquare; // True if red square is being dragged, false
                                   //    if blue square is being dragged.

    private double offsetX, offsetY;  // Offset of mouse-click coordinates from the
                                      //   top-left corner of the square that was
                                      //   clicked.

    /**
     * Respond when the user presses the mouse on the canvas.
     * Check which square the user clicked, if any, and start
     * dragging that square.
     */
    public void mousePressed(MouseEvent evt) { 

        if (dragging)  // Exit if a drag is already in progress.
            return;

        double x = evt.getX();  // Location where user clicked.
        double y = evt.getY();

        if (x >= x2 &amp;&amp; x &lt; x2+30 &amp;&amp; y >= y2 &amp;&amp; y &lt; y2+30) {
                // It's the blue square (which should be checked first,
                // since it's drawn on top of the red square.)
            dragging = true;
            dragRedSquare = false;
            offsetX = x - x2;  // Distance from corner of square to (x,y).
            offsetY = y - y2;
        }
        else if (x >= x1 &amp;&amp; x &lt; x1+30 &amp;&amp; y >= y1 &amp;&amp; y &lt; y1+30) {
                // It's the red square.
            dragging = true;
            dragRedSquare = true;
            offsetX = x - x1;  // Distance from corner of square to (x,y).
            offsetY = y - y1;
        }

    }

    /**
     * Dragging stops when user releases the mouse button.
     */
    public void mouseReleased(MouseEvent evt) { 
        dragging = false;
    }

    /**
     * Respond when the user drags the mouse.  If a square is 
     * not being dragged, then exit. Otherwise, change the position
     * of the square that is being dragged to match the position
     * of the mouse.  Note that the corner of the square is placed
     * in the same relative position with respect to the mouse that it
     * had when the user started dragging it.
     */
    public void mouseDragged(MouseEvent evt) { 
        if (dragging == false)  
            return;
        double x = evt.getX();
        double y = evt.getY();
        if (dragRedSquare) {  // Move the red square.
            x1 = x - offsetX;
            y1 = y - offsetY;
        }
        else {   // Move the blue square.
            x2 = x - offsetX;
            y2 = y - offsetY;
        }
        draw();  // (Calls the draw() to show squares in new positions.)
    }

} // end class DragTwoSquares
</prog>
</pre>
</exercise-code>
</exercise>
   
   

<exercise id="GUI1.ex.3">
<exercise-question><p>Write a program that shows a pair of dice.  The
dice are drawn on a <classname>Canvas</classname>. 
You can assume that the size of the canvas is 100 by 100 pixels.
When the user clicks on the canvas, the dice should be rolled
(that is, the dice should be assigned newly computed random values). Each die
should be drawn as a square showing from 1 to 6 dots. Since you have to draw
two dice, its a good idea to write a subroutine, such as "<code>void drawDie(GraphicsContext g,
int val, int x, int y)</code>", to draw a die at the specified <code>(x,y)</code>
coordinates. The second parameter, <code>val</code>, specifies the the number of dots that are
showing on the die. 
Here is a picture of a canvas displaying two the dice:</p>
<img src="roll-dice-gui.png" width="100" height="100" alt="a pair of dice" tex="roll-dice-gui.eps" texscale="0.75"/>
</exercise-question>
<exercise-discuss><p>This is largely an exercise in precision drawing.</p>
   
<p>We will need a <classname>Canvas</classname> for drawing the dice.  In my program,
it is a global variable.  We need to add a <code>MousePressed</code> event handler to
the canvas.  My handler calls a method, <code>roll()</code>, that will assign new
values to the dice and redraw the canvas.  The code is in the <code>start()</code> method:</p>

<pre>canvas = new Canvas(100,100);  // Canvas is 100-by-100 pixels.
draw();  // Draw the original dice.
canvas.setOnMousePressed( e -> roll() );  // Add the event handler.</pre>
   
<np>The <code>draw()</code> method completely redraws the canvas.
The hardest part of this exercise was drawing the dice. I made each die 35
pixels wide, leaving a 10 pixel border on each side and 10 pixels between the
dice, for a total of 100 pixels.
The top left corner of the left die is at <code>(10,10)</code>, the top left
corner of the right die is at <code>(55,55)</code>. The 55 includes the 10 pixel
border on the left, the 35 pixel width of the other die, and the 10 pixels
between the dice. The <code>paintComponent()</code>
method calls a <code>drawDie()</code> routine to draw
each die, using the commands:</np>

<pre>drawDie(g, die1, 10, 10);
drawDie(g, die2, 55, 55);</pre>

<np>where <code>die1</code> is the numerical value shown on the first die and
<code>die2</code> is the numerical value of the second die.</np>

<p>As for the <code>drawDie</code> routine, there are two quite different
algorithms that could have been used for drawing the dots. Either:</p>

<pre>if the value shown is 1
    draw 1 dot (in the center)
else if the value shown is 2
    draw 2 dots (in the top-left and bottom-right corners)
  .
  .
  .
else if the value shown is 6
    draw 6 dots (along the left and right edges)</pre>

<np>Or:</np>

<pre>if the value has a dot in the top-left corner
     draw the top-left dot
else if the value has a dot in the top-right corner
     draw the top-right dot
   .
   .
   .
else if the value has a dot in the bottom-right corner
     draw the bottom-right dot</pre>

<np>Although the first algorithm is more obvious, the second requires much less
typing. (The first algorithm ends up using 21 <code>drawOval()</code> commands,
while the second uses only 7.) Furthermore, after drawing the dice on paper, I
found that the conditions for testing when a given dot needs to be drawn are
simpler than I expected. For example, the values that need a dot in the
top-left position are all the values greater than 1. The algorithm leads to my
<code>drawDie()</code> routine:</np>

<pre>/**
 * Draw a die with upper left corner at (x,y).  The die is
 * 35 by 35 pixels in size.  The val parameter gives the
 * value showing on the die (that is, the number of dots).
 */
private void drawDie(Graphics g, int val, int x, int y) {
    g.setFill(Color.WHITE);
    g.fillRect(x, y, 35, 35);
    g.setStroke(Color.BLACK);
    g.strokeRect(x+0.5, y+0.5, 34, 34);
    g.setFill(Color.BLACK);
    if (val &gt; 1)  // upper left dot
       g.fillOval(x+3, y+3, 9, 9);
    if (val &gt; 3)  // upper right dot
       g.fillOval(x+23, y+3, 9, 9);
    if (val == 6) // middle left dot
       g.fillOval(x+3, y+13, 9, 9);
    if (val % 2 == 1) // middle dot (for odd-numbered val's)
       g.fillOval(x+13, y+13, 9, 9);
    if (val == 6) // middle right dot
       g.fillOval(x+23, y+13, 9, 9);
    if (val &gt; 3)  // bottom left dot
       g.fillOval(x+3, y+23, 9, 9);
    if (val &gt; 1)  // bottom right dot
       g.fillOval(x+23, y+23, 9,9);
}</pre>

<p>It took some care to figure out the numbers to use in the <code>fillOval</code>
commands. The individual dots have a diameter of 9 pixels. There are three rows
of dots, which have a combined height of 27 pixels. That leaves 35 minus 27, or 8
pixels for spacing. I use 3 pixels between the dots and the edge of the die,
and 1 pixel between rows. This puts the tops of the rows at 3, 3+9+1, and
3+9+1+9+1, that is, at 3, 13, and 23. The columns use the same numbers. (If you
believe that I got all this right the first time, I won't disillusion you!)</p>

<p>The <code>draw()</code> method fills the canvs with light blue, draws a 2-pixel blue border
around the canvas, and draws the two dice:</p>

<pre>public void draw()) {
    GraphicsContext g = canvas.getGraphicsContext2D();
    g.setFill(Color.rgb(200,200,255));
    g.fillRect(0,0,100,100); // fill canvas with light blue
    g.setLineWidth(2);
    g.strokeRect(1,1,98,98); // draw a blue border
    drawDie(g, die1, 10, 10);  // draw the dice
    drawDie(g, die2, 55, 55);
}</pre>

<np>Note the different parameters to <code>g.fillRect()</code>
and <code>g.strokeRect()</code>.  To cover the entire canvas,
we need to fill a 100-by-100 rectangle, with its top-left
corner at (0,0), so the command is <code>g.fillRect(0,0,100,100)</code>.
But when a rectangle is stroked, the <b>center</b>
of the pen is dragged along the boundary of the rectangle.  For
a 2-pixel border, we need to stroke a rectangle that is inset
from the boundary of the canvas by half the size of the pen, that
is, by one pixel. Since the rectangle is inset by 1 pixel on each
side, it is 2 pixels smaller than the full 100-pixel canvas,
hence its width and height are 98.  If I had said
<code>g.strokeRect(0,0,100,100), half of the pen would lie outside
the canvas, and we would only see a 1-pixel border.</code>
</np>
</exercise-discuss>
<exercise-code>
<pre><prog name="RollDice">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;

/**
 * Shows a pair of dice that are rolled when the user clicks on the
 * canvas where the dice are drawn.
 */
public class RollDice extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------

    private int die1 = 4;  // The values shown on the dice.
    private int die2 = 3;

    private Canvas canvas;  // The canvas on which the dice are drawn.
    

    /**
     *  The start() method sets up the GUI and installs a mouse listener
     *  on the canvas where the dice are to be drawn.
     */
    public void start(Stage stage) {
        
        canvas = new Canvas(100,100);
        draw();  // Draw the original dice.
        
        canvas.setOnMousePressed( e -> roll() );
        
        Pane root = new Pane(canvas);
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Dice!");
        stage.setResizable(false);
        stage.show();
        
    }
    

    /**
     * Draw a die with upper left corner at (x,y).  The die is
     * 35 by 35 pixels in size.  The val parameter gives the
     * value showing on the die (that is, the number of dots).
     */
    private void drawDie(GraphicsContext g, int val, int x, int y) {
        g.setFill(Color.WHITE);
        g.fillRect(x, y, 35, 35);
        g.setStroke(Color.BLACK);
        g.strokeRect(x+0.5, y+0.5, 34, 34);
        g.setFill(Color.BLACK);
        if (val > 1)  // upper left dot
            g.fillOval(x+3, y+3, 9, 9);
        if (val > 3)  // upper right dot
            g.fillOval(x+23, y+3, 9, 9);
        if (val == 6) // middle left dot
            g.fillOval(x+3, y+13, 9, 9);
        if (val % 2 == 1) // middle dot (for odd-numbered val's)
            g.fillOval(x+13, y+13, 9, 9);
        if (val == 6) // middle right dot
            g.fillOval(x+23, y+13, 9, 9);
        if (val > 3)  // bottom left dot
            g.fillOval(x+3, y+23, 9, 9);
        if (val > 1)  // bottom right dot
            g.fillOval(x+23, y+23, 9,9);
    }


    /**
     * Roll the dice by randomizing their values.  Tell the
     * system to repaint the canvas, to show the new values.
     */
    private void roll() {
        die1 = (int)(Math.random()*6) + 1;
        die2 = (int)(Math.random()*6) + 1;
        draw();
    }


    /**
     * The draw() method just draws the two dice and draws
     * a two-pixel wide blue border around the canvas.
     */
    private void draw() {
        GraphicsContext g = canvas.getGraphicsContext2D();
        g.setFill(Color.rgb(200,200,255));
        g.fillRect(0,0,100,100);
        g.setStroke( Color.BLUE );
        g.setLineWidth(2);
        g.strokeRect(1,1,98,98);
        drawDie(g, die1, 10, 10);
        drawDie(g, die2, 55, 55);
    }

} // end class RollDice
</prog></pre>
</exercise-code>
</exercise>
   
   

<exercise id="GUI1.ex.4">
<exercise-question><p>In <localref href="GUI1.ex.3"/>,
you wrote a graphical pair-of-dice program where the dice are rolled when the user clicks on
the canvas. Now make a pair-of-dice program where the user rolls the
dice by clicking a button.  The button should appear under the
canvas that shows the dice.  Also make the following change:  When the
dice are rolled, instead of just showing the new value, show a short animation
during which the values on the dice are changed in every frame.  The animation
is supposed to make the dice look more like they are actually rolling.</p>
</exercise-question>
<exercise-discuss><p>In <localref href="GUI1.ex.3"/>, the entire window
was filled by a <classname>Canvas</classname>. In the new version, we need
both a canvas and a button.  We need to add both components to the container
that acts as the root of the scene graph.  I decided to use a <code>BorderPane</code>
with the canvas in the center position and the button in the bottom position.
(Another option would have been a <classname>VBox</classname>.)
When I first tried this, the button only filled the left half of the
bottom position.  A <code>BorderPane</code> wants to expand the components that
it contains to completely fill their positions in the layout,
but as mentioned in <localref href="GUI1.5"/>, the problem is that
a <classname>Button</classname> has a maximum size that is just large enough
to hold the contents of the button.  The problem can be fixed by giving
the button a bigger maximum width.  After I did that, the button filled the
entire width of the window.  Here is the new <code>start()</code> method:</p>

<pre>public void start(Stage stage) {
   
    canvas = new Canvas(100,100);
    draw();  // Draw the original dice.
    
    rollButton = new Button("Roll!");
    rollButton.setMaxWidth(1000);  // so button can grow to full width of window
    rollButton.setOnAction( e -> roll() ); // When clicked, roll the dice.
    
    BorderPane root = new BorderPane();
    root.setCenter(canvas);
    root.setBottom(rollButton);
    
    Scene scene = new Scene(root);
    stage.setScene(scene);
    stage.setTitle("Dice!");
    stage.setResizable(false);
    stage.show();
          
} // end start()</pre>


<p>The method for drawing the dice was discussed in the solution to
<localref href="GUI1.ex.3"/>.  But we still have to think about animating
the rolling of the dice.  The <code>roll()</code> method is responsible
for rolling the dice.  In the original version, this method simply set
the numbers showing on the dice to random values and called <code>draw()</code>.
In the new version, we want to repeat this action several times over a period
of time.  That is, we want an animation in which the action for each frame
is to randomize the numbers on the dice and call <code>draw()</code>.</p>

<p>Animation is discussed in <localref href="GUI1.3.5"/>.  We need to
make a subclass of <classname>AnimationTimer</classname> and provide
a definition for the <code>handle()</code> method.  That method will
be called once in each frame.  The timer can be defined using
an anonymous nested class (see <localref href="OOP.8.3"/>.)  In my program,
the timer is a global variable.  It might
seem like it would be enough to say:</p>

<pre>private AnimationTimer timer = new AnimationTimer() {
    public void handle( long time ) {
        die1 = (int)(Math.random()*6) + 1;
        die2 = (int)(Math.random()*6) + 1;
        draw();
    }
};</pre>

<np>Then, when the <code>roll()</code> method is called, it could simply
call <code>time.start()</code>.  But there is a big problem with this:
The animation should only go on for a short time.  In order to stop
it, <code>timer.stop()</code> has to be called.  But who will call it,
and how will they know when to call it?  In fact, the timer can stop
itself after a certain number of frames have passed.  In order to do
that, I use a global <code>frameNumber</code> variable.  When <code>roll()</code>
starts the timer, it sets the frame number to 0:</np>

<pre>private void roll() {
   frameNumber = 0;
   rollButton.setDisable(true);
   timer.start(); // start an animation
}</pre>

<np>Note that it also
disables the button, so that the user will not be able to roll the dice
while they are already being rolled.  Then the timer's <code>handle()</code>
method should increment the frame number, and it should stop itself if the frame number
has reached some maximum value.
It must also re-enable the button to make it possible to
roll the dice again.  So, here is the actual definition of the timer:</np>

<pre>private AnimationTimer timer = new AnimationTimer() {
        // The timer is used to animate "rolling" of the dice.
        // In each frame, the dice values are randomized.  When
        // the number of frames reaches 60, the timer stops itself.
        // The rollButton is disabled while an animation is in
        // progress, so it has to be enabled when the animation stops.
    public void handle( long time ) {
        die1 = (int)(Math.random()*6) + 1;
        die2 = (int)(Math.random()*6) + 1;
        draw();
        frameNumber++;
        if (frameNumber == 60) {
            timer.stop();
            rollButton.setDisable(false);
        }
    }
};</pre>

<np>The dice will change for 60 frames or about one second.  It might be that changing the dice
every 1/60 second is too fast.  Unfortunately, there is no way to slow down the
frame rate in an <classname>AnimationTimer</classname>.  However, it is certainly
possible to do nothing in some of the frames.  For example, if you only want
to change the dice every 10 frames, you can begin the <code>handle()</code>
method by saying</np>

<pre>if (frameNumber % 10 != 0) {
       // do nothing if frameNumber is not a multiple of 10
    return;
}</pre>

</exercise-discuss>
<exercise-code>
<pre><prog name="RollDiceWithButton">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.BorderPane;
import javafx.scene.control.Button;
import javafx.scene.paint.Color;
import javafx.animation.AnimationTimer;


/**
 * Shows a pair of dice that are rolled when the user clicks a button
 * that appears below the dice.
 */
public class RollDiceWithButton extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------
    
   private int die1 = 4;  // The values shown on the dice.
   private int die2 = 3;
   
   private Canvas canvas; // The canvas where the dice are drawn
   
   private Button rollButton;  // The button that is clicked to roll the dice.
   
   private int frameNumber;  // When an animation is running, the number of
                             //    frames for which it has been running.  This
                             //    is used to end the animation after 60 frames.

   private AnimationTimer timer = new AnimationTimer() {
           // The timer is used to animate "rolling" of the dice.
           // In each frame, the dice values are randomized.  When
           // the number of frames reaches 60, the timer stops itself.
           // The rollButton is disabled while an animation is in
           // progress, so it has to be enabled when the animation stops.
       public void handle( long time ) {
           die1 = (int)(Math.random()*6) + 1;
           die2 = (int)(Math.random()*6) + 1;
           draw();
           frameNumber++;
           if (frameNumber == 60) {
               timer.stop();
               rollButton.setDisable(false);
           }
       }
   };
   
   
   /**
    *  The start() method sets up the GUI, using a BorderPane in which
    *  the canvas is the center component and the button is the bottom
    *  component.  An ActionEvent handler is added to the button to
    *  roll the dice when the button is clicked.
    */
   public void start(Stage stage) {
      
       canvas = new Canvas(100,100);
       draw();  // Draw the original dice.
       
       rollButton = new Button("Roll!");
       rollButton.setMaxWidth(1000);  // so button can grow to full width of window
       rollButton.setOnAction( e -> roll() ); // When clicked, roll the dice.
       
       BorderPane root = new BorderPane();
       root.setCenter(canvas);
       root.setBottom(rollButton);
       
       Scene scene = new Scene(root);
       stage.setScene(scene);
       stage.setTitle("Dice!");
       stage.setResizable(false);
       stage.show();
             
   } // end start()
   
   
   /**
    * Roll the dice by starting an animation that randomizes
    * the values on the dice in each frame.  The animation will
    * last for 60 frames, and the rollButton is disabled while
    * the animation is in progress.  This method is called
    * when the user clicks the roll button.
    */
   private void roll() {
       frameNumber = 0;
       rollButton.setDisable(true);
       timer.start(); // start an animation
   }


  /**
    * Draw a die with upper left corner at (x,y).  The die is
    * 35 by 35 pixels in size.  The val parameter gives the
    * value showing on the die (that is, the number of dots).
    */
   private void drawDie(GraphicsContext g, int val, int x, int y) {
       g.setFill(Color.WHITE);
       g.fillRect(x, y, 35, 35);
       g.setStroke(Color.BLACK);
       g.strokeRect(x+0.5, y+0.5, 34, 34);
       g.setFill(Color.BLACK);
       if (val > 1)  // upper left dot
           g.fillOval(x+3, y+3, 9, 9);
       if (val > 3)  // upper right dot
           g.fillOval(x+23, y+3, 9, 9);
       if (val == 6) // middle left dot
           g.fillOval(x+3, y+13, 9, 9);
       if (val % 2 == 1) // middle dot (for odd-numbered val's)
           g.fillOval(x+13, y+13, 9, 9);
       if (val == 6) // middle right dot
           g.fillOval(x+23, y+13, 9, 9);
       if (val > 3)  // bottom left dot
           g.fillOval(x+3, y+23, 9, 9);
       if (val > 1)  // bottom right dot
           g.fillOval(x+23, y+23, 9,9);
   }


   /**
    * The draw() method just draws the two dice and draws
    * a two-pixel wide blue border around the canvas.
    */
   private void draw() {
       GraphicsContext g = canvas.getGraphicsContext2D();
       g.setFill(Color.rgb(200,200,255));
       g.fillRect(0,0,100,100);
       g.setStroke( Color.BLUE );
       g.strokeRect(1,1,98,98);
       drawDie(g, die1, 10, 10);
       drawDie(g, die2, 55, 55);
   }
   
} // end class RollDiceWithButton
</prog></pre>
</exercise-code>
</exercise>
   
   

<exercise>
<exercise-question><p>In <localref href="control.ex.6"/>, you drew a checkerboard. For this
exercise, write a program where the user can select a square by
clicking on it.
Highlight the selected square by drawing a colored border around
it. When the program starts, no square is selected. When the user
clicks on a square that is not currently selected, it becomes selected, and the
previously selected square, if any, is unselected. If the
user clicks the square that is selected, it becomes unselected. Assume that the
size of the checkerboard is exactly 400 by 400 pixels, so that each square on the
checkerboard is 50 by 50 pixels.  Here is my checkerboard, with the square in
row 3, column 3 selected, shown at reduced size:</p>
<img src="clickable-checkerboard.png" width="160" height="160" alt="checkerboard"
    tex="clickable-checkerboard.eps" texscale="0.75"/>
</exercise-question>
<exercise-discuss><p>See the solution to <localref href="control.ex.6"/> for
a discussion of how to draw the checkerboard. For the new version, we need
to add a <code>MousePressed</code> event handler to the <classname>Canvas</classname>
on which the checkerboard is drawn. We also need to add instance variables to
keep track of which square, if any, is selected.  I use two integer variables
<code>selectedRow</code> and <code>selectedCol</code>.
When no square is selected, <code>selectedRow</code> is -1 (and I don't care what
<code>selectedCol</code> is). When a square is selected, <code>selectedRow</code> is
the number of the row that contains that square and <code>selectedCol</code> is the
number of the column that contains the selected square. Remember that rows and
columns are numbered from 0 to 7. This makes some of the calculations easier
than numbering them from 1 to 8.</p>

<p>After drawing the checkerboard, <code>draw()</code>, the method that draws the canvas,
has to highlight the selected square, if there is one. I do
this by drawing a cyan border around the inside of the selected square. This is
the new code that is added to the checkerboard-drawing code, after the
checkerboard has been drawn:</p>

<pre>if (selectedRow >= 0) {
        // Since there is a selected square, draw a cyan
        // border around it.  (If selectedRow &lt; 0, then
        // no square is selected and no border is drawn.)
    g.setStroke(Color.CYAN);
    g.setLineWidth(3);  // the border will be 3 pixels wide
    y = selectedRow * 50;  // y-coord of top-left corner of selected square
    x = selectedCol * 50;  // x-coord of top-left corner of selected square
    g.strokeRect(x+1.5, y+1.5, 47, 47);
}</pre>

<np>The border of the selected square is three pixels wide. To make the border lie
entirely inside the square, we need to stroke a rectangle that is inset from
the edges of the square by half of the line width, that is, by 1.5 pixels.
This explains the parameters to <code>g.strokeRect()</code>.  Remember that
when a shape is stroked, the center of the pen is dragged along the border
of the shape.</np>

<p>Now, let's say that the user clicks at the point <code>(x,y)</code>. The problem is
to determine which square on the checkerboard contains that point. The column
number of the square is obtained by dividing the <code>x</code> coordinate by the
width of the squares. The column number is an integer, while <code>x</code>
is of type <ptype>double</ptype>.  Since the squares are 50 pixels wide, the row number of
the clicked square is <code>(int)(x/50)</code>. 
For values of <code>x</code> between 0 and 49, <code>x/50</code> is greater than or equal
to 0 and less than 1, so taking its integer part
gives a column number of 0, which is correct. For the next 50 pixels, from
50 to 99, <code>(int)(x/50)</code> is 1, which is the correct column number. For the next
strip of pixels, from 100 to 149, the answer is 2. And so on. Similarly,
<code>(int)(y/50)</code> gives the row number of the square where the user clicked.
(I often get rows and columns mixed up&mdash;remember that the x coordinate corresponds to
columns and the y coordinate corresponds to rows.)</p>

<p>Once we know the row and column where the user clicked, we can compare them
to <code>selectedRow</code> and <code>selectedCol</code>. If the values are the same,
then the user clicked in a square that was already selected. We want to remove
the highlighting. That can be done by setting <code>selectedRow = -1</code>, the value
that indicates that no square is selected. Otherwise, the values of
<code>selectedRow</code> and <code>selectedCol</code> are set to the row and column
that the user clicked.  In the end, <code>draw()</code> is called so that the
change will be reflected in what is shown on the screen.</p>

<p>All this explains the reasoning behind the <code>mousePressed()</code> routine,
which you can see below.</p>
</exercise-discuss>
<exercise-code>
<pre>
<prog name="ClickableCheckerboard">import javafx.application.Application;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.scene.layout.Pane;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.input.MouseEvent;

/**  
 *  This program draws a red-and-black checkerboard.
 *  It is assumed that the size of the canvas is 400
 *  by 400 pixels.  When the user clicks a square, that
 *  square is selected, unless it is already selected.
 *  When the user clicks the selected square, it is
 *  unselected.  If there is a selected square, it is
 *  highlighted with a cyan border.
 */
public class ClickableCheckerboard extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //-------------------------------------------------------------------

    private Canvas canvas;  // Where the checkerboard is drawn

    private int selectedRow; // Row and column of selected square.  If no
    private int selectedCol; //      square is selected, selectedRow is -1.

    /**
     * Constructor.  Set selectedRow to -1 to indicate that
     * no square is selected.  And set the board object
     * to listen for mouse events on itself.
     */
    public void start(Stage stage) {
        
        selectedRow = -1;  // To start, no square is selected!
        
        canvas = new Canvas(400,400);
        draw();
        
        canvas.setOnMousePressed(e -> mousePressed(e));
        
        Pane root = new Pane(canvas);
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setResizable(false);
        stage.setTitle("Click Me!");
        stage.show();        
    }
    

    /**
     * Draw the checkerboard and highlight selected square, if any.
     */
    private void draw() {

        int row;   // Row number, from 0 to 7
        int col;   // Column number, from 0 to 7
        int x,y;   // Top-left corner of square
        
        GraphicsContext g = canvas.getGraphicsContext2D();

        for ( row = 0;  row &lt; 8;  row++ ) {

            for ( col = 0;  col &lt; 8;  col++) {
                x = col * 50;
                y = row * 50;
                if ( (row % 2) == (col % 2) )
                    g.setFill(Color.RED);
                else
                    g.setFill(Color.BLACK);
                g.fillRect(x, y, 50, 50);
            } 

        } // end for row

        if (selectedRow >= 0) {
                // Since there is a selected square, draw a cyan
                // border around it.  (If selectedRow &lt; 0, then
                // no square is selected and no border is drawn.)
            g.setStroke(Color.CYAN);
            g.setLineWidth(3);
            y = selectedRow * 50;
            x = selectedCol * 50;
            g.strokeRect(x+1.5, y+1.5, 47, 47);
        }

    }  // end paint()
    

    /**
     * When the user clicks on the canvas, figure out which
     * row and column the click was in and change the
     * selected square accordingly.
     */
    private void mousePressed(MouseEvent evt) {

        int col = (int)(evt.getX() / 50);   // Column where user clicked.
        int row = (int)(evt.getY() / 50);   // Row where user clicked.

        if (selectedRow == row &amp;&amp; selectedCol == col) {
                // User clicked on the currently selected square.
                // Turn off the selection by setting selectedRow to -1.
            selectedRow = -1;
        }
        else {
                // Change the selection to the square the user clicked on.
            selectedRow = row;
            selectedCol = col;
        }
        draw();

    }  // end mousePressed()

} // end ClickableCheckerboard
</prog>
</pre>
</exercise-code>
</exercise>
   
   

<exercise>
<exercise-question><p>For this exercise, you
should modify the SubKiller game from <localref href="GUI1.3.6"/>. You
can start with the existing source code, from the file 
<sourceref href="SubKiller.java"/>. Modify the game so it
keeps track of the number of hits and misses and displays these quantities.
That is, every time the depth charge blows up the sub, the number of hits goes
up by one. Every time the depth charge falls off the bottom of the screen
without hitting the sub, the number of misses goes up by one. There is room at
the top of the canvas to display these numbers. To do this exercise, you only
have to add a half-dozen lines to the source code. But you have to figure out
what they are and where to add them. To do this, you'll have to read the source
code closely enough to understand how it works.</p>
</exercise-question>
<exercise-discuss><p>You can do this exercise by adding as few as seven lines to the original
version, <sourceref href="SubKiller.java"/> (plus changing the name of the class, if you want to do that).
I used two lines to declare instance variables named <code>hits</code> and
<code>misses</code>. These variables have to be updated whenever the depth charge
hits the sub or falls off the bottom of the canvas. These events are already
detected by the canvas, in the <code>updateForNextFrame()</code> method of the
<classname>Bomb</classname> class. At the point
where this method detects that the depth charge has hit the sub, I add the
command "<code>hits++;</code>" to chalk up another hit for the user. At the point
in where it is determined that the <code>y</code>-coordinate
of the depth charge has exceeded the height of the canvas, I add the command
"<code>misses++;</code>" to record the fact that the sub has escaped destruction
this time.</p>

<p>The only other thing to do is to display the number of hits and misses at
the top of the canvas. This is part of drawing the picture, so it is done in the
<code>draw()</code> method. The information is output with two
<code>drawString</code> commands. We need one more command to set the color
for the strings:</p>

<pre>g.setFill(Color.BLACK);
g.fillText("Number of hits:   " + hits, 15, 24);
g.fillText("Number of misses: " + misses, 15, 45);</pre>

<p>(Using the coordinates in these statements, the messages about hits and misses were
drawn over the "CLICK TO ACTIVATE" message, so I also moved the
"CLICK TO ACIVATE" message from x-coordinate 30 to x-coordinate 300 to make room 
for the new messages.)</p>
   
<p>I made one further non-essential change when I decided that I wanted the output to be
displayed in a larger font. I create a new font, store it in an instance
variable named <code>infoFont</code>, and use the command
"<code>g.setFont(infoFont);</code>" before drawing the strings.</p>

<p>The source code is shown below. Changes from the original version are shown
in &newcodestyle;.</p>
</exercise-discuss>
<exercise-code>
<pre>
<prog name="SubKillerWithScore">import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.KeyCode;
import javafx.animation.AnimationTimer;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;

/**
 * This program implements a simple arcade game in which the user tries to blow
 * up a "submarine" (a black oval) by dropping "depth charges" (a red disk) from 
 * a "boat" (a blue roundrect).  The user moves the boat with the left- and 
 * right-arrow keys and drops the depth charge with the down-arrow key.
 * The sub moves left and right erratically along the bottom of the canvas.
 <newcode>* The number of hits and the number of misses are shown at the top of the window.</newcode>
 */
public class SubKillerWithScore extends Application {
    
    public static void main(String[] args) {
        launch(args);
    }
    
    //------------------------------------------------------------------------

    private AnimationTimer timer; // AnimationTimer that drives the animation.

    private final int width = 640, height = 480; // The size of the canvas  

    private Boat boat;          // The boat, bomb, and sub objects are defined
    private Bomb bomb;          //    by nested classes Boat, Bomb, and Submarine,
    private Submarine sub;      //    which are defined later in this class.
    
    <newcode>private int hits;           // The number of times the user has hit the sub.
    private int misses;         // The number of times the user has missed the sub.

    private Font infoFont = Font.font(null, FontWeight.BOLD, 16);
                            // A font for displaying the numbers of hits and misses.</newcode>

    private Canvas canvas;      // The canvas where everything is drawn.
    
    private Stage stage;        // This program's window.


    /**
     * Start method creates the window content and configures event listening.
     */
    public void start(Stage stage) {
        
        /* Create objects. */

        boat = new Boat();
        sub = new Submarine();
        bomb = new Bomb();

        canvas = new Canvas(width,height);
                
        this.stage = stage;
        
        /* Set up the GUI */
        
        Pane root = new Pane(canvas);
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Sub Killer -- Use arrow keys to play!");
        stage.setResizable(false);
        
        /* Configure event listeners and animation. */
        
        scene.setOnKeyPressed( evt -> {
                // The key listener responds to keyPressed events on the canvas. Only
                // the left-, right-, and down-arrow keys have any effect.  The left- and
                // right-arrow keys move the boat while down-arrow releases the bomb.
            KeyCode code = evt.getCode();  // Which key was pressed?
            if (code == KeyCode.LEFT) {
                    // Move the boat left.  (If this moves the boat out of the frame, its
                    // position will be adjusted in the boat.updateForNewFrame() method.)
                boat.centerX -= 15;
            }
            else if (code == KeyCode.RIGHT) {  
                    // Move the boat right.  (If this moves boat out of the frame, its
                    // position will be adjusted in the boat.updateForNewFrame() method.)
                boat.centerX += 15;
            }
            else if (code == KeyCode.DOWN) {
                    // Start the bomb falling, if it is not already falling.
                if ( bomb.isFalling == false )
                    bomb.isFalling = true;
            }
        } );
        
        stage.focusedProperty().addListener( (obj,oldVal,newVal) -> {
                // This listener turns the animation off when this program's
                // window does not have the input focus.
            if (newVal) { // The window has gained focus.
                timer.start();
            }
            else {  // The window has lost focus.
                timer.stop();
            }
            draw(); // Appearance changes depending on focus.
        });
        
        timer = new AnimationTimer( ) {
               // The handle method is called once per frame while the
               // animation is running.  There should be about 60
               // frames per second.
            public void handle(long time) {
                boat.updateForNewFrame();
                bomb.updateForNewFrame();
                sub.updateForNewFrame();
                draw();
            }
        };
        
        /* Show the window. */
        
        stage.show();
        timer.start(); // (Start animation -- probably redundant, since 
                       //  focus listener should be called when window opens.)
    } // end start()


    /**
     * The draw() method draws the current state of the game.  It
     * draws a gray or cyan border around the canvas to indicate whether or not
     * the window has the input focus.  It draws the boat, sub, and bomb by
     * calling their respective draw() methods.  This method is called in
     * each frame and when the window gains or loses focus.
     */
    public void draw() {

        GraphicsContext g = canvas.getGraphicsContext2D();
        <newcode>g.setFont(infoFont);</newcode>
        
        g.setFill(Color.rgb(0,200,0)); // Fill with green, erasing previous frame.
        g.fillRect(0,0,width,height);

        if (stage.isFocused()) {
                // draw a CYAN border on the window when when window has focus.
            g.setStroke(Color.CYAN);
        }
        else {
                // Draw gray border and a message when window does not have focus.
            g.setFill(Color.BLACK);
            g.fillText("(ANIMATION PAUSED)", <newcode>300</newcode>, 30); <newcode>// (x-coord was changed)</newcode>
            g.setStroke(Color.DARKGRAY);
        }
        g.setLineWidth(3);
        g.strokeRect(1.5,1.5,width-3,height-3);  // Draw a 3-pixel border.

        boat.draw(g);  // The three objects draw themselves.
        sub.draw(g);
        bomb.draw(g);

        <newcode>g.setFill(Color.BLACK);
        g.fillText("Number of hits:   " + hits, 15, 24);
        g.fillText("Number of misses: " + misses, 15, 45);</newcode>
        
    } // end draw()


    /**
     * This nested class defines the boat.
     */
    private class Boat {
        int centerX, centerY;  // Current position of the center of the boat.
        Boat() { // Constructor centers the boat horizontally, 80 pixels from top.
            centerX = width/2;
            centerY = 80;
        }
        void updateForNewFrame() { // Makes sure boat has not moved off screen.
            if (centerX &lt; 0)
                centerX = 0;
            else if (centerX > width)
                centerX = width;
        }
        void draw(GraphicsContext g) {  // Draws the boat at its current location.
            g.setFill(Color.BLUE);
            g.fillRoundRect(centerX - 40, centerY - 20, 80, 40, 20, 20);
        }
    } // end nested class Boat


    /**
     * This nested class defines the bomb. 
     */
    private class Bomb {
        int centerX, centerY; // Current position of the center of the bomb.
        boolean isFalling;    // If true, the bomb is falling; if false, it
                             // is attached to the boat.
        Bomb() { // Constructor creates a bomb that is initially attached to boat.
            isFalling = false;
        }
        void updateForNewFrame() {  // If bomb is falling, take appropriate action.
            if (isFalling) {
                if (centerY > height) {
                        // Bomb has missed the submarine.  It is returned to its
                        // initial state, with isFalling equal to false.
                    isFalling = false;
                    <newcode>misses++; // The number of misses goes up by one.</newcode>
                }
                else if (Math.abs(centerX - sub.centerX) &lt;= 36 &amp;&amp;
                        Math.abs(centerY - sub.centerY) &lt;= 21) {
                        // Bomb has hit the submarine.  The submarine
                        // enters the "isExploding" state.
                    sub.isExploding = true;
                    sub.explosionFrameNumber = 1;
                    isFalling = false;  // Bomb reappears on the boat.
                    <newcode>hits++;  // The number of hits goes up by one.</newcode>
                }
                else {
                        // If the bomb has not fallen off the canvas or hit the
                        // sub, then it is moved down 6 pixels.
                    centerY += 6;
                }
            }
        }
        void draw(GraphicsContext g) { // Draw the bomb.
            if ( ! isFalling ) {  // If not falling, set centerX and centerY
                                  // to show the bomb on the bottom of the boat.
                centerX = boat.centerX;
                centerY = boat.centerY + 23;
            }
            g.setFill(Color.RED);
            g.fillOval(centerX - 8, centerY - 8, 16, 16);
        }
    } // end nested class Bomb


    /**
     * This nested class defines the sub.
     */
    private class Submarine {
        int centerX, centerY; // Current position of the center of the sub.
        boolean isMovingLeft; // Tells whether the sub is moving left or right
        boolean isExploding;  // Set to true when the sub is hit by the bomb.
        int explosionFrameNumber;  // If the sub is exploding, this is the number
                                   //   of frames since the explosion started.
        Submarine() {  // Create the sub at a random x-coordinate, 40 pixels from bottom.
            centerX = (int)(width*Math.random());
            centerY = height - 40;
            isExploding = false;
            isMovingLeft = (Math.random() &lt; 0.5);
        }
        void updateForNewFrame() { // Move sub or increase explosionFrameNumber.
            if (isExploding) {
                    // If the sub is exploding, add 1 to explosionFrameNumber.
                    // When the number reaches 15, the explosion ends and the
                    // sub reappears in a random position.
                explosionFrameNumber++;
                if (explosionFrameNumber == 25) { 
                    centerX = (int)(width*Math.random());
                    centerY = height - 40;
                    isExploding = false;
                    isMovingLeft = (Math.random() &lt; 0.5);
                }
            }
            else { // Move the sub.
                if (Math.random() &lt; 0.02) {  
                        // In one frame out of every 50, on average, the sub
                        // reverses its direction of motion.
                    isMovingLeft = ! isMovingLeft; 
                }
                if (isMovingLeft) { 
                        // Move the sub 3 pixels to the left.  If it moves off
                        // the left edge of the canvas, move it back to the left
                        // edge and start it moving to the right.
                    centerX -= 3;  
                    if (centerX &lt;= 0) {  
                        centerX = 0; 
                        isMovingLeft = false; 
                    }
                }
                else {
                        // Move the sub 3 pixels to the right.  If it moves off
                        // the right edge of the canvas, move it back to the right
                        // edge and start it moving to the left.
                    centerX += 3;         
                    if (centerX > width) {  
                        centerX = width;   
                        isMovingLeft = true; 
                    }
                }
            }
        }
        void draw(GraphicsContext g) {  // Draw sub and, if it is exploding, the explosion.
            g.setFill(Color.BLACK);
            g.fillOval(centerX - 30, centerY - 15, 60, 30);
            if (isExploding) {
                    // Draw an "explosion" that grows in size as the number of
                    // frames since the start of the explosion increases.
                g.setFill(Color.YELLOW);
                g.fillOval(centerX - 3*explosionFrameNumber,
                        centerY - 1.5*explosionFrameNumber,
                        6*explosionFrameNumber,
                        3*explosionFrameNumber);
                g.setFill(Color.RED);
                g.fillOval(centerX - 1.5*explosionFrameNumber,
                        centerY - explosionFrameNumber/2,
                        3*explosionFrameNumber,
                        explosionFrameNumber);
            }
        }
    } // end nested class Submarine    


} // end class SubKillerWithScore
</prog>
</pre>
</exercise-code>
</exercise>
   


<exercise id="GUI1.ex.7">
<exercise-question><p><localref href="OOP.ex.2"/> involved a class, <sourceref chapter="5" href="StatCalc.java"/>,
that could compute some statistics
of a set of numbers. Write a GUI program that uses the <classname>StatCalc</classname> class to
compute and display statistics of numbers entered by the user. The program will
have an instance variable of type <classname>StatCalc</classname> that does the computations.
The program should include a <classname>TextField</classname> where the user enters a number.
It should have four labels that display four statistics for the numbers that
have been entered: the number of numbers, the sum, the mean, and the standard
deviation. Every time the user enters a new number, the statistics displayed on
the labels should change. The user enters a number by typing it into the
<classname>TextField</classname> and then either clicking an "Enter" button or
pressing the Return (or Enter) key.  There should be a "Clear" button that
clears out all the data. This means creating a new <classname>StatCalc</classname> object and
changing the text that is displayed on the labels. 
(See the discussion of "default buttons" at the end of
<localref href="GUI1.4.2"/> for one way of implementing a response the Return key.)
Here is a picture of my solution to this problem:</p>
<img src="stat-calc-gui.png" width="396" height="204" alt="screenshot from StatCalcGUI program"
        tex="stat-calc-gui.eps" texscale="0.6"/>
<np>Getting the interface to look just like I wanted it was the hardest part.
In the end, I used <classname>TilePanes</classname> (<localref href="GUI1.5.4"/>) for the layout.</np>
</exercise-question>
<exercise-discuss>
<p>In my solution, I used four labels to display results from the <classname>StatCalc</classname>,
and another label at the top of the window to display a message to the user. Aside from these labels,
one row in the layout holds the other three components: a <classname>TextField</classname> and
two <classname>Buttons</classname>.  I want to spend some time talking about how I designed
the GUI for the program.  My first idea for layout was to use an <classname>HBox</classname> 
to hold the text field and buttons, and a <classname>VBox</classname> to line up the
<classname>HBox</classname> and the five labels vertically.  As I often do, I first
wrote the program without paying too much attention to appearance.  The result was
not very attractive:</p>

<img src="StatCalcGUI-ugly.png" width="278" height="108" tex="StatCalcGUI-ugly.eps"
         texscale="0.6" alt="first, unattractive version of StatCalcGUI"/>
         
<np>Note in particular that there is not enough room in the bottom display labels to display
the numbers.  When this happens, a <classname>Label</classname> will automatically
modify the displayed string to use an ellipsis (&dots;) to indicate that not all of
the text is shown.  (Buttons will do the same thing.)  When the labels were constructed,
the text in the constructor did not include the numbers, so the preferred size of
the labels was not large enough to allow enough space when the numbers were added
later.  This is often an issue when using labels and buttons whose text will change
while the program is running.</np>

<p>I could have worked to improve the appearance, but I decided that it would be easier
to do if I used <classname>TilePanes</classname> for layout.  My final program
uses a <classname>TilePane</classname> to hold the textfield and
buttons; the preferred number of columns for that <classname>TilePane</classname> is set to&nbsp;3.
And the program uses a <classname>TilePane</classname> with one column for the
overall layout.</p>

<p>Labels and buttons in a <classname>TilePane</classname> will not
automatically expand to fill their tiles, because of their default maximum size.
To allow them to expand, we have to increase their maximum sizes.  This can be
done by calling, for example, <code>label.setMaxSize(1000,1000)</code>.
</p>

<p>I also reduced the number of preferred columns in the <classname>TextField</classname>,
since the default forced the preferred size of the scene to be larger than I liked.
With all of these changes, the interface looked much nicer:</p>

<img src="StatCalcGUI-less-ugly.png" width="365" height="173" tex="StatCalcGUI-less-ugly.eps"
         texscale="0.6" alt="second, more attractive version of StatCalcGUI"/>

<p>This would have been satisfactory, but I wanted something a little more dramatic.
I decided to add lines between the labels.  I could have done that by adding black borders
to the labels, but I decided to use a different approach.  I set the horizontal and
vertical gaps on the <classname>TilePanes</classname> to be 3 pixels.  The background
will show through the gaps, so I got my black lines by setting the background color of the
root <classname>TilePane</classname> to be black, instead of the usual light gray.
Unfortunately, the default background for a label is transparent, which meant that all the labels
were filled with the black background of the root <classname>TilePane</classname>,
hiding the text, which was also black!  To fix that,
I set the text color for the top label to be white, and I set the background color
for the other four labels to be white.  This finally gave me the look that I wanted.
I should emphasize that the approach that I used is not by any means the only one
that would have worked.</p>

<break/>         

<p>Turning to the actual programming, consider the labels that display
the results from the <classname>StatCalc</classname>.
Since there are four labels to create, I wrote a method to
create and configure them:</p>

<pre>/**
 * A utility routine for creating the labels that are used
 * for display.  This routine is used in the start() method.
 */
private Label makeLabel(String text) {
   Label label = new Label(text);
   label.setMaxSize(1000,1000);
   label.setStyle("-fx-background-color:white; " +
                        "-fx-font-family: monospace; -fx-font-weight: bold");
   return label;
} </pre>

<np>Note that the maximum width and height of the label have been made quite
large.  CSS styling (<localref href="GUI1.2.5"/>) is used to set the background color to be white
and to use a bold monospace font.  (A monospace font is used since every
character in a monospace font has the same width, making it easy to
line up the numbers vertically in the labels.  JavaFX 8 seems to have no
way to ensure that a font will be monospace, except to use CSS.)</np>

<p>Then in the <code>start()</code> method, the labels can be created with four
statements, instead of 12:</p>

<pre>countLabel =   makeLabel(" Number of Entries:  0");
sumLabel =     makeLabel(" Sum:                0.0");
meanLabel =    makeLabel(" Average:            undefined");
standevLabel = makeLabel(" Standard Deviation: undefined");</pre>

<p>Utility routines like <code>makeLabel()</code> are very commonly used when there
are a lot of similar components to create. Note that when the labels are first
created, the text on the labels is appropriate for a dataset that contains zero
elements. In particular, if there is no data, the average and standard
deviation are undefined.</p>

<p>An <code>ActionEvent</code> handler is installed on each button.  The handler
calls an appropriate method that is defined elsewhere in the class.
The "Enter" button is made into the default button for the program
by calling <code>enterButton.setDefaultButton(true)</code>, as suggested
in the instructions for the exercise.  Note in the
screenshot from the program that this also changes the appearance of the
"Enter" button.  Here is the code that creates and configures the buttons:</p>

<pre>enterButton = new Button("Enter");
enterButton.setOnAction( e -> doEnter() );
enterButton.setMaxSize(1000,1000);
enterButton.setDefaultButton(true);

clearButton = new Button("Clear");
clearButton.setOnAction( e -> doClear() );
clearButton.setMaxSize(1000,1000);</pre>

<p>In the <code>doClear()</code> method, the response to the "Clear" button is to create a new
<classname>StatCalc</classname> object and to reset the display labels to reflect the fact
that there is no data in the dataset.  The labels are changed by another method, 
<code>showData()</code>:</p>

<pre>private void doClear() {
    stats = new StatCalc();
    numberInput.setText("");
    showData();
}</pre>

<np>Here, <code>stats</code> is a global variable of type <code>StatCalc</code> that is
used to do the calculations in the program.  It's important to understand the effect
of the command "<code>stats&nbsp;=&nbsp;new&nbsp;StatCalc();</code>". The program will continue to
use the same <classname>StatCalc</classname> <b>variable</b>, <code>stats</code>. However, now
the variable refers to a new <classname>StatCalc</classname> <b>object</b>. The new object
does not yet have any data in its dataset. When <code>showData()</code> is called,
it is working with a <code>StatCalc</code> object to which no data has been added.
The next time the user enters a
number, the dataset will get its first value. Always keep in mind the
difference between variables and objects. Also, keep in mind that you have to
think in terms of changing the state of the program in response to events. I
change the program's state by starting to use a new <classname>StatCalc</classname> object,
and I call <code>showData()</code> to change the display labels to keep them consistent with the new
state.</np>

<p>When the user clicks the "Enter" button or presses Return, another method, <code>doEnter()</code> is called.
That method has to get the user's input, add it to the
<classname>StatCalc</classname> object, and then call <code>showData()</code>
to change the display labels to show the new values. The code
for getting the user's number from the input box includes a check to make sure that the user's
input is a legal number. If the input is not legal, then the method shows an error
message in the <classname>Label</classname> at the top of the window, which is represented by
a global variable named <code>message</code>:</p>

<pre>private void doEnter() {
    double num;  // The user's number.
    try {
        num = Double.parseDouble(numberInput.getText());
    }
    catch (NumberFormatException e) {
            // The user's entry is not a legal number.  
            // Put an error message in the message label 
            // and return without entering a number.
        message.setText("\"" + numberInput.getText() + "\" is not a legal number.");
        numberInput.selectAll();
        numberInput.requestFocus();
        return;
    }
    stats.enter(num);
    showData();
}</pre>

<np>When an error is detected, the method returns immediately, since there is
no data to process.
The commands "<code>numberInput.selectAll();</code>" and
"<code>numberInput.requestFocus();</code>" are there as a convenience for the user.
The first command
selects all the text in the textfield. The second
command gives the input focus to the textfield. That way, the user can just
start typing the next number, without having to click on the input box or erase
the content of the box. (Since the contents of the box are selected, they will
disappear automatically when the user starts typing, to be replaced with the
new input. A surprising number of people have never learned that text
selections work this way.)</np>

<p>Once we have the user's number, the command "<code>stats.enter(num);</code>"
adds the number <code>num</code> into the dataset. In the <code>showData()</code>
method, the statistics about the data
set can be obtained by calling the functions <code>stats.getCount()</code>,
<code>stats.getSum()</code>, <code>stats.getMean()</code>, and
<code>stats.getStandardDeviation()</code>. (This information can be found by reading
the <sourceref chapter="5" href="StatCalc.java">source code</sourceref> for the <classname>StatCalc</classname>
class.)  These values are used on the labels that display the statistics.  For example,</p>

<pre>countLabel.setText(" Number of Entries:  " + stats.getCount());</pre>

<np>Returning to the topic of variables versus objects, a common novice mistake would
be to try to change the text that is displayed on the label by saying</np>

<pre>countLabel = new Label(" Number of Entries:  " + stats.getCount());  <newcode>// WRONG</newcode></pre>

<np>since that type of command is what was used to set the text in the first
place.  But this statement has no effect on what is displayed on the screen.
The reason why this doesn't work is instructive:  The assignment
command creates a new <classname>Label</classname> and sets <code>countLabel</code> to refer to
that new object.  The new label does indeed have the desired text.  But the
new label has nothing to do with what's on the screen!  The original label was
created in the constructor and added to the root tilepane.  It is the <b>original</b>
label object that is in the scene graph, so the original label continues to appear on the screen
even if the instance variable <code>countLabel</code> now refers to a different label object.  The correct command,
using <code>countLabel.setText()</code>, <b>modifies the original label object</b>,
which is what is shown on the screen.</np>

<p>As a point of interest, I will mention another technique.  You might want to limit the number of decimal places that
are displayed in the statistics.  You know how to do this in output to the command
line, using <code>System.out.printf</code>, but we are not 
outputting the data here, just putting it into a String.  The <classname>String</classname>
class has a <code>static</code> method <code>String.format()</code> that solves this
problem.  <code>String.format(fmtString,val,val,val,...)</code> works similarly
to <code>System.out.printf(fmtString,val,val,val,...)</code>, but instead of producing
output, <code>String.format</code> just creates a string and returns it.
To set the text of the label that displays the average, for example, you Might say:</p>

<pre>meanLabel.setText( String.format(" Average:            %1.8g", stats.getMean()) );</pre>

<np>I don't do this in my solution, but <code>String.format()</code> can be very useful</np>
   
</exercise-discuss>
<exercise-code>
<pre> 
<prog name="StatCalcGUI">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.layout.TilePane;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

/**
 * In this program, the user enters numbers in a text field box.
 * After entering each number, the user presses return (or clicks
 * on a button).  Some statistics are displayed about all the
 * numbers that the user has entered.
 */
public class StatCalcGUI extends Application {
 
    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------
    
    private Label countLabel;    // A label for displaying the number of numbers.
    private Label sumLabel;      // A label for displaying the sum of the numbers.
    private Label meanLabel;     // A label for displaying the average.
    private Label standevLabel;  // A label for displaying the standard deviation.
    
    private Label message;  // A message at the top of the program.  It will
                            //   show an error message if the user's input is
                            //   not a legal number.  Otherwise, it just tells
                            //   the user to enter a number and press return.
    
    private Button enterButton;   // A button the user can press to enter a number.
                                  //    This is an alternative to pressing return.
    
    private Button clearButton;   // A button that clears all the data that the
                                  //    user has entered.
    
    private TextField numberInput;  // The input box where the user enters numbers.
    
    private StatCalc stats;  // An object that keeps track of the statistics
                             //   for all the numbers that have been entered.
    
 
    /**
     * Set up the GUI and event handling.
     */
    public void start(Stage stage) {
    
       stats = new StatCalc();
       
       numberInput = new TextField();
       numberInput.setPrefColumnCount(8);  // Makes the text box smaller than the default.
       
       enterButton = new Button("Enter");
       enterButton.setOnAction( e -> doEnter() );
       enterButton.setMaxSize(1000,1000);
       enterButton.setDefaultButton(true); // Pressing return will be equivalent to clicking this button.
       clearButton = new Button("Clear");
       clearButton.setOnAction( e -> doClear() );
       clearButton.setMaxSize(1000,1000);
       
       countLabel =   makeLabel(" Number of Entries:  0");
       sumLabel =     makeLabel(" Sum:                0.0");
       meanLabel =    makeLabel(" Average:            undefined");
       standevLabel = makeLabel(" Standard Deviation: undefined");
       
       message = new Label("Enter a number, press return:");
       message.setFont(Font.font(16));
       message.setTextFill(Color.WHITE);
       
       TilePane inputPanel = new TilePane(3,3,numberInput,enterButton,clearButton);
       inputPanel.setPrefColumns(3);
       TilePane root = new TilePane(3, 3, message, inputPanel, countLabel,
                                               sumLabel, meanLabel, standevLabel);
       root.setPrefColumns(1);
       root.setStyle("-fx-border-color:black; " + 
                           "-fx-border-width:3; -fx-background-color:black");
       
       Scene scene = new Scene(root);
       stage.setScene(scene);
       stage.setTitle("Simple Calc GUI");
       stage.setResizable(false);
       stage.show();
       
    } // end start()

    
    /**
     * A utility routine for creating the labels that are used
     * for display.  This routine is used in the start() method.
     * @param text The text to show on the label.
     */
    private Label makeLabel(String text) {
       Label label = new Label(text);
       label.setMaxSize(1000,1000);
       label.setStyle("-fx-background-color:white; " +
                              "-fx-font-family: monospace; -fx-font-weight: bold");
       return label;
    }   
    
    
    /**
     * Clear all data, restoring the program to its original state.
     * This method is called when the user clicks the Clear button.
     */
    private void doClear() {
        stats = new StatCalc();
        numberInput.setText("");
        showData();
    }
    
    
    /**
     * Respond when the clicks the Enter button by getting a number from
     * the text input box, adding it to the StatCalc and updating the
     * four display labels.  It is possible that an error will occur,
     * in which case an error message is put into the label at the top
     * of the window.  (Because the Enter button has been set to be the
     * default button for the program, this mehod is also invoked when
     * the user presses return.)
     */
    private void doEnter() {
        double num;  // The user's number.
        try {
            num = Double.parseDouble(numberInput.getText());
        }
        catch (NumberFormatException e) {
                // The user's entry is not a legal number.  
                // Put an error message in the message label 
                // and return without entering a number.
            message.setText("\"" + numberInput.getText() + "\" is not a legal number.");
            numberInput.selectAll();
            numberInput.requestFocus();
            return;
        }
        stats.enter(num);
        showData();
    }
    
    
    /**
     *  Show the data from the StatCalc in the four output labels.
     */
    private void showData() {
        countLabel.setText(" Number of Entries:  " + stats.getCount());
        sumLabel.setText(" Sum:                " + stats.getSum());
        if (stats.getCount() == 0) {
               // Don't show any values for mean and standard deviation if
               // no numbers have been added to the data.
            meanLabel.setText(" Average:            undefined");
            standevLabel.setText(" Standard Deviation: undefined");
        }
        else {
            meanLabel.setText(" Average:            " + stats.getMean());
            standevLabel.setText(" Standard Deviation: " + stats.getStandardDeviation());
        }
        
        /* Set the message label back to its normal text, in case it has
          been showing an error message.  For the user's convenience,
          select the text in the TextField and give the input focus
          to the text field.  That way the user can just start typing
          the next number. */

        message.setText("Enter a number, click Enter:");
        numberInput.selectAll();
        numberInput.requestFocus();
    }

 
}  // end StatsCalcGUI
</prog></pre>
</exercise-code>
</exercise>

   
   

<exercise>
<exercise-question><p> Write a program that has a
<classname>TextArea</classname> where the user can enter some text. 
The program should have a
button such that when the user clicks on the button, the program will count the number
of lines in the user's input, the number of words in the user's input, and the
number of characters in the user's input. This information should be displayed
on three <classname>Labels</classname>. Recall that if <code>textInput</code> is a
<classname>TextArea</classname>, then you can get the contents of the <classname>TextArea</classname> by
calling the function <code>textInput.getText()</code>. This function returns a
<classname>String</classname> containing all the text from the text area. The number
of characters is just the length of this <classname>String</classname>. Lines in the
<classname>String</classname> are separated by the new line character, <code>'\n'</code>, so the number of
lines is just the number of new line characters in the <classname>String</classname>, plus
one. Words are a little harder to count. <localref href="control.ex.4"/> 
has some advice about finding the
words in a <classname>String</classname>. Essentially, you want to count the number of
characters that are first characters in words.  Here is a picture of my solution:</p>
<img src="text-count.png" width="342" height="346" alt="TextCounter program showing some text and the numbers of words, lines and chars"
      tex="text-count.eps" texscale="0.6"/>
</exercise-question>
<exercise-discuss><p>The window contains five components. There are several ways to lay them out.
Since the <classname>TextArea</classname> is much larger than the other components,
my program uses a <classname>VBox</classname> as the <code>root</code> of the scene graph, 
which allows each component to have its preferred height.</p>

<p>To get a dark blue border around the edges, I use CSS to add a border to the <classname>VBox</classname>.
To get blue lines between the components, I set the spacing between components in the <classname>VBox</classname>
to be 4, and I make its background dark blue.  I set the background color for the labels to be white;
otherwise, the usual transparent background for the labels would let the blue background of
the <classname>VBox</classname> show through.  I increased the maximum width of the labels to make
them fill the entire width of the <classname>VBox</classname>.  (Otherwise, the blue background would
show through in the space left empty by the labels.)  As for the button, I did not
want to increase its maximum width to fill the available space, but without that, the <classname>VBox</classname>
placed it on the left edge of the available space.  I wanted it to be centered.  The only way I could
think of to do that was to put the button inside another pane, and add that pane to the
<classname>VBox</classname>.  That pane will fill the available space.  I used a <classname>BorderPane</classname>
with the button as its center component; the parameter to the
<classname>BorderPane</classname>constructor becomes the center component in the layout,
and a <classname>BorderPane</classname> centers its center component
within the available space.  You can see how it's is all done in this code from the <code>start()</code>
method:</p>

<pre>textInput = new TextArea();
    textInput.setPrefRowCount(15);
    textInput.setPrefColumnCount(30);

    /* Create the button and a listener to listen for
         clicks on the button. */

    Button countButton = new Button("Process the Text");
    countButton.setOnAction( e -> processInput() );

    /* Create each of the labels, and set their properties. */
    
    String style = 
         "-fx-padding: 5px; -fx-font: bold 14pt serif; -fx-background-color: white";

    lineCountLabel = new Label("  Number of lines:");
    lineCountLabel.setStyle(style);
    lineCountLabel.setMaxWidth(1000);

    wordCountLabel = new Label("  Number of words:");
    wordCountLabel.setStyle(style);
    wordCountLabel.setMaxWidth(1000);

    charCountLabel = new Label("  Number of chars:");
    charCountLabel.setStyle(style);
    charCountLabel.setMaxWidth(1000);

    /* Use a VBox as the root component. */

    VBox root = new VBox( 4, textInput, new BorderPane(countButton),
                              lineCountLabel, wordCountLabel, charCountLabel );
    root.setStyle(
        "-fx-background-color: #009; -fx-border-color: #009; -fx-border-width:3px" );</pre>

<np>The first parameter to the <classname>VBox</classname> constructor is the spacing
between components, and the remaining parameter are added as child nodes of the
<classname>VBox</classname>. Note that both
<code>countButton</code> IS wrapped in a pane which is then added to the
<classname>VBox</classname>.</np>

<p>The <code>ActionEvent</code> handler for the button calls the 
method <code>processInput()</code>.  That method does all the work of the program:
It gets the text from the <code>TextArea</code>, does the
counting, and sets the labels. The only interesting part is counting the words.
Back in <localref href="control.ex.4"/>, words such as
"can't", that contain an apostrophe, were counted as two words. This time
around, let's handle this special case. Two letters with an apostrophe between
them should be counted as part of the same word. The algorithm for counting
words is still</p>

<pre>wordCt = 0
for each character in the string:
   if the character is the first character of a word:
      Add 1 to wordCt</pre>

<np>but testing whether a given character is the first character in a word has
gotten more complicated. To make the test easier, I use a boolean
variable, <code>startOfWord</code>. The value of this variable is set to true if
the character is the start of a word and to false if not. That is, the
algorithm becomes:</np>

<pre>wordCt = 0
for each character in the string:
   Let startOfWord be true if at start of word, false otherwise
   if startOfWord is true:
      Add 1 to wordCt</pre>

<np>The use of a "flag variable" like <code>startOfWord</code> can simplify the
calculation of a complicated boolean condition. The value is computed as a
series of tests:</np>

<pre>boolean startOfWord;  // Is character i the start of a word?
if ( Character.isLetter(text.charAt(i)) == false )
   startOfWord = false;  // No.  It's not a letter.
else if (i == 0)
   startOfWord = true;   // Yes.  It's a letter at start of text.
else if ( Character.isLetter(text.charAt(i-1)) )
   startOfWord = false;  // No.  It's a letter preceded by a letter.
else if ( text.charAt(i-1) == '\'' &amp;&amp; i &gt; 1 
                     &amp;&amp; Character.isLetter(text.charAt(i-2)) )
   startOfWord = false;  // No.  It's a continuation of a word
                         //      after an apostrophe.
else
   startOfWord = true;   // Yes.  It's a letter preceded by
                         //       a non-letter.</pre>

<np>The first test checks whether the character in position <code>i</code> is a
letter. If it is not, then we know that it can't be the start of a word, so
<code>startOfWord</code> is false. If it is a letter, it might be the start of a
word, so we go on to make additional tests. Note that if we get to the other
tests at all, we already know that the character in position <code>i</code> is a
letter. And so on. This style of "cascading tests" is very useful. In each
test, we already have all the information from the previous tests. Note that
the cascade effect works only with "<code>else if</code>". Using "<code>if</code>" in
place of "<code>else if</code>" in the preceding code would not give the right
answer. (You should be sure to understand why this is so.)  You should
also note why the test "<code>if&nbsp;(i&nbsp;==&nbsp;0)</code>"" has to 
be made before the test <code>if&nbsp;(&nbsp;Character.isLetter(text.charAt(i-1))&nbsp;)</code>"&mdash;that's
because <code>text.charAt(i-1)</code> gives an index-out-of-bounds exception if <code>i</code> is zero.</np>

</exercise-discuss>
<exercise-code>
<pre><prog name="TextCounter">
import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;


/**
 * In this program, the user types some text in a TextArea and presses
 * a button.  The program computes and displays the number of lines
 * in the text, the number of words in the text, and the number of
 * characters in the text.  A word is defined to be a sequence of
 * letters, except that an apostrophe with a letter on each side
 * of it is considered to be a letter.  (Thus "can't" is one word,
 * not two.)
 */
public class TextCounter extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------

    private TextArea textInput;     // For the user's input text.

    private Label lineCountLabel;   // For displaying the number of lines.
    private Label wordCountLabel;   // For displaying the number of words.
    private Label charCountLabel;   // For displaying the number of chars.


    /**
     * The constructor creates components and lays out the window.
     */ 
    public void start(Stage stage) {

        textInput = new TextArea();
        textInput.setPrefRowCount(15);
        textInput.setPrefColumnCount(30);

        /* Create the button and a listener to listen for
             clicks on the button. */

        Button countButton = new Button("Process the Text");
        countButton.setOnAction( e -> processInput() );

        /* Create each of the labels, and set their properties. */
        
        String style = "-fx-padding: 5px; -fx-font: bold 14pt serif; -fx-background-color: white";

        lineCountLabel = new Label("  Number of lines:");
        lineCountLabel.setStyle(style);
        lineCountLabel.setMaxWidth(1000);

        wordCountLabel = new Label("  Number of words:");
        wordCountLabel.setStyle(style);
        wordCountLabel.setMaxWidth(1000);

        charCountLabel = new Label("  Number of chars:");
        charCountLabel.setStyle(style);
        charCountLabel.setMaxWidth(1000);

        /* Use a VBox as the root component. */

        VBox root = new VBox( 4, textInput, new BorderPane(countButton),
                                  lineCountLabel, wordCountLabel, charCountLabel );
        root.setStyle("-fx-background-color: #009; -fx-border-color: #009; -fx-border-width:3px");
        
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Line/Word/Char Counter");
        stage.setResizable(false);
        stage.show();

    } // end constructor


    /**
     * This will be called when the user clicks the "Process the Text" button.
     * It gets the text from the text area, counts the number of chars, words, 
     * and lines that it contains, and sets the labels to display the results.
     */
    public void processInput() {

        String text;  // The user's input from the text area.

        int charCt, wordCt, lineCt;  // Char, word, and line counts.

        text = textInput.getText();

        charCt = text.length();  // The number of characters in the
                                 //    text is just its length.

        /* Compute the wordCt by counting the number of characters
              in the text that lie at the beginning of a word.  The
              beginning of a word is a letter such that the preceding
              character is not a letter.  This is complicated by two
              things:  If the letter is the first character in the
              text, then it is the beginning of a word.  If the letter
              is preceded by an apostrophe, and the apostrophe is
              preceded by a letter, than its not the first character
              in a word.
         */

        wordCt = 0;
        for (int i = 0; i &lt; charCt; i++) {
            boolean startOfWord;  // Is character i the start of a word?
            if ( Character.isLetter(text.charAt(i)) == false )
                startOfWord = false;  // No.  It's not a letter.
            else if (i == 0)
                startOfWord = true;   // Yes.  It's a letter at start of text.
            else if ( Character.isLetter(text.charAt(i-1)) )
                startOfWord = false;  // No.  It's a letter preceded by a letter.
            else if ( text.charAt(i-1) == '\'' &amp;&amp; i > 1 
                    &amp;&amp; Character.isLetter(text.charAt(i-2)) )
                startOfWord = false;  // No.  It's a continuation of a word
                                      //      after an apostrophe.
            else
                startOfWord = true;   // Yes.  It's a letter preceded by
                                      //       a non-letter.
            if (startOfWord)
                wordCt++;
        }

        /* The number of lines is just one plus the number of times the
              end of line character, '\n', occurs in the text. */

        lineCt = 1;
        for (int i = 0; i &lt; charCt; i++) {
            if (text.charAt(i) == '\n')
                lineCt++;
        }

        /* Set the labels to display the data. */

        lineCountLabel.setText("  Number of lines:  " + lineCt);
        wordCountLabel.setText("  Number of words:  " + wordCt);
        charCountLabel.setText("  Number of chars:  " + charCt);

    }  // end processInput()


} // end class TextCounter
</prog></pre>
</exercise-code>
</exercise>
   
   
   
<exercise>
<exercise-question><p> A <newword>polygon</newword> 
is a geometric figure made up of a sequence of
connected line segments. The points where the line segments meet are called the
<newword>vertices</newword> of the polygon. <localref href="GUI1.2.4"/> has 
a list of shape-drawing methods in a <classname>GraphicsContext</classname>.
Among them are methods for stroking and for filling polygons:
<code>g.strokePolygon(xcoords,ycoords,n)</code> and
<code>g.fillPolygon(xcoords,ycoords,n)</code>, For these commands,
the coordinates of the vertices of the polygon are stored in arrays
<code>xcoords</code> and <code>ycoords</code> of type <atype>double[]</atype>,
and the number of vertices of the polygon is given by the third parameter, <code>n</code>.
Note that it is OK for the sides of a polygon to cross each other,
but the interior of a polygon with self-intersections might not be exactly what
you expect.</p>
<p>Write a program that lets the user draw polygons.  As the user clicks a
sequence of points in a <classname>Canvas</classname>, count the points and store their x- and y-coordinates in two
arrays. These points will be the vertices of the polygon. As the user is creating
the polygon, you should just connect all the points with line segments.
When the user clicks near the starting point, draw the complete polygon. Draw
it with a red interior and a black border.  Once the user has completed a
polygon, the next click should clear the data and start a new polygon from scratch.</p>
<p>Here is a picture of my solution after the user has drawn a fairly complex polygon:</p>
<img src="polygon.png" width="300" height="300" alt="screen shot of the solution"
       tex="polygon.eps" texscale="0.5"/>
</exercise-question>
<exercise-discuss>
<p>This is an exercise in using arrays, but it is also an exercise in using instance
variables to record the state of the program.  When the user clicks the canvas,
my program completely redraws the canvas.  (This is not really necessary, but it's
often the easiest way to organize a drawing program, since it's the easiest way
to ensure that the picture always agrees perfectly with the state of the program.)
The <code>draw()</code> method that draws the canvas
needs enough state information in the instance variables 
to correctly draw the picture.  Obviously, that includes
the coordinate arrays and the number of points that have been stored in the arrays.
But the picture is different depending on whether or not the user has completed
the polygon.  If the polygon is complete, the picture shows a polygon; if not,
the picture shows line segments connecting each point to the next.  We need to 
record that basic distinction as part of the state.  We can do that using a
boolean instance variable, <code>complete</code>, which is true when a complete polygon should
be drawn and <code>false</code> while the polygon is under construction.
So, here are the necessary instance variables:</p>

<pre>double[] xCoord, yCoord;  // Arrays to hold the coordinates for up to 500 points.
int pointCt;              // Number of points in the arrays.
boolean complete;         // Set to true when a polygon is complete.</pre>

<np>The arrays <code>xCoord</code> and <code>yCoord</code> are examples of partially
full arrays (<localref href="control.7a.4"/>), although there is only one counter variable that applies to both arrays.</np>

<p>Given these instance variables, the <code>draw()</code> method can
be written.  To make the picture look nicer, I decided to use wide lines.
There is also a question about what to draw when there is only one point.  It's nice
if the user can see that the point has been added to the data, but one point is not
enough to draw a line or polygon.  I decided to draw a small square at the first point,
just to make it visible and noticeable.  This also helps the user to find the first point when he is 
trying to click on it to complete the polygon.  The fill color of the polygon
is given by a global constant, <code>POLYGON_COLOR</code>.
</p>

<pre>private void draw() {
    GraphicsContext g = canvas.getGraphicsContext2D();
    g.setFill(Color.WHITE);
    g.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
    if (pointCt == 0)
        return;
    g.setLineWidth(2);
    g.setStroke(Color.BLACK);
    if (complete) { // draw a polygon
        g.setFill(POLYGON_COLOR);
        g.fillPolygon(xCoord, yCoord, pointCt);
        g.strokePolygon(xCoord, yCoord, pointCt);
    }
    else { // show the lines the user has drawn so far
        g.setFill(Color.BLACK);
        g.fillRect(xCoord[0]-2, yCoord[0]-2, 4, 4);  // small square marks first point
        for (int i = 0; i &lt; pointCt - 1; i++) {
            g.strokeLine( xCoord[i], yCoord[i], xCoord[i+1], yCoord[i+1]);
        }
    }
}</pre>


<p>The rest of the program logic is in a <code>mousePressed()</code> routine that
is called when the user presses the mouse on the canvas.
In that method, state variables have to change in response to the user's actions.
It requires some care to do things in the right order.  The three things that
can happen are that the user starts a new polygon, the user completes the current
polygon, or the user just adds a point to the current polygon.  The conditions should
be tested in that order:</p>

<pre>if the current polygon is complete
    start a new polygon with the point where the user clicked
else if the user clicked near the starting point
    complete the current polygon
else
    add the point that the user clicked to the data
call draw() to make the change visible</pre>

<p>Actually, in my solution, I decided to add another case: The polygon 
can also be completed by right-clicking, or&mdash;to be very safe&mdash;if the number of points
has reached 500.  Also, there is a <b>bug</b> in the algorithm as
stated, where it tests "if the user clicked near the first point". This test
doesn't make sense unless there actually is a first point, that is unless
<code>pointCt</code> is greater than zero. The test should really read "if
<code>pointCt</code> &gt; 0 and if the user clicked near
<code>(xCoord[0],yCoord[0])</code>."</p>

<p>To complete a polygon just means setting the value of the variable <code>complete</code>
to true.  When <code>draw()</code> is called, the data will be displayed as a polygon.
When a new polygon is started, the value of the variable <code>complete</code>
has to be reset to false.  Also, the first point on the polygon has to be put into
the coordinate arrays, and <code>pointCt</code> must be set to&nbsp;1 to indicate that
there is only one point in the data. This much is pretty straightforward to implement.</p>

<p>The only thing in the algorithm that still needs implementing is to test
whether the user clicks "near the starting point". The starting point has
coordinates <code>(xCoord[0],yCoord[0])</code> and the point where the user clicked
has coordinates <code>(evt.getX(),evt.getY())</code>. In my program, I check whether
the <code>x</code>-coordinates of these points are three pixels or less apart and the
<code>y</code>-coordinates are also two pixels or less apart. This is done by
checking whether "<code>Math.abs(xCoord[0]&nbsp;-&nbsp;evt.getX()) &lt;=&nbsp;3 &amp;&amp;
Math.abs(yCoord[0]&nbsp;-&nbsp;evt.getY()) &lt;=&nbsp;3</code>".</p>

</exercise-discuss>
<exercise-code>
<pre><prog name="SimplePolygons">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.layout.StackPane;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;

/**
 * This program lets the user draw filled polygons.
 * The user inputs a polygon by clicking a series of points.
 * The points are connected with lines from each point to the
 * next Clicking near the starting point (within 3 pixels) or
 * right-clicking will complete the polygon, so the user can 
 * begin a new one.  As soon as the user begins drawing a new 
 * polygon, the old one is discarded.
 */
public class SimplePolygons extends Application {
     
    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------

    private Canvas canvas;

    /* Variables for implementing polygon input. */

    private double[] xCoord, yCoord;    // Arrays containing the points of 
                                        //   the polygon.  Up to 500 points 
                                        //   are allowed.

    private int pointCt;  // The number of points that have been input.

    private boolean complete;   // Set to true when the polygon is complete.
                                // When this is false, only a series of lines are drawn.
                                // When it is true, a filled polygon is drawn.

    private final static Color POLYGON_COLOR = Color.RED;  
                                // Color that is used to draw the polygons.  


    /**
     * Set up the GUI, and install a mouse hander its data.
     */
    public void start (Stage stage) {
        
        xCoord = new double[500];  // create arrays to hold the polygon's points
        yCoord = new double[500];
        pointCt = 0;
        
        canvas = new Canvas(400,400);
        draw();
        canvas.setOnMousePressed( e -> mousePressed(e) );
        
        StackPane root = new StackPane(canvas);
        root.setStyle("-fx-border-color: black");
        
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Polygons");
        stage.setResizable(false);
        stage.show();
        
    }

    
    /**
     * Fill the canvas with white.  If the polygon is complete, draw it.
     * If not, draw the lines that the user has input so far.  (If only
     * one point has been input, it will still be visible as a small dot.)
     */
    private void draw() {
        GraphicsContext g = canvas.getGraphicsContext2D();
        g.setFill(Color.WHITE);
        g.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
        if (pointCt == 0)
            return;
        g.setLineWidth(2);
        g.setStroke(Color.BLACK);
        if (complete) { // draw a polygon
            g.setFill(POLYGON_COLOR);
            g.fillPolygon(xCoord, yCoord, pointCt);
            g.strokePolygon(xCoord, yCoord, pointCt);
        }
        else { // show the lines the user has drawn so far
            g.setFill(Color.BLACK);
            g.fillRect(xCoord[0]-2, yCoord[0]-2, 4, 4);  // small square marks first point
            for (int i = 0; i &lt; pointCt - 1; i++) {
                g.strokeLine( xCoord[i], yCoord[i], xCoord[i+1], yCoord[i+1]);
            }
        }
    }


    /**
     * Processes a mouse click.
     */
    private void mousePressed(MouseEvent evt) { 

        if (complete) {
                // Start a new polygon at the point that was clicked.
            complete = false;
            xCoord[0] = evt.getX();
            yCoord[0] = evt.getY();
            pointCt = 1;
        }
        else if ( pointCt > 0 &amp;&amp; pointCt > 0 &amp;&amp; (Math.abs(xCoord[0] - evt.getX()) &lt;= 3)
                   &amp;&amp; (Math.abs(yCoord[0] - evt.getY()) &lt;= 3) ) {
                // User has clicked near the starting point.
                // The polygon is complete.
            complete = true;
        }
        else if (evt.getButton() == MouseButton.SECONDARY || pointCt == 500) {
                // The polygon is complete.
            complete = true;
        }
        else {
                // Add the point where the user clicked to the list of
                // points in the polygon, and draw a line between the
                // previous point and the current point.  A line can
                // only be drawn if there are at least two points.
            xCoord[pointCt] = evt.getX();
            yCoord[pointCt] = evt.getY();
            pointCt++;
        }
        draw();  // in all cases, redraw the picture.
    } // end mousePressed()


}  // end class SimplePolygons
</prog></pre>
</exercise-code>
</exercise>
   



<exercise id="GUI1.ex.9">
<exercise-question><p>Write a GUI Blackjack program
that lets the user play a game of Blackjack, with the computer as the dealer.
The program should draw the user's cards and the dealer's cards, just as was
done for the graphical HighLow card game in  <localref href="GUI1.6.1"/>.
You can use the source code for that game, <sourceref href="HighLowGUI.java"/>, for some ideas about how to
write your Blackjack game. The structures of the HighLow program and the
Blackjack program are very similar. You will certainly want to use the
<code>drawCard()</code> method from the HighLow program.</p>

<p>You can find a description of the game of Blackjack in <localref href="OOP.ex.5"/>. 
Add the following rule to that
description: If a player takes five cards without going over 21, that player
wins immediately. This rule is used in some casinos. For your program, it means
that you only have to allow room for five cards. You should make the
canvas just wide enough to show five cards, and tall enough to
show both the user's hand and the dealer's hand.</p>

<p>Note that the design of a GUI Blackjack game is very different from the
design of the text-oriented program that you wrote for <localref href="OOP.ex.5"/>. The user
should play the game by clicking on "Hit" and "Stand" buttons. There should be
a "New Game" button that can be used to start another game after one game ends.
You have to decide what happens when each of these buttons is pressed. You
don't have much chance of getting this right unless you think in terms of the
states that the game can be in and how the state can change.</p>

<p>Your program will need the classes defined in 
<sourceref href="Card.java"/>,
<sourceref href="Hand.java"/>,
<sourceref href="Deck.java"/>, and
<sourceref href="BlackjackHand.java"/>.  It will also need the images file
<sourceref href="cards.png"/>, which contains pictures of the cards.</p>

<p>The <localref href="GUI1.ex.10">next exercise</localref> has a picture of a Blackjack game that
you can use a guide, except that the version for this exercise does not allow betting.
(Some aesthetic changes to the GUI were made in that Blackjack program, compared to the
HighLow program.)</p>

</exercise-question>
<exercise-discuss><p>The <code>start()</code> method for this exercise can be very similar to that in
the <sourceref href="HighLowGUI.java">HighLow</sourceref> game.  Aside from some
tweaks to appearance, the canvas has to be bigger and the text of the buttons
just has to be changed from "Higher" and "Lower" to "Hit" and "Stand".
(The tweaks are discussed in the solution to the <localref href="GUI1.ex.10">next exercise</localref>;
they are not really needed in this version of Blackjack.)</p>

<p>In the HighLow game, there is one "hand," which holds all the cards that
have been dealt. Blackjack is a two-player game, so there are two hands, one
for the player and one for the dealer. These hands are of type
<code>BlackjackHand</code>. So, we need instance variables</p>

<pre>BlackjackHand dealerHand;   // The dealer's cards.
BlackjackHand playerHand;   // The user's cards.</pre>

<p>We also need a <code>deck</code> of cards and a boolean-valued instance variable,
<code>gameInProgress</code>, to keep track of the two basic states of the game: Is
a game in progress, or are we between games? Finally, there is a
<code>message</code> variable, which holds the string that is shown at the bottom
of the game board.</p>

<p>There is a <code>drawBoard()</code> method that completely redraws the
canvas, based on the current state of the game.  It uses the information in the
<code>dealerHand</code>, <code>playerHand</code>, <code>message</code>, and
<code>gameInProgress</code> variables. The reason it needs to look at the
<code>gameInProgress</code> variable is that when a game is in progress, one of the
dealer's cards is drawn face down, so the user can't see it. Once the game is
over, the card is drawn face up so the user can see what the dealer was
holding. Note that there is no point in the program where I say, "turn the
dealer's first card face up"! It happens automatically because the state of the
game changes, and the <code>drawBoard()</code> method checks the state when it
draws the canvas. If the game is over, the card is face up. If the game is in
progress, the card is face down. This is nice
example of state-machine thinking.</p>

<p>Note that writing the <code>drawBoard()</code> method required some
calculation. The cards are 79 pixels wide and 123 pixels tall. Horizontally,
there is a gap of 20 pixels between cards, and there are gaps of 20 pixels
between the cards and the left and right edges. The total width needed for the
canvas, 515, allows for five 79-pixel cards and six 20-pixel gaps:
 5*79 + 6*20  = 515.  The <code>N</code>-th card,
counting from 0, has its left edge at <code>20+99*N</code>. It might be easier to
see this as <code>20+79*N+20*N</code>, 20 pixels on the left plus <code>N</code>
79-pixel cards, plus a 20-pixel gap after each of the <code>N</code> cards. The vertical
placement of the cards and strings was more experimental.  
I placed the dealer's hand at y-coordinate 40 and the player's hand at y-coordinate 206,
leaving space to draw the strings "Dealer's Cards" and "Your Cards" above the hands.
The message to the user is placed with its baseline 20 pixels above the bottom
of the canvas, and I adjusted the height of the canvas to get the spacing right.</p>

<p>In this GUI version of Blackjack, things happen when the user clicks the
"Hit", "Stand", and "New Game" buttons. The program handles these events by
calling the methods <code>doHit()</code>, <code>doStand()</code>, and
<code>doNewGame()</code>. Each of these methods has responsibility for one part of
the game of Blackjack. Note that each method starts by checking the state of
the game to make sure that it is legal to call the routine at this time. If
<code>gameInProgress</code> is true, the user can legally click "Hit" or "Stand".
If <code>gameInProgress</code> is false, the user can legally click "New Game". If
the user made an illegal move, an error message is stored in the
<code>message</code> variable, and <code>drawBoard()</code> is called so the user will
see the new message. This is similar to the way the three buttons in HighLowGUI
are handled.</p>

<p>The <code>doNewGame()</code> routine has to set up a new game. This means
creating the deck and hands, shuffling the deck and dealing two cards into each
hand. At this point, the first time I wrote the game, I just set
<code>gameInProgress</code> to true, to record the fact that the state of the game
has changed. Later, I realized that the <code>doNewGame()</code> routine also has
to check whether one of the players has Blackjack, since there is really no
other place where this can be done. It has to happen immediately after the first two
cards are dealt.  If one of the players has Blackjack, the
game is over as soon as it starts, so <code>gameIsProgress</code> has to be false, and the only action
that the user can take at that point is to click the "New Game" button again.
(Note that the <code>doNewGame()</code> routine is also called by the <code>start()</code> method.
This sets up the first game, so the user doesn't have to click on the "New Game"
button to start the first game.)</p>

<p>When the user clicks "Hit", if the game is in progress, we deal a card into
the user's hand. At this point, the state of the game might have changed. If
the user has over 21, the user loses and the game is over. If the user has
taken 5 cards without going over 21, the user wins and the game is over. In
either of these cases, the value of the state variable <code>gameInProgress</code>
becomes <code>false</code>. Otherwise, <code>gameInProgress</code> retains the value
<code>true</code>, and the game will continue. Since <code>gameInProgress</code> is
<code>true</code>, the user still has the choice of clicking "Hit" or "Stand".
(Note that there is no loop in the program that says "while the user continues
to hit." The progress of the game is driven by events.)</p>

<p>Finally, when the user clicks "Stand", the game is definitely over, so
<code>gameInProgress</code> is set to false. However, before the game can end, the
dealer gets to draw cards and a winner is determined. This all has to be done
in the <code>doStand()</code> routine. Then, the canvas is redrawn to show the
final state of the game.</p>
</exercise-discuss>
<exercise-code>
<pre>
<prog name="BlackjackGUI">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.image.Image;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

/**
 * In this program, the user plays a game of Blackjack.  The
 * computer acts as the dealer.  The user plays by clicking
 * "Hit!" and "Stand!" buttons.
 *
 * This program depends on the following classes:  Card, Hand,
 * BlackjackHand, Deck.  It also requires the image resource
 * file cards.png.
 */
public class BlackjackGUI extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------

    private Deck deck;         // A deck of cards to be used in the game.

    private BlackjackHand dealerHand;   // Hand containing the dealer's cards.
    private BlackjackHand playerHand;   // Hand containing the user's cards.

    private String message; // A message drawn on the canvas, which changes
                            //    to reflect the state of the game.

    private boolean gameInProgress; // Set to true when a game begins and to false
                                    //   when the game ends.

    private Canvas board;     // The canvas were cards and messages are displayed.
    
    private Image cardImages;  // The image that contains all the cards in a deck.
    
    
    /**
     * The start() method() sets up the GUI and event handling.
     */
    public void start(Stage stage) {

        cardImages = new Image("cards.png");

        board = new Canvas(515, 390); 
                         // space for 5 cards across and 2 cards down, 
                         // with 20-pixel spaces between cards,
                         // plus space for messages

        Button hitButton = new Button( "Hit!" );
        hitButton.setOnAction( e -> doHit() );
        Button standButton = new Button( "Stand!" );
        standButton.setOnAction( e -> doStand() );
        Button newGameButton = new Button( "New Game" );
        newGameButton.setOnAction( e -> doNewGame() );

        HBox buttonBar = new HBox(6,hitButton,standButton,newGameButton);
        buttonBar.setStyle("-fx-border-color: darkred; -fx-border-width: 3px 0 0 0;" 
                + "-fx-padding: 8px; -fx-background-color:beige");
        buttonBar.setAlignment(Pos.CENTER);

        BorderPane root = new BorderPane();
        root.setStyle("-fx-border-color: darkred; -fx-border-width: 3px");
        root.setCenter(board);
        root.setBottom(buttonBar);
        
        doNewGame(); // Start the first game.
        
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Blackjack");
        stage.setResizable(false);
        stage.show();

    }  // end start()

    
    /**
     * This method is called when the user clicks the "Hit!" button.  First 
     * check that a game is actually in progress.  If not, give  an error 
     * message and exit.  Otherwise, give the user a card.  The game can end 
     * at this point if the user goes over 21 or if the user has taken 5 cards 
     * without going over 21.
     */
    void doHit() {
        if (gameInProgress == false) {
            message = "Click \"New Game\" to start a new game.";
            drawBoard();
            return;
        }
        playerHand.addCard( deck.dealCard() );
        if ( playerHand.getBlackjackValue() > 21 ) {
            message = "You've busted!  Sorry, you lose.";
            gameInProgress = false;
        }
        else if (playerHand.getCardCount() == 5) {
            message = "You win by taking 5 cards without going over 21.";
            gameInProgress = false;
        }
        else {
            message = "You have " + playerHand.getBlackjackValue() + ".  Hit or Stand?";
        }
        drawBoard();
    }


    /**
     * This method is called when the user clicks the "Stand!" button.
     * Check whether a game is actually in progress.  If it is, the game 
     * ends.  The dealer takes cards until either the dealer has 5 cards 
     * or more than 16 points.  Then the  winner of the game is determined. 
     */
    void doStand() {
        if (gameInProgress == false) {
            message = "Click \"New Game\" to start a new game.";
            drawBoard();
            return;
        }
        gameInProgress = false;
        while (dealerHand.getBlackjackValue() &lt;= 16 &amp;&amp; dealerHand.getCardCount() &lt; 5)
            dealerHand.addCard( deck.dealCard() );
        if (dealerHand.getBlackjackValue() > 21)
            message = "You win!  Dealer has busted with " + dealerHand.getBlackjackValue() + ".";
        else if (dealerHand.getCardCount() == 5)
            message = "Sorry, you lose.  Dealer took 5 cards without going over 21.";
        else if (dealerHand.getBlackjackValue() > playerHand.getBlackjackValue())
            message = "Sorry, you lose, " + dealerHand.getBlackjackValue()
                              + " to " + playerHand.getBlackjackValue() + ".";
        else if (dealerHand.getBlackjackValue() == playerHand.getBlackjackValue())
            message = "Sorry, you lose.  Dealer wins on a tie.";
        else
            message = "You win, " + playerHand.getBlackjackValue()
                              + " to " + dealerHand.getBlackjackValue() + "!";
        drawBoard();
    }


    /**
     * Called by the constructor, and called by doNewGame().  Start a new game.  
     * Deal two cards to each player.  The game might end right then  if one 
     * of the players had blackjack.  Otherwise, gameInProgress is set to true 
     * and the game begins.
     */
    void doNewGame() {
        if (gameInProgress) {
                // If the current game is not over, it is an error to try
                // to start a new game.
            message = "You still have to finish this game!";
            drawBoard();
            return;
        }
        deck = new Deck();   // Create the deck and hands to use for this game.
        dealerHand = new BlackjackHand();
        playerHand = new BlackjackHand();
        deck.shuffle();
        dealerHand.addCard( deck.dealCard() );  // Deal two cards to each player.
        dealerHand.addCard( deck.dealCard() );
        playerHand.addCard( deck.dealCard() );
        playerHand.addCard( deck.dealCard() );
        if (dealerHand.getBlackjackValue() == 21) {
            message = "Sorry, you lose.  Dealer has Blackjack.";
            gameInProgress = false;
        }
        else if (playerHand.getBlackjackValue() == 21) {
            message = "You win!  You have Blackjack.";
            gameInProgress = false;
        }
        else {
            message = "You have " + playerHand.getBlackjackValue() + ".  Hit or stand?";
            gameInProgress = true;
        }
        drawBoard();
    }  // end newGame();


    /**
     * The drawBoard() method shows the message at the bottom of the
     * canvas, and it draws all of the dealt cards spread out
     * across the canvas.
     */
    public void drawBoard() {

        GraphicsContext g = board.getGraphicsContext2D();
        g.setFill( Color.DARKGREEN);
        g.fillRect(0,0,board.getWidth(),board.getHeight());
        
        g.setFont( Font.font(16) );
        g.setFill( Color.rgb(220,255,220) );
        
        // Draw the message at the bottom of the canvas.
        
        g.fillText(message, 20, board.getHeight() - 20);

        // Draw labels for the two sets of cards.

        g.fillText("Dealer's Cards:", 20, 27);
        g.fillText("Your Cards:", 20, 190);

        // Draw dealer's cards.  Draw first card face down if
        // the game is still in progress,  It will be revealed
        // when the game ends.

        if (gameInProgress)
            drawCard(g, null, 20, 40);
        else
            drawCard(g, dealerHand.getCard(0), 20, 40);
        for (int i = 1; i &lt; dealerHand.getCardCount(); i++)
            drawCard(g, dealerHand.getCard(i), 20 + i * 99, 40);

        // Draw the user's cards.

        for (int i = 0; i &lt; playerHand.getCardCount(); i++)
            drawCard(g, playerHand.getCard(i), 20 + i * 99, 206);

    }  // end drawBoard();


    /**
     * Draws a card with top-left corner at (x,y).  If card is null,
     * then a face-down card is drawn.  The cards images are from 
     * the file cards.png; this program will fail without it.
     */
    private void drawCard(GraphicsContext g, Card card, int x, int y) {
        int cardRow, cardCol;
        if (card == null) {  
            cardRow = 4;   // row and column of a face down card
            cardCol = 2;
        }
        else {
            cardRow = 3 - card.getSuit();
            cardCol = card.getValue() - 1;
        }
        double sx,sy;  // top left corner of source rect for card in cardImages
        sx = 79 * cardCol;
        sy = 123 * cardRow;
        g.drawImage( cardImages, sx,sy,79,123, x,y,79,123 );
    } // end drawCard()


} // end class BlackjackGUI
</prog></pre>
</exercise-code>
</exercise>
   
<exercise id="GUI1.ex.10">
<exercise-question><p>In the Blackjack game 
from <localref href="GUI1.ex.9"/>, the user can click on the "Hit",
"Stand", and "NewGame" buttons even when it doesn't make sense to do so. It
would be better if the buttons were disabled at the appropriate times. The "New
Game" button should be disabled when there is a game in progress. The "Hit" and
"Stand" buttons should be disabled when there is <b>not</b> a game in progress. The
instance variable <code>gameInProgress</code> tells whether or not a game is in
progress, so you just have to make sure that the buttons are properly enabled
and disabled whenever this variable changes value. 
I strongly advise writing a method that can be called every time it is
necessary to set the value of the <code>gameInProgress</code> variable. That
method can take full responsibility for enabling and disabling the buttons
(as long as it is used consistently).
Recall that if <code>bttn</code> is a variable of type <code>Button</code>, then
<code>bttn.setDisable(true)</code> disables the button and
<code>bttn.setDisable(false)</code> enables the button.</p>

<p>As a second (and more difficult) improvement, make it possible
for the user to place bets on the Blackjack game. When the program starts, give
the user $100. Add a <classname>TextField</classname> to the strip of controls along the
bottom of the panel. The user enters the bet in this <classname>TextField</classname>.
When the game begins, check the amount of the bet. You should do this when the
game begins, not when it ends, because several errors can occur: The contents
of the <classname>TextField</classname> might not be a legal number, the bet that the user
places might be more money than the user has, or the bet might be &lt;= 0. You
should detect these errors and show an error message instead of starting the
game. The user's bet should be an integral number of dollars.</p>

<p>It would be a good idea to make the <classname>JextField</classname> uneditable while the
game is in progress. If <code>betInput</code> is the <classname>TextField</classname>, you can
make it editable and uneditable by the user with the commands
<code>betInput.setEditable(true)</code> and <code>betInput.setEditable(false)</code>.</p>

<p>In the <code>drawBoard()</code> method, you should include commands to
display the amount of money that the user has left.</p>

<p>There is one other thing to think about: Ideally, the program should not start a new
game when it is first created. The user should have a chance to set a bet
amount before the game starts. So, in the <code>start()</code> method, you
should not call <code>doNewGame()</code>. You might want to display a message such
as "Welcome to Blackjack" before the first game starts.</p>
   
<p>Here is a picture of my program:</p>
<img src="blackjack-gui.png" width="417" height="373" alt="a blackjack game in progress"
       tex="blackjack-gui.eps" texscale="0.8"/>
</exercise-question>
<exercise-discuss>
<p>First, I want to briefly discuss the changes that I made to the appearance of
the user interface, compared to the program, <sourceref href="HighLowGUI.java"/>, on
which the Blackjack programs are based.</p>
<p>For Blackjack, I added a dark red border around the <classname>BorderPane</classname>
that serves as the <code>root</code> node of the scene graph.  I also wanted
a red line between the canvas and the <code>buttonBar</code> that is in the
bottom position.  For that, I added a border to <code>buttonBar</code>, but only
on its top edge; the border width on the other three sides of the <code>buttonBar</code>
is set to zero.</p>
<p>In <classname>HighLowGUI</classname>, the three buttons are all the same size,
and they fill the <code>buttonBar</code>.  In the final version of Blackjack,
the button bar contains five components, and it didn't look good to make them
all the same width.  Furthermore, I wanted to give a nicer background color (beige)
to the button bar, and it needed some padding to add some space between the
components and the edges of the button bar.  Finally, to put the components that
it contains in the center of the button bar rather than at the left end,
the alignment property of the button bar is set to <code>Pos.CENTER</code>.
So, in my Blackjack program,
the root node and button bar are created and configured in the <code>start()</code>
method as follows:</p>

<pre>HBox buttonBar = new HBox(6, hitButton, standButton, newGameButton,
        new Label(" Your bet:"), betInput);
buttonBar.setStyle("-fx-border-color: darkred; -fx-border-width: 3px 0 0 0;" 
        + "-fx-padding: 8px; -fx-background-color:beige");
buttonBar.setAlignment(Pos.CENTER);

BorderPane root = new BorderPane();
root.setStyle("-fx-border-color: darkred; -fx-border-width: 3px");
root.setCenter(board);
root.setBottom(buttonBar);</pre>

<np>All of these details might seem very complicated, but it does get easier
with practice!</np>

<break/>

<p>The buttons in the program must be enabled and
disabled whenever the value of the variable <code>gameInProgress</code> changes. 
At the same time, the text field should be made editable or non-editable.  As
recommended in the exercise, I wrote a method for changing the value of 
<code>gameInProgress</code>. This method also sets the buttons and text field to reflect the
state of the program, which allows the state of the buttons and text field
to be controlled in one location:</p>

<pre>/**
 * This method is called whenever the value of the gameInProgress
 * property has to be changed.  In addition to setting the value
 * of the gameInProgress variable, it also enables and disables
 * the buttons and text input box to reflect the state of the game.
 * @param inProgress The new value of gameInProgress.
 */
private void setGameInProgress( boolean inProgress ) {
    gameInProgress = inProgress;
    if (gameInProgress) {
        hitButton.setDisable(false);
        standButton.setDisable(false);
        newGameButton.setDisable(true);
        betInput.setEditable(false);
        hitButton.requestFocus();
    }
    else {
        hitButton.setDisable(true);
        standButton.setDisable(true);
        newGameButton.setDisable(false);
        betInput.setEditable(true);
        newGameButton.requestFocus();
    }
}</pre>

<np>Note that this method requests that the "Hit" button get focus of there is a game in progress,
and that the "New Game" button get focus if not.  When a button has the input focus, the user
can trigger the button by pressing Return.  The idea is to give the input focus to
the button that represents the user's most likely next action.  This makes it possible
for the user to play the game largely by hitting the space bar, instead of using the
mouse.  (In fact, since the TAB key can be used to move the input focus, the user can
play the game without ever touching the mouse.)</np>

<p>Once <code>setGameInProgress()</code> is available, then any line in the old program that said
"<code>gameInProgress&nbsp;=&nbsp;false;</code>" should be changed to
"<code>setGameInProgress(false);</code>". And any line that said
"<code>gameInProgress&nbsp;=&nbsp;true;</code>" should be changed to
"<code>setGameInProgress(true);</code>". In this way, we can be sure that the
buttons are always properly enabled and disabled.  Note that I added a 
call to <code>setGameInProgress(false)</code> to the <code>start()</code> method
as well, to make sure the buttons and textfield are properly configured at the
beginning of the program.  Since the new program does not immediately start
the first game, <code>gameInProgress</code> should be set to <code>false</code>
in the <code>start()</code> method. (Also, the call to <code>doNewGame()</code>
in the <code>start()</code> method was deleted).</p>

<p>You should understand why I use a subroutine to set the value of
<code>gameInProgress</code>. Every time <code>gameInProgress</code> changes, each of
the buttons has to be enabled or disabled and the text field has
to be made editable or uneditable. That's four extra lines of code
each time the program says <code>gameInProgress&nbsp;=&nbsp;true</code> 
or <code>gameInProgress&nbsp;=&nbsp;false</code>. We can avoid some extra typing by calling the subroutine.
Furthermore, if we always call the subroutine to set the value of
<code>gameInProgress</code>, we can be sure that the states of the buttons and text field will
always be set correctly to match the value of <code>gameInProgress</code>.
</p>
   
<p>The changes that I've discussed so far are enough to complete the first part
of the exercise, enabling and disabling the buttons.  We still have to implement
betting.</p>
   
<break/>

<p>I added several new instance variables to the program to implement betting:
a <classname>TextField</classname>, <code>betInput</code>, where the user
inputs the bet amount; an <ptype>int</ptype> variable, <code>usersMoney</code>,
to hold the number of dollars that the user currently has; and another
<ptype>int</ptype> variable, <code>betAmount</code>, to store the amount
of the user's bet while a game is in progress.</p>
   
<p>The <classname>TextField</classname> for the user's input
is created with the command "<code>betInput = new
TextField("10");</code>". The parameter in the constructor specifies the
initial content of the text input box. This is meant as a reasonable value for
the bet, but the user can change it if she wants to.  The number of preferred
columns for the textfield is reduced by calling
<code>betInput.setPrefColumnCount(5)</code>. The preferred size of the <classname>TextField</classname> is computed
based on the preferred column count.  Without this change, the textfield would be
too big for this program.</p>

<p>The value of <code>usersMoney</code> is
initialized to 100 when it is declared. Any time a game ends, if the user wins,
then <code>betAmount</code> is added to the user's money, and if the user loses, then
<code>betAmount</code> is subtracted from the user's money. We have to decide what
happens if the user runs out of money. One possibility would be to shut the
game down, but that seems drastic since it's only play money anyway. So, if the
value of <code>usersMoney</code> drops to zero, I give the user another $100 by
setting the value of <code>usersMoney</code> back to 100; this is done in
<code>doNewGame()</code> at the start of the next game.</p>
   
<p>At the beginning of a game in <code>doNewGame()</code>, the program has to look at the number in the text
field to determine how much money the user wants to bet on the game.  Several things
can go wrong at this time: The text in the box might not be a legal integer,
the amount might be more money than the user has, and the value might be less than or
equal to zero.  Each of these possibilities has to be tested, and, if an error is detected,
an error message has to be shown to the user and no new game is started.
It's a little complicated:</p>
   
<pre>try {  // get the amount of the user's bet and check for errors
    betAmount = Integer.parseInt(betInput.getText());
}
catch (NumberFormatException e) {
    message = "Bet amount must be an integer!";
    betInput.requestFocus();
    betInput.selectAll();
    drawBoard();
    return;
}
if (betAmount > usersMoney) {
    message = "The bet amount can't be more than you have!";
    betInput.requestFocus();
    betInput.selectAll();
    drawBoard();
    return;
}
if (betAmount &lt;= 0) {
    message = "The bet has to be a positive number";
    betInput.requestFocus();
    betInput.selectAll();
    drawBoard();
    return;
}</pre>

<np>If the program gets past all of these tests, it starts the game as it did in the old program.</np>
  
<p>When the game ends for any reason, the user's money has to be adjusted. There are many points
in the source code where the game ends. In each of those places, I inserted a line
"<code>usersMoney = usersMoney + betAmount</code>" if the user won or
"<code>usersMoney = usersMoney - betAmount</code>" if the user lost.  It might
have been a good idea to write another subroutine to handle this task.</p>
   
<p>I also added some code to the <code>drawBoard()</code> method to display
the user's current amount of money. To accommodate this, this version of the panel is
25 pixels taller than the previous version.</p>

<p>If the first game has not started, <code>drawBoard()</code> draws a welcome
message instead of showing the user's and dealer's hands.  There is the question
of how to test whether the first game has started.  The obvious (and perhaps best)
way to handle that would have been to add another <ptype>boolean</ptype>
state variable such as <code>firstGameHasStarted</code>.  However, I used
the fact that <code>dealerHand</code> is <code>null</code> before the first
game starts (and only then). So <code>drawBoard()</code> can test whether
<code>dealerHand</code> is <code>null</code> to decide whether to draw the
welcome message.</p>

</exercise-discuss>
<exercise-code>
<p>Here is the new version of the Blackjack source code, with changes from
<localref href="GUI1.ex.9"/> shown in &newcodestyle;:</p>
<pre>
<prog name="BlackjackGUI2">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
<newcode>import javafx.scene.control.Label;
import javafx.scene.control.TextField;</newcode>
import javafx.scene.image.Image;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

/**
 * In this program, the user plays a game of Blackjack.  The
 * computer acts as the dealer.  The user plays by clicking
 * "Hit!" and "Stand!" buttons.  <newcode>The user can place bets.
 * At the beginning of the game, the user is given $100.</newcode>
 *
 * This program depends on the following classes:  Card, Hand,
 * BlackjackHand, Deck.  It also requires the image resource
 * file cards.png.
 */
public class BlackjackGUI2 extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------

    private Deck deck;         // A deck of cards to be used in the game.

    private BlackjackHand dealerHand;   // Hand containing the dealer's cards.
    private BlackjackHand playerHand;   // Hand containing the user's cards.

    private Button hitButton, standButton, newGameButton;

    <newcode>private TextField betInput;  // An input box for the user's bet amount.</newcode>

    private String message; // A message drawn on the canvas, which changes
                            //    to reflect the state of the game.

    private boolean gameInProgress; // Set to true when a game begins and to false
                                    //   when the game ends.

    private Canvas board;     // The canvas were cards and messages are displayed.

    private Image cardImages;  // The image that contains all the cards in a deck.

    <newcode>private int usersMoney = 100;  // How much money the user currently has.

    private int betAmount;  // The amount the use bet on the current game,
                            //      when a game is in progress.</newcode>

    /**
     * The start() method() sets up the GUI and event handling.
     */
    public void start(Stage stage) {

        cardImages = new Image("cards.png");

        board = new Canvas(515, 415); 
            // space for 5 cards across and 2 cards down, 
            // with 20-pixel spaces between cards,
            // plus space for messages

        hitButton = new Button( "Hit!" );
        hitButton.setOnAction( e -> doHit() );
        standButton = new Button( "Stand!" );
        standButton.setOnAction( e -> doStand() );
        newGameButton = new Button( "New Game" );
        newGameButton.setOnAction( e -> doNewGame() );

        <newcode>betInput = new TextField("10");
        betInput.setPrefColumnCount(5);</newcode>

        HBox buttonBar = new HBox(6, hitButton, standButton, newGameButton,
                <newcode>new Label(" Your bet:"), betInput</newcode>);
        buttonBar.setStyle("-fx-border-color: darkred; -fx-border-width: 3px 0 0 0;" 
                + "-fx-padding: 8px; -fx-background-color:beige");
        buttonBar.setAlignment(Pos.CENTER);

        BorderPane root = new BorderPane();
        root.setStyle("-fx-border-color: darkred; -fx-border-width: 3px");
        root.setCenter(board);
        root.setBottom(buttonBar);

        <newcode>setGameInProgress(false);</newcode>
        drawBoard();

        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle("Blackjack");
        stage.setResizable(false);
        stage.show();

    }  // end start()


    <newcode>/**
     * This method is called whenever the value of the gameInProgress
     * property has to be changed.  In addition to setting the value
     * of the gameInProgress variable, it also enables and disables
     * the buttons and text input box to reflect the state of the game.
     * @param inProgress The new value of gameInProgress.
     */
    private void setGameInProgress( boolean inProgress ) {
        gameInProgress = inProgress;
        if (gameInProgress) {
            hitButton.setDisable(false);
            standButton.setDisable(false);
            newGameButton.setDisable(true);
            betInput.setEditable(false);
            hitButton.requestFocus();
        }
        else {
            hitButton.setDisable(true);
            standButton.setDisable(true);
            newGameButton.setDisable(false);
            betInput.setEditable(true);
            newGameButton.requestFocus();
        }
    }</newcode>


    /**
     * This method is called when the user clicks the "Hit!" button.  First 
     * check that a game is actually in progress.  If not, give  an error 
     * message and exit.  Otherwise, give the user a card.  The game can end 
     * at this point if the user goes over 21 or if the user has taken 5 cards 
     * without going over 21.
     */
    void doHit() {
        if (gameInProgress == false) {
                <newcode>// Should be impossible, since the Hit button
                // is disabled when it is not legal to use it.</newcode>
            message = "Click \"New Game\" to start a new game.";
            drawBoard();
            return;
        }
        playerHand.addCard( deck.dealCard() );
        if ( playerHand.getBlackjackValue() > 21 ) {
            <newcode>usersMoney = usersMoney - betAmount;
            message = "You've busted!  Sorry, you lose.";
            setGameInProgress(false);</newcode>
        }
        else if (playerHand.getCardCount() == 5) {
            <newcode>usersMoney = usersMoney + betAmount;
            message = "You win by taking 5 cards without going over 21.";
            setGameInProgress(false);</newcode>
        }
        else {
            message = "You have " + playerHand.getBlackjackValue() + ".  Hit or Stand?";
        }
        drawBoard();
    }


    /**
     * This method is called when the user clicks the "Stand!" button.
     * Check whether a game is actually in progress.  If it is, the game 
     * ends.  The dealer takes cards until either the dealer has 5 cards 
     * or more than 16 points.  Then the  winner of the game is determined. 
     */
    void doStand() {
        if (gameInProgress == false) {
                <newcode>// Should be impossible, since the Stand button
                // is disabled when it is not legal to use it.</newcode>
            message = "Click \"New Game\" to start a new game.";
            drawBoard();
            return;
        }
        <newcode>setGameInProgress(false);</newcode>
        while (dealerHand.getBlackjackValue() &lt;= 16 &amp;&amp; dealerHand.getCardCount() &lt; 5)
            dealerHand.addCard( deck.dealCard() );
        if (dealerHand.getBlackjackValue() > 21) {
            <newcode>usersMoney = usersMoney + betAmount;</newcode> 
            message = "You win!  Dealer has busted with " + dealerHand.getBlackjackValue() + ".";
        }
        else if (dealerHand.getCardCount() == 5) {
            <newcode>usersMoney = usersMoney - betAmount; </newcode>
            message = "Sorry, you lose.  Dealer took 5 cards without going over 21.";
        }
        else if (dealerHand.getBlackjackValue() > playerHand.getBlackjackValue()) {
            <newcode>usersMoney = usersMoney - betAmount;</newcode>
            message = "Sorry, you lose, " + dealerHand.getBlackjackValue()
                                   +    " to " + playerHand.getBlackjackValue() + ".";
        }
        else if (dealerHand.getBlackjackValue() == playerHand.getBlackjackValue()) {
            <newcode>usersMoney = usersMoney - betAmount; </newcode>
            message = "Sorry, you lose.  Dealer wins on a tie.";
        }
        else {
            <newcode>usersMoney = usersMoney + betAmount; </newcode>
            message = "You win, " + playerHand.getBlackjackValue()
                          + " to " + dealerHand.getBlackjackValue() + "!";
        }
        drawBoard();
    }


    /**
     * Called by the constructor, and called by doNewGame().  Start a new game.  
     * Deal two cards to each player.  The game might end right then  if one 
     * of the players had blackjack.  Otherwise, gameInProgress is set to true 
     * and the game begins.
     */
    void doNewGame() {
        if (gameInProgress) {
                // If the current game is not over, it is an error to try
                // to start a new game.  <newcode>Should be impossible, since
                // the New Game button is disabled when it is not legal to use it.</newcode>
            message = "You still have to finish this game!";
            drawBoard();
            return;
        }
        <newcode>if (usersMoney == 0) { // User is broke; give the user another $100.
            usersMoney = 100;
        }
        try {  // get the amount of the user's bet and check for errors
            betAmount = Integer.parseInt(betInput.getText());
        }
        catch (NumberFormatException e) {
            message = "Bet amount must be an integer!";
            betInput.requestFocus();
            betInput.selectAll();
            drawBoard();
            return;
        }
        if (betAmount > usersMoney) {
            message = "The bet amount can't be more than you have!";
            betInput.requestFocus();
            betInput.selectAll();
            drawBoard();
            return;
        }
        if (betAmount &lt;= 0) {
            message = "The bet has to be a positive number";
            betInput.requestFocus();
            betInput.selectAll();
            drawBoard();
            return;
        }</newcode>
        deck = new Deck();   // Create the deck and hands to use for this game.
        dealerHand = new BlackjackHand();
        playerHand = new BlackjackHand();
        deck.shuffle();
        dealerHand.addCard( deck.dealCard() );  // Deal two cards to each player.
        dealerHand.addCard( deck.dealCard() );
        playerHand.addCard( deck.dealCard() );
        playerHand.addCard( deck.dealCard() );
        if (dealerHand.getBlackjackValue() == 21) {
            message = "Sorry, you lose.  Dealer has Blackjack.";
            <newcode>usersMoney = usersMoney - betAmount; 
            setGameInProgress(false);</newcode>
        }
        else if (playerHand.getBlackjackValue() == 21) {
            message = "You win!  You have Blackjack.";
            <newcode>usersMoney = usersMoney + betAmount;  
            setGameInProgress(false);</newcode>
        }
        else {
            message = "You have " + playerHand.getBlackjackValue() + ".  Hit or stand?";
            setGameInProgress(true);
        }
        drawBoard();
    }  // end newGame();


    /**
     * The drawBoard() method shows the message<newcode>s</newcode> at the bottom of the
     * canvas, and it draws all of the dealt cards spread out
     * across the canvas.  <newcode>If the first game has not started, it shows
     * a welcome message instead of the cards.</newcode>
     */
    public void drawBoard() {

        GraphicsContext g = board.getGraphicsContext2D();
        g.setFill( Color.DARKGREEN);
        g.fillRect(0,0,board.getWidth(),board.getHeight());

        g.setFont( Font.font(16) );

        <newcode>// Draw a message telling how much money the user has.

        g.setFill(Color.YELLOW);
        if (usersMoney > 0) {
            g.fillText("You have $" + usersMoney, 20, board.getHeight() - 45);
        }
        else {
            g.fillText("YOU ARE BROKE!  (I will give you another $100.)", 
                    20, board.getHeight() - 45 );
            usersMoney = 100;
        }</newcode>

        g.setFill( Color.rgb(220,255,220) );

        <newcode>if (dealerHand == null) {
                // The first game has not yet started.
                // Draw a welcome message and return.
            g.setFont( Font.font(30) );
            g.fillText("Welcome to Blackjack!\nPlace your bet and\nclick \"New Game\".", 40,80);
            return;  
        }</newcode>

        // Draw the message at the bottom of the canvas.

        g.fillText(message, 20, board.getHeight() - 20);

        // Draw labels for the two sets of cards.

        g.fillText("Dealer's Cards:", 20, 27);
        g.fillText("Your Cards:", 20, 190);

        // Draw dealer's cards.  Draw first card face down if
        // the game is still in progress,  It will be revealed
        // when the game ends.

        if (gameInProgress)
            drawCard(g, null, 20, 40);
        else
            drawCard(g, dealerHand.getCard(0), 20, 40);
        for (int i = 1; i &lt; dealerHand.getCardCount(); i++)
            drawCard(g, dealerHand.getCard(i), 20 + i * 99, 40);

        // Draw the user's cards.

        for (int i = 0; i &lt; playerHand.getCardCount(); i++)
            drawCard(g, playerHand.getCard(i), 20 + i * 99, 206);

    }  // end drawBoard();


    /**
     * Draws a card with top-left corner at (x,y).  If card is null,
     * then a face-down card is drawn.  The cards images are from 
     * the file cards.png; this program will fail without it.
     */
    private void drawCard(GraphicsContext g, Card card, int x, int y) {
        int cardRow, cardCol;
        if (card == null) {  
            cardRow = 4;   // row and column of a face down card
            cardCol = 2;
        }
        else {
            cardRow = 3 - card.getSuit();
            cardCol = card.getValue() - 1;
        }
        double sx,sy;  // top left corner of source rect for card in cardImages
        sx = 79 * cardCol;
        sy = 123 * cardRow;
        g.drawImage( cardImages, sx,sy,79,123, x,y,79,123 );
    } // end drawCard()


} // end class BlackjackGUI2
</prog></pre>
</exercise-code>
</exercise>

</exercises>